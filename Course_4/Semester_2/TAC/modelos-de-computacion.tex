\chapter{Modelos de Computación}\label{ch:modelos-de-computación}
Es un modelo que describe la estructura que hace posible computar una salida a partir de una entrada, conocido como modelo, se puede medir la complejidad de un algoritmo que resuelve un problema.

Un modelo recibe como entrada una instancia, aplica un algoritmo y se obtiene una salida, analizando este proceso se determina la complejidad.

Algunos modelos de computación:
\begin{itemize}
    \item Automatas Finitos (AFD)
    \item Automatas de Pila (AP)
    \item Máquinas de Turing (MT)
    \item Random Access Machine (RAM)
    \item Automatas Celulares (AC)
\end{itemize}

\textbf{Turing Completo:} Un modelo es Turing-completo si puede computar (resolver) las mismas funciones (problemas) que una Máquina de Turing.
\begin{itemize}
    \item AFD y AP NO son Turing Completos.
    \item RAM, $\lambda$-calculus y Automatas Celulares son Turing Completos.
\end{itemize}

Un problema No-Turing-Decidible aunque se cambie el modelo de computación no lo va a dejar de ser.

La MT es el modelo de modelos. La MT es muy potente en capacidad de resolver problemas, pero muy ineficiente en cómputo, por lo que utilizar otras puede resultar más eficiente, pero no son más capaces.

\section{Automatas Finitos (AFD)}
Se definen mediante: ($\Sigma$, Q, f, $q_0$, F)
\begin{itemize}
    \item $\Sigma$: alfabeto de entrada.
    \item Q: conjunto de estados.
    \item f: función de transición.
    \item $q_0$: estado inicial, $q_0 \in Q$.
    \item F: conjunto de estados finales, F $\subset$ Q.
\end{itemize}

Pueden ser Deterministas (AFD) y No Deterministas (AFN). Se puede pasar un AFN a un AFD.

Es No Determinista si:
\begin{itemize}
    \item Para un mismo signo en un estado haya más de una transición.
    \item Transitar con $\lambda$.
    \item ?No hay estado final?
\end{itemize}

El problema de estas máquinas es que no tiene memoria, por lo que no pueden recordar.

\section{Automata de Pila (AP)}
Se definen mediante: ($\Sigma$, $\Gamma$, Q, $A_0$, $q_0$, f, F)
\begin{itemize}
    \item $\Sigma$: alfabeto de entrada.
    \item $\Gamma$: alfabeto de pila (normalmente son mayúsculas).
    \item Q: conjunto de estados.
    \item $A_0$: conjunto de estados de la pila inicial, $A_0 \subset Q$.
    \item $q_0$: estado inicial, $q_0 \in Q$.
    \item f: función de transición.
    \item F: conjunto de estados finales, F $\subset$ Q.
\end{itemize}

Un APN NO se puede pasar a APD.

\section{Generalizaciones de las Máquinas de Turing}
Toda posible generalización de la Máquina de Turing se puede simular con una máquina de Turing: 
\begin{itemize}
    \item Determinista, 
    \item con cinta infinita en ambos sentidos, y \item donde el alfabeto de la cinta es {1,0, b} (b es celda vacía, en blanco)
\end{itemize}

\section{Random Access Machine Model (RAM)}
También conocido como Máquina de Registros.

Modelo abstracto de los computadores digitales. Reflejan más los aspectos de la computación real que las MT.

MT debe recorrer las celdas anteriores a una concreta para leerla, esta, sin embargo, puede acceder directamente a los registros al estar numerados.

Estructura:
\begin{itemize}
    \item $R_0$, $R_1$, ...; Un número ilimitado de registros (celdas). Capaz de almacenar un entero cualquiera.
    \item $I_0$, $I_1$, ...; La entrada es un conjunto finito de datos, no almacenados en los registros.
    \item \textbf{Programa:} Es un conjunto finito de instrucciones, que no están almacenados en los registros. Almacenado en un número finito de registros, y uno adicional, denominado Program Counter (PC).
\end{itemize}

Conjunto de posibles instrucciones (cada operación aumenta el PC, excepto el salto condicional que llega a un determinado valor):
\begin{itemize}
    \item $R_i \leftarrow R_j$ Asignación
    \item $<R_i> \leftarrow R_j$ y $R_i \leftarrow <R_j>$ Direccionamiento indirecto ($<R_i>$ valor almacenado en la celda con dirección almacenada en $R_i$)
    \item $R_i \leftarrow R_j + R_k$ Suma
    \item $R_i \leftarrow R_j - R_k$ Resta
    \item $R_i \leftarrow R_j \textit{ bool } R_k$ Operación booleana
    \item If $R_i$ comp $R_j$ label 1 else label 2 Salto condicional, para comp=comparación
\end{itemize}

Hay diferentes tipos de arquitecturas (como pasa con los tipos de MT) con las que se puede implementar: Counter Machine, Pointer Machine, Random Access Machine, Random Access Stored Program Machine.

\subsection{Random Access Stored Program (RASP)}
Es una máquina abstracta empleada para implementar algoritmos.

Se diferencia de la RAM, en que el programa está almacenado en los propios registros de la máquina. Los datos y las instrucciones están en la misma memoria (memoria de acceso aleatorio)
\begin{itemize}
    \item RAM $\rightarrow$ Arquitectura Von Harvard $\rightarrow$ Máquina de Turing.
    \item RASP $\rightarrow$ Arquitectura Von Neumann $\rightarrow$ Máquina de Turing Universal.
\end{itemize}

\section{Automatas Celulares}
Sucesión de sitios que contienen un valor numérico, que está determinado a seguir unas reglas que hacen evolucionar estos valores a lo largo del tiempo.

Es un modelo de un ''mundo'' con una física muy sencilla. El mundo está dividió en celdas (entramado de celdas).

El Automata Celular está gobernado por reglas que rigen la evolución del sistema en el tiempo.
\begin{itemize}
    \item El tiempo se considera Discreto (steps).
    \item Las reglas para el siguiente paso en el tiempo (t+1) se basan en el estado del autómata en el instante actual (t).
    \item El comportamiento de una celda se puede representar (computar) mediante un Automata Finito.
\end{itemize}

\textbf{AC Deterministas:} Las reglas no tienen componentes de aleatoriedad, dado el mismo estado inicial, siempre se obtendrán el mismo estado final.

\textbf{AC No Deterministas:} Sigue una aleatoriedad controlada, pero aleatoria.

Aplicaciones: Generadores de contenido multimedia, Generadores de números aleatorios, Desarrollo de Computadores paralelos y Supercomputación.

\subsection{AC Unidimensional}
Dimensión del AC: Dimensiones del entramado que forman el conjunto de celdas.

En una dimensión, hay 3 configuraciones:
\begin{itemize}
    \item Secuencia finita: Hay posibles estados finitos.
    \item Anillo: Siempre vuelve al mismo estado.
    \item Secuencia infinita: El cambio siempre es diferente.
\end{itemize}

Las Reglas dependen del estado que tenga la celda $x_i$ en el instante anterior y del estado del vecindario (izq. y dch.) en el instante anterior.

Rule 50 y 30, ejemplo de reglas que con vecindario de las celdas adyacentes (3 valores) define que valor tomara la siguiente, la distribución será el valor en binario 50 o 30 escritos de menos a más significativo de arriba a abajo.

\section{Máquinas de Turing}
Se definen mediante: (Q, $\Gamma$, b, $\Sigma$, $\delta$, $q_0$, F)
\begin{itemize}
    \item Q: conjunto de estados.
    \item $\Gamma$: alfabeto de cinta.
    \item b: símbolo en blanco, b $\in$ $\Gamma$.
    \item $\Sigma$: alfabeto de entrada.
    \item $\delta$: función de transición.
    \item $q_0$: estado inicial, $q_0 \in Q$.
    \item F: conjunto de estados finales, F $\subset$ Q.
\end{itemize}

\subsection{Origen}
Formulada por Turing como un medio para formalizar el proceso sistemático de resolver problemas de un matemático.

En sentido más amplio: Para representar cualquier Algoritmo, por precaución hablamos de Procedimientos Efectivos para resolver un problema.

Actualmente, es una máquina evolucionada en base a contribuciones de Post, Turing y otros.

\subsection{Utilidad}
Turing se sirvió de ella para desarrollar diversas cuestiones: 
\begin{itemize}
    \item Máquina de Turing Universal.
    \item Problema de la parada (demostración computacional) en equivalencia con el Entscheidungsproblem de Gödel.
    \item Modelo Universal de Computación.
\end{itemize}

\subsection{Modelo de Computación Universal}
Las Máquinas de Turing definen un Modelo de Computación que es la base de los Lenguajes Imperativos y Procedimentales.
\pagebreak

Suposiciones previas:
\begin{itemize}
    \item MT de cinta infinita
    \item Alfabeto$=\{b,1\}$ siendo b o $\#$ representan celda en blanco
    \item Alfabeto auxiliar con símbolos de marcado $\{\$, X, etc\}$
    \item Se representan Números Naturales en base 1
\end{itemize}

\subsubsection{Aritmética de Peano} 
Conjunto axiomático que sirve para definir los Números naturales
\begin{itemize}
    \item R0 - Objeto inicial. 0 es un objeto especial y es un Número Natural.
    \item R1 - Sucesor. Para cada n NN existe otro NN $succ(n)$.
    \item R2 - Predecesor. Si a es $succ(b)$ entonces b es $pred(a)$.
    
    Ojo con $pred(k=1)$, no está definido si no incluimos 0
    \item R3 - Única. No hay dos NN diferentes con el mismo sucesor.
    \item R4 - Igualdad. Comparar a y b NN en cuanto a igualdad.
    \begin{itemize}
        \item Reflexiva $Eq(a,a)$
        \item Simétrica $Eq(a,b) \Leftrightarrow Eq(b,a)$
        \item Transitiva $Eq(a,b), Eq(b,c) \Leftrightarrow Eq(a,c)$
    \end{itemize}
    \item R5 - Inducción. Predicado $P(n)$ es cierto $\forall n$ si cumple: 
    
    $P(0)$ cierta.
    
    $P(n)$ cierta para algún n y se puede demostrar que $P(succ(n))$ es cierta.
\end{itemize}

\subsection{Eficiencia}
No, no busca la eficiencia.

La MT es un modelo de computación abstracta.

Igual sabe hacer cosas que podríamos calcular de otra manera. No obstante, vamos a estudiar la eficiencia $\Rightarrow$ Coste Computacional.
\pagebreak

\subsection{Coste Computacional con MT}
Uso para el Análisis del Coste Computacional de Algoritmos.

\subsubsection{Ventajas}
\begin{itemize}
    \item Propone un modelo único, al contrario que con el uso de un Lenguaje X y una CPU Y
    \item No hay dudas sobre el coste del Paso Base
\end{itemize}

\subsubsection{Desventaja}
\begin{itemize}
    \item Es muy pesado para algoritmos complejos $\Rightarrow$ Limitaremos el tamaño de las MT
\end{itemize}

\subsubsection{Propósito}
\begin{itemize}
    \item Relacionar conceptos vistos en la asignatura.
    \item En base a un modelo muy sencillo
    \item Abstraer de construcciones de muy alto nivel
\end{itemize}

\subsubsection{Marco necesario para el Análisis}
\begin{itemize}
    \item MT de cinta infinita hacia ambos lados
    \item Alfabeto determinado, en principio con pocos símbolos, pero pueden ser más
    \item Una instancia de un Problema se describirá con una cinta de Entrada
    \item El número de símbolos de la Entrada define el Tamaño de la Instancia
    \item Coste de Paso Base: Una Transición con su Lectura/Escritura y Desplazamiento
\end{itemize}

\subsubsection{Coste computacional empírico: Aplicando diferencias finitas}
\begin{table}[H]
    \begin{tabular}{|l|l|l|l|l|l|l|}
    \hline
    Tamaño n                  & \textbf{1} & \textbf{3} & \textbf{5} & \textbf{7} & \textbf{9} & \textbf{11} \\ \hline
    \textbf{Pasos}            & 2          & 9          & 20         & 35         & 54         & 77          \\ \hline
    \textbf{A: T(n) - T(n-2)} &            & 7          & 11         & 15         & 19         & 23          \\ \hline
    \textbf{B: A(n) - A(n-2)} &            &            & 4          & 4          & 4          & 4           \\ \hline
    \textbf{C: B(n) - B(n-2)} &            &            &            & 0          & 0          & 0           \\ \hline
    \end{tabular}
    \caption{Diferencias finitas}
\end{table}

Si $T(n)$ \textbf{exponencial}, las diferencias finitas no se anulan, pero aparecen comportamientos particulares.

Si $T(n)$ \textbf{polinómico} de orden k, las diferencias finitas de orden $k=cte$. En este caso orden 2.

Sabiendo el orden se plantea un polinomio genérico de ese orden: $T(n)=xn^2+bn+c$.

Se resuelve la ecuación y ya tenemos la complejidad.

$$a+b+c=2;\; 9a+3b+c=9;\; 25a+5b+c=20 \Rightarrow a=\frac{1}{2},\; b=\frac{3}{2},\; c=0$$

$$T(n)=\frac{1}{2}n^2+\frac{3}{2}n$$

\subsubsection{Coste computacional empírico: Recursivamente}
Se plantean las observaciones y observan los patrones de los datos.

\begin{itemize}
    \item $n=1 \Rightarrow 2$ pasos
    \item $n=3 \Rightarrow 4$ pasos a derecha $+ 3$ a izquierda $+ T(1)$
    \item $n=5 \Rightarrow 6$ pasos a derecha $+ 6$ a izquierda $+ T(3)$
    \item $n \Rightarrow n+1$ pasos a derecha $+ n+1$ a izquierda $+ T(n-2) = \Sigma i \Rightarrow T(n)=\frac{(n+1)(n+2)}{2}-1=\frac{1}{2}n^2+\frac{3}{2}n$ 
\end{itemize}

\subsection{Variantes del Modelo de Máquina de Turing}
Abordamos:
\begin{itemize}
    \item Máquinas de Turing de dos o más cintas (multicinta)
    \item Máquinas de Turing No Deterministas
    \item Automata de Dos Pilas
    \item Máquinas de Turing 2D
    \item Aplicaciones
    \item Costes Computacionales
\end{itemize}

\subsubsection{Máquinas de Turing de Dos Cintas}
La misma estructura que una MT convencional, pero:
\begin{itemize}
    \item Tiene dos cintas y sus respectivos cabezales
    \item Pueden operar de forma independiente
\end{itemize}

Implica cambios en el funcionamiento, las transiciones se definen:
\begin{itemize}
    \item Cambio de estado
    \item Para cabezales
    \begin{itemize}
        \item Una Lectura
        \item Una Escritura
        \item Un Desplazamiento
    \end{itemize}
\end{itemize}

Las operaciones de cada cabezal son independientes entre sí, pero están vinculados en cada transición.

\subsubsection{Máquinas de Turing No Deterministas}
La misma estructura que una MT convencional, pero
\begin{itemize}
    \item Admiten transiciones No Deterministas, es decir, para un mismo símbolo leído define al menos dos transiciones que:
    \begin{itemize}
        \item Escriben símbolos diferentes
        \item Desplazan el cabezal de distinta forma
        \item Transitan a estados diferentes
    \end{itemize}
\end{itemize}

Cuando se encuentra una transición ND, entendemos que la MT bifurca en dos o más instancias de la misma que adoptaran estados diferentes.

Si alguna de las instancias alcanza un Estado Final $\Rightarrow$ MT acepta