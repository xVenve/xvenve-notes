\documentclass[12pt, twoside, openright]{report} % Fuente a 12pt, formato doble página y chapter a la derecha
\raggedbottom % No ajustar el contenido con un salto de página

% MÁRGENES: 2,5 cm sup. e inf.; 3 cm izdo. y dcho.
\usepackage[
a4paper,
vmargin=2.5cm,
hmargin=3cm
]{geometry}

% INTERLINEADO: Estrecho (6 ptos./interlineado 1,15) o Moderado (6 ptos./interlineado 1,5)
\renewcommand{\baselinestretch}{1.15}
\parskip=6pt

% DEFINICIÓN DE COLORES para portada y listados de código
\usepackage[table]{xcolor}
\definecolor{azulUC3M}{RGB}{0,0,102}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

% Soporte para GENERAR PDF/A
\usepackage{etoolbox}
\makeatletter
\@ifl@t@r\fmtversion{2021-06-01}%
 {\AddToHook{package/after/xmpincl}
   {\patchcmd\mcs@xmpincl@patchFile{\if\par}{\ifx\par}{}{\fail}}}{}
\makeatother
\usepackage[a-1b]{pdfx}

% ENLACES
\usepackage{hyperref}
\hypersetup{colorlinks=true,
  linkcolor=black, % enlaces a partes del documento (p.e. índice) en color negro
  urlcolor=blue} % enlaces a recursos fuera del documento en azul

% Añadir pdfs como partes del documento
\usepackage{pdfpages}

% Quitar la indentación de principio de los párrafos
\setlength{\parindent}{0em}

% EXPRESIONES MATEMÁTICAS
\usepackage{amsmath,amssymb,amsfonts,amsthm}

\usepackage{txfonts} 
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

% Insertar gráficas y fotos
\usepackage{tikz}
\usepackage{pgfplots}

\usepackage[spanish, es-tabla]{babel} 
\usepackage[babel, spanish=spanish]{csquotes}
\AtBeginEnvironment{quote}{\small}

% diseño de PIE DE PÁGINA
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\fancyfoot[LE,RO]{\thepage}
\fancypagestyle{plain}{\pagestyle{fancy}}

% DISEÑO DE LOS TÍTULOS de las partes del trabajo (capítulos y epígrafes o subcapítulos)
\usepackage{titlesec}
\usepackage{titletoc}
\titleformat{\chapter}[block]
{\large\bfseries\filcenter}
{\thechapter.}
{5pt}
{\MakeUppercase}
{}
\titlespacing{\chapter}{0pt}{0pt}{*3}
\titlecontents{chapter}
[0pt]                                               
{}
{\contentsmargin{0pt}\thecontentslabel.\enspace\uppercase}
{\contentsmargin{0pt}\uppercase}                        
{\titlerule*[.7pc]{.}\contentspage}                 

\titleformat{\section}
{\bfseries}
{\thesection.}
{5pt}
{}
\titlecontents{section}
[5pt]                                               
{}
{\contentsmargin{0pt}\thecontentslabel.\enspace}
{\contentsmargin{0pt}}
{\titlerule*[.7pc]{.}\contentspage}

\titleformat{\subsection}
{\normalsize\bfseries}
{\thesubsection.}
{5pt}
{}
\titlecontents{subsection}
[10pt]                                               
{}
{\contentsmargin{0pt}                          
  \thecontentslabel.\enspace}
{\contentsmargin{0pt}}                        
{\titlerule*[.7pc]{.}\contentspage}  

% DISEÑO DE TABLAS.
\usepackage{multirow} % permite combinar celdas 
\usepackage{caption} % para personalizar el título de tablas y figuras
\usepackage{floatrow} % utilizamos este paquete y sus macros \ttabbox y \ffigbox para alinear los nombres de tablas y figuras de acuerdo con el estilo definido. Para su uso ver archivo de ejemplo 
\usepackage{array} % con este paquete podemos definir en la siguiente línea un nuevo tipo de columna para tablas: ancho personalizado y contenido centrado
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\DeclareCaptionFormat{upper}{#1#2\uppercase{#3}\par}

% Diseño de tabla para ingeniería
\captionsetup[table]{
  format=hang,
  name=Tabla,
  justification=centering,
  labelsep=colon,
  width=.75\linewidth,
  labelfont=small,
  font=small,
}

% DISEÑO DE FIGURAS.
\usepackage{graphicx}
\graphicspath{{img/}} %ruta a la carpeta de imágenes

% Diseño de figuras para ingeniería
\captionsetup[figure]{
  format=hang,
  name=Fig.,
  singlelinecheck=off,
  labelsep=colon,
  labelfont=small,
  font=small    
}

% NOTAS A PIE DE PÁGINA
\usepackage{chngcntr} % Para numeración continua de las notas al pie
\counterwithout{footnote}{chapter}

% LISTADOS DE CÓDIGO
% soporte y estilo para listados de código. Más información en https://es.wikibooks.org/wiki/Manual_de_LaTeX/Listados_de_código/Listados_con_listings
\usepackage{listings}

% definimos un estilo de listings
\lstdefinestyle{estilo}{ frame=Ltb,
  framerule=0pt,
  aboveskip=0.5cm,
  framextopmargin=3pt,
  framexbottommargin=3pt,
  framexleftmargin=0.4cm,
  framesep=0pt,
  rulesep=.4pt,
  backgroundcolor=\color{gray97},
  rulesepcolor=\color{black},
  %
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\bfseries,
  stringstyle=\ttfamily,
  showstringspaces = false,
  commentstyle=\color{gray45},     
  %
  numbers=left,
  numbersep=15pt,
  numberstyle=\tiny,
  numberfirstline = false,
  breaklines=true,
  xleftmargin=\parindent
}

\captionsetup[lstlisting]{font=small, labelsep=period}
% fijamos el estilo a utilizar 
\lstset{style=estilo}
\renewcommand{\lstlistingname}{\uppercase{Código}}

\pgfplotsset{compat=1.17} 
%-------------
% DOCUMENTO
%-------------

\begin{document}
\pagenumbering{roman} % Se utilizan cifras romanas en la numeración de las páginas previas al cuerpo del trabajo

%----------
% PORTADA
%---------- 
\begin{titlepage}
	\begin{sffamily}
		\color{azulUC3M}
		\begin{center}
			\begin{figure}[H] %incluimos el logotipo de la Universidad
				\makebox[\textwidth][c]{\includegraphics[width=16cm]{Portada_Logo.png}}
			\end{figure}
			\vspace{2.5cm}
			\begin{Large}
				Grado en Ingeniería Informática\\
				2021-2022\\
				\vspace{2cm}
				\textsl{Apuntes}\\
				\bigskip
			\end{Large}
			{\Huge Ingeniería del Conocimiento}\\
			\vspace*{0.5cm}
			\rule{10.5cm}{0.1mm}\\
			\vspace*{0.9cm}
			{\LARGE Jorge Rodríguez Fraile\footnote{\href{mailto:100405951@alumnos.uc3m.es}{Universidad: 100405951@alumnos.uc3m.es}  |  \href{mailto:jrf1616@gmail.com}{Personal: jrf1616@gmail.com}}}\\
			\vspace*{1cm}
		\end{center}
		\vfill
		\color{black}
		\includegraphics[width=4.2cm]{img/creativecommons.png}\\
		Esta obra se encuentra sujeta a la licencia Creative Commons\\ \textbf{Reconocimiento - No Comercial - Sin Obra Derivada}
	\end{sffamily}
\end{titlepage}

%----------
% ÍNDICES
%---------- 

%--
% Índice general
%-
\tableofcontents
\thispagestyle{fancy}

%--
% Índice de figuras. Si no se incluyen, comenta las líneas siguientes
%-
\listoffigures
\thispagestyle{fancy}

%--
% Índice de tablas. Si no se incluyen, comenta las líneas siguientes
%-
\listoftables
\thispagestyle{fancy}

%----------
% TRABAJO
%---------- 

\pagenumbering{arabic} % numeración con números arábigos para el resto de la publicación  


%----------
% COMENZAR A ESCRIBIR AQUI
%---------- 

\chapter{Información}

\section{Profesores}
\begin{quote}
	Teoría y coordinadora: Susana Fernández Arregui, sfarregu@inf.uc3m.es, enviar mail con tiempo para pedir tutorías.
	
	Prácticas: Alba Gragera Álvarez, agragera@pa.uc3m.es
\end{quote}

\section{Presentación}
Asistencia no obligatoria.

\textbf{Taller:} tareas/ejercicios autoevaluados (nosotros hacemos el ejercicio y después otro compañero lo evalúa) semanales, para llevar la asignatura al día. Seguir los plazos, para que esta dinámica se pueda seguir.
Wooclap que se realizaran en clase, para seguir el temario.

\subsection{Objetivos}
\begin{itemize}
	\item Aprender a diseñar e implementar Sistemas basados en el Conocimiento.
	\item Aprender a identificar problemas, no se nos dará el problema que debemos resolver sino que nos los encontraremos y solucionaremos (antigua mentalidad). Aprender para crear empleo no para trabajar en un empleo.
	\item Analizaremos como obtener el conocimiento de los expertos, lograr conceptualizarlo y formalizarlo para hacerlo accesible.
	\item Aprender a diseñar e implementar ontologías.
	\item Analizar las técnicas más utilizadas para implementar SBC.
	\item Estudiaremos CLIP, una versión reducida.
	\item Aplicar los conocimientos teóricos a problemas complejos.
\end{itemize}
Lograremos adquirir, obtener, formalizar y representar el conocimiento humano en una forma computable para la resolución de problemas mediante un sistema informático en cualquier ámbito de aplicación.
También obtendremos soft-skill que nos permitirán destacar entre el resto de los graduados, como son la comunicación escrita y oral, flexibilidad, responsabilidad, trabajo en equipo.

\pagebreak
\subsection{Evaluación}
\begin{itemize}
	\item Habrá un examen de CLIP, día de asistencia obligatoria, un martes.
	\item 30 \% Examen final.
	      \begin{itemize}
		      \item Consistirán en formalizar y resolver un problema dado. También habrá preguntas relacionadas con las prácticas obligatorias.
		      \item Nota mínima de 4.
	      \end{itemize}
	\item 70 \% Teoría.
	      \begin{itemize}
		      \item Actividad individual relacionada con magistrales 15 \%, son la que se realizan peer-to-peer.
		            \begin{itemize}
			            \item Preguntas cortas de manera semanal.
			            \item Se reciben puntos por realizarlo 70 \% y un 30 \% por evaluar a un compañero (anónimamente).
			            \item Las notas se medirán en estrellas: 0, 2'5, 5, 7'5 o 10.
		            \end{itemize}
		      \item Practica obligatoria en parejas 30 \%, en las clases prácticas.
		      \item Actividad parcial 25 \%.
		            \begin{itemize}
			            \item Examen CLIPS y antologías 1 punto.
			            \item Actividades foro 1 punto, 0.25 entregas  y 0.25 por cada foro.
			            \item Entregas dominios de planificación 0.5 puntos.
			            \item Practica 1: Implementación en CLIPS 1.5 puntos.
			            \item Practica 2: Implementación en PDDL 1.5 puntos.
		            \end{itemize}
	      \end{itemize}
\end{itemize}

Prácticas dirigidas a conceptualizar (recoger todo el conocimiento, independientemente mediante el sistema que lo vayamos a realizar) e implementar el conocimiento, realizado mediante 2 prácticas.

\chapter{CLIPS}
\section{Introducción}
\textbf{CLIPS:} C Languaje Integrated Production System. Es la unión del lenguaje C y LIPS, de ahí su nombre.

Desarrollado por Software Technology Branch (STB) NASA desde 1986.

Combina los paradigmas de lenguajes declarativos, funcionales y orientados a objetos.

No tiene interfaz se utiliza a través del terminal, aparece \textit{CLIPS >}.

Distingue entre mayúsculas y minúsculas, todos los comandos se presentan entre paréntesis (todo va con paréntesis).

\subsection{Arquitectura de un sistema de producción}
\begin{itemize}
	\item \textbf{Base de Hechos o Memoria de Trabajo:} Representa conocimientos del dominio sobre el problema (hechos establecidos y metas a alcanzar). Según se ejecutan las reglas se va modificando, parte de esta es permanente (la inicial, no la del propio proceso).
	      
	      Representa el estado inicial, el conocimiento de manera declarativa (hechos e instancias).
	      
	      Los hechos pueden ser:
	      \begin{itemize}
		      \item \textbf{Ordered:} Con uno o varios campos, donde el primer campo marca la relación entre los restantes, por lo que el orden es importante. Sin nombre.
		      \item \textbf{Non-ordered:} Abstraer la estructura de un hecho asignando un nombre, el orden de los slots no afecta dado que van con nombre.
	      \end{itemize}
	\item \textbf{Base de Reglas:} Representa conocimiento sobre cómo conseguir la solución del problema en forma de reglas de producción. Las reglas dan información sobre cómo resolverlo.
	\item \textbf{Motor de Inferencia (MI):} Razona sobre el conocimiento del problema y sobre su solución. Determina como se aplican las reglas.
	      
	      \pagebreak
	      \textbf{Fases}
	      \begin{itemize}
		      \item \textbf{Fase de selección}
		            \begin{itemize}
			            \item \textbf{Restricción:} Acota el contenido de la Base de Reglas y la Base de Hechos según las características del programa.
			            \item \textbf{Equiparación:} Selección del conjunto de reglas candidatas para dispararse.
			                  
			                  \textbf{Equiparación de constantes}, son aquellas secuencias de caracteres no precedidas por ?. Deben ser exactamente iguales.
			                  
			                  \textbf{Equiparación de variables}, este proceso equipara las variables de la regla con los hechos en busca de patrones de hechos que ocupen las posicione especificadas. Es decir, ocupe la misma posición en ordered o el mismo nombre en non-ordered.
			                  
			                  El mismo hecho puede ser utilizado varias veces en una regla, a menos que se especifique con un test neq de ambas.
			                  
			            \item \textbf{Resolución del Conjunto Conflicto:} Selección de la instancia de regla que va a ejecutar.
			                  Conjunto conflicto: Conjunto de instancias de las posibles reglas ejecutables.
			                  
			                  \textbf{Estrategias de selección}
			                  \begin{itemize}
				                  \item \textbf{Orden de escritura:} Primera regla que cuyo antecedente es cierto según el orden de escritura en al BR.
				                  \item \textbf{Prioridad} (la regla más prioritaria)
				                  \item \textbf{Especificidad} (la regla más específica)
				                  \item \textbf{Novedad} (la regla con elementos de la BH más recientemente añadidos o modificado)
				                  \item Utilizar el \textbf{principio de refracción:} No se pueden ejecutar instancias de reglas ya disparadas
				                  \item \textbf{Arbitrariedad}
			                  \end{itemize}
			                  
			                  \textbf{Estrategias de inferencia}
			                  \begin{itemize}
				                  \item \textbf{Encadenamiento hacia delante} (dirigido por el antecedente), parte de unos hechos particulares (el contenido de la BH).
				                        
				                        Busca reglas cuyo antecedente esté satisfecho por esos hechos.
				                  \item \textbf{Encadenamiento hacia atrás} (dirigido por el consecuente), parte de un conjunto de metas u objetivos.
				                        
				                        Se buscan reglas cuya instanciación implica la consecución de una meta. La
				                        equiparación se realiza sobre el consecuente
				                        
				                        Si el antecedente equipara con la BH la meta se puede concluir
			                  \end{itemize}
			                  
		            \end{itemize}
		            
		            \pagebreak
		      \item \textbf{Fase de acción o ejecución}: La ejecución de una instancia de una regla modifica la Base de Hechos actual dando lugar a una Base de Hechos nueva al añadir, borrar o modificar. La nueva BH es el punto de partida para el siguiente ciclo.
		            
		            Por el principio de refracción nunca se ejecuta 2 veces la misma regla con los mismos hechos, entraría en bucle.
	      \end{itemize}
\end{itemize}

\subsection{Expresiones}
Se emplea una notación prefija, es decir primero la operación y después los operandos. Algunas funciones y operaciones matemáticas son $+ - / * \textit{mod div sqrt round integer}$.

\subsection{Tipos de datos}
\begin{itemize}
	\item NUMBER, INTEGER o FLOAT
	\item STRING
	\item SYMBOL, casos en los que tiene unos valores determinados
	\item EXTERNAL-ADDRESS
	\item FACT-ADDRESS
	\item INSTANCE-NAME
	\item INSTANCE-ADDRESS
\end{itemize}

\section{Hechos}
Son los elementos básicos del conocimiento y a cada uno CLIPS le asigna un identificador f-XX (fact-index).

El primer campo suele representar una relación entre las restantes, como (edad 14) o (padre-de Jose Alex).

Los campos sin valor se indican con \textit{nil}.

\pagebreak
\subsection{Comandos sobre hechos}
\begin{description}
	\item[(facts)] Base de hechos.
	\item[(assert hecho)] Añadir hechos a la base de hechos. Si se trata de introducir dos hechos iguales solo deja el último.
	\item[(retract índice-hecho)] Eliminar hechos de la base de hechos.
	\item[(modify dirección-hecho (nombre-atributo nuevo-valor))] Modifica el valor de un atributo. La dirección la podemos obtener buscando el hecho por algún atributo ?f <- (car (doors 2)).
	\item[(reset)] Eliminar todos los hechos de la memoria de trabajo, añade initial-fact e initial-object. Cuando comenzamos lo utilizamos para añadir los hechos y que se tengan en cuenta.
	\item[(clear)] Elimina todos los hechos y constructores.
	\item[(deffacts nombre comentarioOpcional hechos)] Definir los hechos iniciales, se añaden al hacer (reset).
\end{description}

\subsection{Plantillas o templates}
\textbf{(deftemplate nombre [comentario] slots-o-multislots)}

Permite asignar un nombre a cada campo.

Puede almacenar un único valor con slot o varios con multislot, para que un mismo nombre tenga varios valores.

\textbf{(slot/multislot nombre (type tipo) (allowed-values valoresPermitidos)/(range desde hasta) (default valor))}

Para obligar al usuario a que de valor a un slot al crear un hecho en default se pone el valor \textit{?NONE} y si queremos que CLIPS lo determine se pone \textit{?DERIVE}, aunque este último no se usa mucho.

\pagebreak
\section{Reglas}
\textbf{(defrule nombre [comentario] [(declare (salience valorPrioridad))] premisa-o-elemento-de-condición => acción)}

La premisa puede ser:
\begin{itemize}
	\item Un patrón que se encarga de consultar la existencia de un hecho en la Memoria de trabajo.
	\item Un test para comprobar el cumplimiento de una condición.
	\item Una negación para negar un patrón o test.
\end{itemize}

La acción puede ser:
\begin{itemize}
	\item Crear un hecho o instancia.
	\item Eliminar un hecho o instancia.
	\item Modificar un hecho o instancia.
	\item Parar el sistema de producción, halt.
	\item Asignar un valor a variable.
	\item Operaciones de entrada/salida.
	\item Llamar a función.
\end{itemize}

Para indicar la variable se pone ? delante del nombre de la variable y ?\$ si la variable es una lista.

En aquellos casos que queramos buscar por un atributo, pero no queramos almacenar el valor en variable se puede poner ? o ?\$ solo.

Al definir reglas ya existentes, la primera regla se borra.
\subsection{Elementos de condición (LHS)}
\begin{itemize}
	\item \textbf{Direcciones de hechos:} Almacenar la dirección de hechos en variables.
	      
	      ?P <- (persona (nombre ?N) (amigos \$?A) (edad 30))
	\item \textbf{Test:} Comprobar el cumplimiento de alguna condición.
	      
	      (test (>= (abs (- ?y ?x)) 3))
	\item \textbf{Not:} No existencia de un determinado hecho.
	      
	      (not (dato rojo ?x ?x))
\end{itemize}

\subsection{Acciones}
\begin{itemize}
	\item \textbf{Parada:} Para la ejecución del sistema.
	      
	      (halt)
	\item \textbf{bind:} Asignar valor a variables.
	      
	      (bind ?X (* ?Y 2))
\end{itemize}

\subsection{Comandos para reglas}
\begin{description}
	\item[(list-defrules)] Ver las reglas definidas.
	\item[(ppdefrule nombre-de-regla)] Ver la definición de la regla.
	\item[(undefrule nombre-de-regla)] Eliminar una regla.
	\item[(undefrule *)] Eliminar todas las reglas.
\end{description}

\subsection{Ejecución de reglas}
La colocación de una regla en la agenda se realiza según su prioridad y la estrategia de resolución de conflictos definida

\begin{description}
	\item[(agenda)] Para ver las reglas ejecutables.
	\item[(run)] Ejecutar las reglas seguidas.
	\item[(run veces)] Ejecutar <veces> reglas.
	\item[(matches nombre-regla)] Para ver que hechos se equiparan con los patrones de una regla.
	\item[(watch <item>)] Observación de la evolución de los componentes del sistema.
	\item[(unwatch <item>)] Desactivar el modo de observación.
	\item[set-break y remove-break] Para poner y quitar un breakpoint en la regla
	      que se les pasa como argumento.
\end{description}

Los item son: all compilations statistic messages deffunctions rules facts activations

\subsection{Estrategias de resolución de conflictos}
Se seleccionan con (set-strategy <estrategia>). La estrategia por omisión es depth.

Cuando no se determina tratara de usar el hecho más nuevo, es decir el último generado o modificado.

\begin{itemize}
	\item \textbf{depth (Profundidad):} Nuevas activaciones por encima de las de igual prioridad.
	\item \textbf{breadth (Amplitud):} Nuevas activaciones por debajo de las de igual prioridad.
	\item \textbf{simplicity:} Nuevas activaciones por encima de las activaciones con igual o mayor especificidad
	\item \textbf{complexity:} Nuevas activaciones por encima de las activaciones con igual o menor especificidad
	\item \textbf{random:} Aleatoria. A cada activación se le asigna un número aleatorio para determinar su orden en la agenda.
\end{itemize}

\subsection{Consideraciones}
No se trata de una estructura if-then-else, sino if-then. Si se quiere else se crean 2 reglas.

No puede haber OR en el consecuente, para suplirlo se crean 2 reglas.

No DEBEN aparecer OR en el antecedente, se crean 2 reglas con una parte del OR en cada una.

No se pueden anidar elementos de decisión (ifs), para esto se pueden usar señalizadores que activen reglas, no olvidar borrarlos.

Desde una regla no se puede lanzar otra.

\section{Funciones}
\begin{itemize}
	\item \textbf{open:} Abrir un fichero, en nombre de canal se puede poner una variable.
	      
	      (open nombre-fichero nombre-canal-asignado modo-acceso)
	\item \textbf{close:} Cerrar un fichero.
	      
	      (close nombre-canal)
	\item \textbf{read:} Leer de un canal.
	      
	      (read <nombre-canal>)
	\item \textbf{printout}
	      
	      Por pantalla: (printout t “Hello there!” crlf)
	      
	      En fichero: (printout file-name “red green”)
	\item \textbf{eq:} TRUE si los argumentos son iguales en valor y tipo, si no FALSE.
	\item \textbf{neq:} TRUE si alguno de los valores de las expresiones argumento es distinto, si no FALSE.
	\item \textbf{=, <>, <, >, <=, >=:} Funciones para argumentos numéricos.
	\item \textbf{and:} TRUE si los argumentos son TRUE.
	\item \textbf{or:} TRUE si alguno de los argumentos es TRUE.
	\item \textbf{not:} TRUE si el valor del argumento es FALSE.
\end{itemize}

\textbf{Modos de acceso:}
\begin{itemize}
	\item “r” solo lectura.
	\item “w” solo escritura.
	\item “r+” lectura y escritura.
	\item “a” escritura al final de fichero (append).
\end{itemize}

\textbf{Canales predefinidos:} stdin, stdout, werror.
\section{Marcos}
Se utilizan en aquellos casos de estructuras más complejas que puedan requerir herencia, para los sencillos se usan las plantillas.

\textbf{Declaración:} (defclass nombre (is-a nombre-padre) propiedades slots-o-multislots)

\textbf{Propiedades de la clase:} (role abstract/concrete) para que no se puedan crear instancias o si y (pattern-match non-reactive/reactive).

Los slots de las clases son los mismos que las plantillas, pero además están (create-accesor read-write) para modificarlo y (source composite) heredar todas las facetas del mismo slot que el padre para redefinir slots del padre.

El nombre de la clase padre inicial es INITIAL-OBJECT.

\subsection{Comandos para instancias}
\begin{itemize}
	\item \textbf{make-instance:} Añade una instancia.
	      
	      (make-instance of INTRODUCCIÓN (primitiva ESTAR))
	\item \textbf{unmake-instance:} Quita la instancia.
	      
	      (unmake-instance ?ins)
	\item \textbf{modify-instance:} Borra y crea instancias de la base de hechos.
	      
	      (modify-instance ?ins (orden 7))
	\item \textbf{instances:} Muestra las instancias de la base de hechos.
	      
	      [gen1] of INTRODUCCIÓN
	\item \textbf{(send [gen1] print):} Para ver valor de los slots.
\end{itemize}

\chapter{Tema 1: Introducción}
\section{Definición de Ingeniería del Conocimiento}

\textbf{Ingeniería de conocimiento:} Es la actividad de construir Sistemas Basados en el Conocimiento (SBC). Es el proceso para adquirir, estructurar, conceptualizar y después implementar un conjunto de conocimientos.

El conocimiento sobrevive a implementaciones y valorado en sí mismo.

Debe considerar la escalabilidad del sistema y el mantenimiento de este.

\subsection{Pirámide de Datos/Información/Conocimiento}
El pico es el metaconocimiento, en esta asignatura trataremos el conocimiento.

\textbf{Datos:} Gran volumen, pero de bajo valor, carecen de significado o contexto que los hagan más valiosos.

\textbf{Información:} Menor volumen, tienen valor al tener un contexto o significado asociado.

\textbf{Conocimiento:} Entender el dominio, pudiendo aplicarlo para resolver problemas. Se basan en la información que sale de los datos, pero este no se trata de meros datos sino de lo que subyace sobre estos.

\textbf{Metaconocimiento:} Es el conocimiento del conocimiento.

\section{Sistemas Basados en el Conocimiento y Sistemas Expertos}

\textbf{Sistema Basados en el Conocimiento (SBC):} Es un tipo de sistemas software, que tratan problemas cuyo método de resolución es más heurístico (guía hacia la solución de una manera más o menos buena, mediante el conocimiento previo del problema, en forma de una serie de reglas) que algorítmico y que contiene conocimientos públicos de un dominio. Lo clave es que es heurística y contiene conocimiento.

Es un sistema que usa conocimiento específico de un problema e intenta codificar el razonamiento que hacemos los humanos, como si fuera un experto, es decir juntando los datos e ir sacando conclusiones hasta llegar a la solución.

El conocimiento se presenta de manera declarativa (explicita). Los SBC son más heurístico que algorítmico.

El primer sistema que se puede llamar SBC es el General Problem Solver (GPS): H. Simon y A. Newell, 1957

\subsection{Actores participantes}
\begin{itemize}
	\item \textbf{Experto:} Es el que posee el conocimiento, como podría ser un libro.
	\item \textbf{Usuario:} Es el que usara el conocimiento.
	\item \textbf{Ingeniero de conocimiento:} Es el que se encarga de formalizar el conocimiento para que sea utilizado \item \textbf{Desarrollador}
	\item \textbf{Gestor del proyecto}
\end{itemize}

\subsection{Diferencias entre un SBC y un SST}
\textbf{SST:} Sistema de Software Tradicional.

\textbf{En arquitectura:} Los SBC siempre separan la parte de datos y la parte de resolución, sin embargo en SST están mezcladas.

\textbf{En tipo de problemas:} Los SBC resuelven problemas heurísticos y los SST dan soluciones algorítmicas.

\textbf{En técnicas de programación:} SBC emplea programación declarativa y los SST programación imperativa.

Lo más importante es que los SBC son capaces de explicar cuál es el proceso de razonamiento que ha empleado para llegar a la solución. Es posible al ser declarativo y la forma en la que se implementan permite ver qué proceso es el que ha seguido.

\subsection{Ingeniería del Software vs. Ingeniería del Conocimiento}
\begin{table}[H]
	\centering
	\caption{IS vs. IC}
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{l|l|l|}
			\cline{2-3}
			                                                          & \multicolumn{1}{c|}{\textbf{Ingeniería del Software}} & \multicolumn{1}{c|}{\textbf{Ingeniería del Conocimiento}} \\ \hline
			\multicolumn{1}{|l|}{\textbf{Dominios}}                   & Tratamiento eficaz de los datos                       & Conocimientos especializados                              \\ \hline
			\multicolumn{1}{|l|}{\textbf{Tipo de problemas}}          & Sistemáticos y procedimentales                        & Heurísticos y declarativos                                \\ \hline
			\multicolumn{1}{|l|}{\textbf{Entrada}}                    & Datos, procesos y algoritmos                          & Conocimiento humano                                       \\ \hline
			\multicolumn{1}{|l|}{\textbf{Técnica de programación}}    & \begin{tabular}[c]{@{}l@{}}Procedimentales sofisticados\\ secuenciales y rígidos\end{tabular}                            & \begin{tabular}[c]{@{}l@{}}Declarativos, elementales\\ paralelos y flexibles\end{tabular}                                \\ \hline
			\multicolumn{1}{|l|}{\textbf{\begin{tabular}[c]{@{}l@{}}Modelo de solución\\ de problemas\end{tabular}}} & \begin{tabular}[c]{@{}l@{}}Implícitamente en el\\ código del programa\end{tabular}                            & \begin{tabular}[c]{@{}l@{}}Explícitamente en la\\ Base de Conocimiento\end{tabular}                                \\ \hline
			\multicolumn{1}{|l|}{\textbf{\begin{tabular}[c]{@{}l@{}}Niveles organización\\ conocimientos\end{tabular}}} & \begin{tabular}[c]{@{}l@{}}1. Datos\\ 2. Programas\end{tabular}                            & \begin{tabular}[c]{@{}l@{}}1. Datos o hechos\\ 2. Reglas operativas o heurísticas\\ 3. Inferencia y control\end{tabular}                                \\ \hline
		\end{tabular}%
	}
\end{table}

\subsection{Elementos de un SBC}
\textbf{Base de conocimiento:} contiene el conocimiento que hemos recibido de los expertos en un dominio determinado.

\textbf{Base de hechos:} Cómo está la base de conocimiento, pensando como el estado, es la memoria de trabajo que almacena los datos iniciales del problema y los resultados intermedio durante el proceso.

\textbf{Motor de inferencia:} Es el que se encarga de ir pasando de estados aplicando reglas, imitando el procedimiento humano de los expertos, poco a poco se va llegando a la solución. Aprenderemos cómo funciona y tendremos que definir las reglas.
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Elementos de un SBC}}
	{\def\svgwidth{.8\textwidth}
		\input{img/elementos_sbc.eps_tex}}
\end{figure}
\pagebreak

\subsection{Fases para construir un SBC}
Iteración:
\begin{enumerate}
	\item \textbf{Identificar} el problema (con usuario y expertos)
	\item Adquirir conocimiento (con expertos y estudio de la documentación)
	\item \textbf{Conceptualizar}, saber estructurar el conocimiento, separar los datos y el problema.
	\item \textbf{Formalizar} conocimiento.
	\item \textbf{Implementar} formalización (con desarrollador).
	\item \textbf{Validar} funcionamientos esperados (con usuario y experto).
\end{enumerate}

Es un proceso que no se realiza a la primera, se retrocede continuamente, además se deben hacer varias iteraciones en todos los pasos, es difícil realizarlos a la primera al ser fácil pasarse algo del problema.

\subsection{Ventajas de los SBC}
\begin{itemize}
	\item Distribución y disponibilidad del conocimiento.
	\item Coherente y estabilidad.
	\item Almacenamiento del conocimiento
	\item Resuelven el problema con incertidumbre.
	\item Explicación de como adoptará la solución.
	\item Aprendizaje.
\end{itemize}

\subsection{Desventajas de los SBC}
\begin{itemize}
	\item No asegura que se vaya a encontrar la solución óptima, pero al menos alcanzara una.
	\item El conocimiento es limitado, no se puede poseer todo el conocimiento, hay que asumir esta limitación y trabajar con ella.
	\item Falta de sentido común.
	\item La adquisición del conocimiento y mantenimiento es difícil.
	\item Degradación del conocimiento, requiere un mantenimiento constante para mantenerse al día.
\end{itemize}

\section{Ejemplos Actuales Relacionados con la Ingeniería del Conocimiento}
\textbf{Sistema Experto en Medicina:} en el que con todo el conocimiento médico y recibiendo una serie de variables ser capaz de dar un diagnóstico. En este punto entra en juego la ética y el querer saber en qué se basa este diagnóstico, como lo obtuvo.
\begin{itemize}
	\item ATHENA: Assessment and Treatment of Hypertensión
	\item GIDEON: Global Infectious Disease and Epidemiology Network
\end{itemize}

\textbf{Sistema de Gestión de Reglas de Negocio:} Dado el conocimiento adquirido por profesionales e históricos (como en el sistema financiero) ser capaz de decidir cuándo invertir o realizar alguna operación.
\begin{itemize}
	\item IBM ILOG JRules BRMS
	\item Drools
	\item Red Hat JBoss BRMS
\end{itemize}

\textbf{Ontologías:}
\begin{itemize}
	\item Web semánticas: Web Ontology Languaje
	\item Protégé: Editor de ontologías
	\item Información de seguimiento de una persona
\end{itemize}

\textbf{Planificación Automática y Robótica:} Como por ejemplo es el proyecto Nao Therapist un robot para ayudar a los niños en rehabilitación por parálisis cerebral.

\chapter{Tema 2: Identificación y Adquisición}
Se tratará la identificación de los problemas y la adquisición del conocimiento para los SBC que se componen de:
\begin{itemize}
	\item \textbf{Conocimiento:} Formado por la Base hechos (define el estado del sistema) y la Base de reglas (como razona el sistema experto).
	\item \textbf{Motor de inferencia} que toma las decisiones como lo haría el experto humano, como si razonase.
\end{itemize}

Una parte muy importante del proceso es limpiar los datos para generar conocimiento.

\section{Identificación del problema}
Es la primera fase para el desarrollo de un SBC, saber cuál es el problema y si es posible aplicarle esta técnica. También se espera que se defina porque resolver este problema es útil.

Etapas de la identificación
\begin{enumerate}
	\item \textbf{Objetivos del problema:} que se quiere resolver y el plan de requisitos. Los 3 primeros son los pedidos para las prácticas.
	      \begin{itemize}
		      \item \textbf{Metas específicas y generales}, a que se quiere llegar y partir el problema.
		      \item \textbf{Funcionalidad y rendimiento esperado}, como el tiempo de respuesta esperado.
		      \item \textbf{Fiabilidad y calidad}, que serie de problemas debe ser capaz de superar para considerarlos de calidad.
		      \item Limitaciones de coste/tiempo.
		      \item Requisitos de fabricación/implementación.
		      \item Tecnología/medios disponibles.
		      \item Ampliaciones futuras.
	      \end{itemize}
	      \pagebreak
	      
	\item \textbf{Evaluar el problema:} ver si de verdad es necesario y posible crear el SBC (tampoco matar moscas a cañonazos). Para la práctica se nos piden las 2 primeras:
	      \begin{itemize}
		      \item \textbf{Adecuación}, se ajusta al tipo de problema. Nos tenemos que fijar en:
		            
		            Naturaleza del problema
		            \begin{itemize}
			            \item Requiere experiencia, si lo hace es adecuado.
			            \item Implica el uso de diferentes tácticas, según los hechos irá por una táctica u otra.
			            \item Es una actividad práctica, se aprende por observación, no solo conociendo el manual.
			            \item Satisface necesidades a largo plazo, es útil para más de 1 vez o caso.
		            \end{itemize}
		            Tipo:
		            \begin{itemize}
			            \item La tarea no requiere investigación, si la requiere no habrá expertos que consultar.
			            \item Solo manipulación simbólica
			            \item Hace uso de heurísticas, no se conoce el procedimiento exacto, son aproximados y sabrá recuperarse.
		            \end{itemize}
		            Complejidad:
		            \begin{itemize}
			            \item Dominio acotado y problema puede descomponerse (los juegos suelen serlo)
			            \item Problema no demasiado fácil (no algorítmica, solución necesita justificación)
			            \item Transferencia de experiencia entre humanos es factible. Que será posible la transferencia de conocimiento.
			            \item No requiere tiempo real, porque suelen ser lentos.
		            \end{itemize}
		      \item \textbf{Plausibilidad}, ver que es posible.
		            \begin{itemize}
			            \item Existen verdaderos expertos y son accesibles
			            \item Los expertos pueden explicar sus métodos de resolución del problema
			            \item La tarea solo depende de los conocimientos
			            \item La definición del problema está clara y estructurada
			            \item Hay suficientes y relevantes casos de prueba
		            \end{itemize}
		      \item Justificación. Normalmente si cumple las 2 anteriores es suficiente.
		            \begin{itemize}
			            \item Solución más sencilla
			            \item Entorno peligroso o poco gratificante
			            \item Escasez de experiencia humana
			            \item Perdida de experiencia humana
			            \item Necesidad de omnipresencia simultánea en lugares distantes
			            \item Rentabilidad económica
			            \item Utilidad y necesidad
			            \item Inexistencia de alternativas.
		            \end{itemize}
		      \item Posibilidades de Éxito.
		            \begin{itemize}
			            \item Expertos autosuficientes (conocimiento repartido de calidad, activos,
			                  cooperativos y coherentes)
			            \item Gestores del proyecto convencidos (prioridad proyecto, resultados
			                  aceptables, no perfectos …)
			            \item Ausencia de rechazo en los usuarios
			            \item Suficientes recursos (humanos y materiales)
			            \item Dominio estable, objetivos claros y evaluables
			            \item Precedentes de uso de IC en problemas semejantes
			            \item Las soluciones son explicables
		            \end{itemize}
	      \end{itemize}
	\item \textbf{Definir el problema y concebir una solución}, como debería ser la solución. Ayuda a pensar en las entradas y sus salidas.
	      \begin{itemize}
		      \item \textbf{Definición y descomposición} del problema. Descripción de problemas similares.
		      \item Descripción de cada subproblema.
		      \item Identificación de las \textbf{entradas y salidas} de cada subproblema.
		      \item Características de datos de entrada: incompletos, imprecisos, inciertos. Permiten tratar la incertidumbre.
		      \item Enumeración de casos y ejemplos con los que se cuenta, poner casos y ejemplos para visualizarlo.
		      \item Describir y cuantificar la complejidad prevista del problema.
		      \item Concepción global de la solución: esbozar a priori posibles soluciones.
	      \end{itemize}
\end{enumerate}

\section{Adquisición del Conocimiento}
Esta fase se repite durante todo el proceso en paralelo para ir completando el sistema, ya que nos daremos cuenta de que hay cosas que nos hemos saltado.

Fuentes de conocimiento, pueden ser orales o escritas:
\begin{itemize}
	\item \textbf{Documentación formal:} libros y manuales, revistas especializadas, etc.
	\item \textbf{Documentación informal:} presentaciones, apuntes, registros internos
	\item \textbf{Bases de datos:} EXTRACCIÓN de conocimiento
	\item \textbf{Expertos humanos:} EDUCCIÓN de conocimiento
\end{itemize}

Es importante saber separar el conocimiento factual de las estrategias (suele estar en la BH), el qué, y el procedimiento de resolución (suele estar en la BR), el cómo. Esta separación nosotros la realizaremos manualmente, pero hay métodos que lo hacen automática o semiautomáticamente.

\subsection{Extracción de Conocimiento desde la Documentación}
Estudio inicial de documentación: Consiste en la búsqueda de terminología, identificar \textbf{conceptos básicos}, y comprender la naturaleza de la \textbf{tarea}.

Análisis estructural de textos: Buscar términos dependientes del dominio y estructuras textuales mediante la detección de patrones.

\subsubsection{Estructuras Textuales}
Están compuestas por 4 elementos:
\begin{itemize}
	\item \textbf{Definiciones:} Introducción de un concepto que puede estar:
	      \begin{itemize}
		      \item Definido por su uso: se extrae el concepto y una característica.
		      \item Definido por las partes que lo componen: se extrae el concepto
		            principal, los componentes y la relación formar-parte-de.
	      \end{itemize}
	      (se usa para, es un, está compuesto por)
	\item \textbf{Afirmaciones:} Establece una verdad.
	      
	      (es causa de, se relaciona con, es la finalidad de)
	\item \textbf{Leyes:} Principios básicos.
	\item \textbf{Procedimientos:} Pasos para la resolución.
\end{itemize}

\subsection{Educción de Conocimiento}
Psicológicamente un experto:
\begin{itemize}
	\item Analiza lo que percibe.
	\item Asocia lo percibido con los conceptos del dominio.
	\item Encuentra causas basándose en relaciones de conceptos.
	\item Infiere y verifica hipótesis.
\end{itemize}

\textbf{Paradoja de la experiencia:} los expertos más competentes son incapaces de describir los conocimientos que usan para resolver los problemas.

Técnicas de educción: ayudan a adquirir y validar el conocimiento de los expertos. No hace falta conocer todas las técnicas.
\begin{itemize}
	\item \textbf{Técnicas naturales:} Implican al experto realizando tareas que haría normalmente como parte de su trabajo.
	      
	      Entrevistas (Abiertas, Semiestructuradas y Estructuradas), Cuestionarios, Técnicas de observación y Técnicas de grupo.
	\item \textbf{Técnicas artificiosas} Implican al experto realizando tareas que no realizaría normalmente como parte de su trabajo.
	      
	      Método triádico, Clasificación de conceptos, Emparrillado, Tareas con restricciones, 20 cuestiones, ‘Teach back’ y Análisis de Protocolos.
	      
	      \textbf{Análisis de Protocolos o caso concreto de forma global}
	      
	      Tiene tres profundidades: Análisis del asunto o materia, Análisis de tareas y Distinguir casos dentro de la materia y la tarea asociada.
	      
	      Etapas:
	      \begin{itemize}
		      \item Grabación del protocolo, tener un registro de cómo se lleva a cabo.
		      \item Transcripción del protocolo segmentándolo en instrucciones.
		      \item Codificación del protocolo:
		            \begin{itemize}
			            \item Identificar conceptos, características, valores, relaciones.
			            \item Identificar el razonamiento del experto.
			            \item Identificar acciones externas.
			            \item Identificar las inferencias.
			            \item Detección de sinónimos, metacomentarios e incertidumbres.
		            \end{itemize}
		      \item Interpretación del IC sobres reglas implícitas, planes y estrategias del experto.
	      \end{itemize}
	      
	\item \textbf{Técnicas de modelado:} Técnicas basadas en el uso de modelos que guían la adquisición, validación y modificación del conocimiento. Representar el conocimiento para conceptualizar.
	      
	      Conceptos, Procesos y Estados.
	      
	      Tipos de modelado: Diagrama de proceso (conocimiento procedural), Mapa conceptual (conocimiento declarativo) y Diagramas de estados (variación de los diagramas de procesos, buenos para todo tipo de conocimiento.)
\end{itemize}

\subsubsection{Reglas para una Buena Educción}
\begin{itemize}
	\item Conseguir la cooperación del experto.
	\item No imponer la visión del IC sobre la del experto.
	\item Limitar las sesiones en duración y contenido.
	\item Intentar comprobar la información.
	\item No limitarse al diálogo, usar textos.
	\item No espaciar demasiado las sesiones de educción.
	\item Elegir el lugar adecuadamente.
	\item No ser el propio experto.
	\item No creer todo lo que dice que hace.
\end{itemize}

\subsubsection{Ciclo de Educción}
El conocimiento se educe mediante la sucesiva aplicación de sesiones de educción.

Para completar una sesión el ingeniero del conocimiento debe realizar los siguientes pasos:
\begin{itemize}
	\item Preparación de la sesión
	\item Ejecución
	\item Transcripción
	\item Análisis de la sesión
	      
	      Organización de la información: Diccionario de términos o conceptos, Librería de casos y Documento de conocimientos.
	      
	      Actualización tras el análisis de cada sesión: determinar comprensión del IC, y si es necesario preguntar más sobre el tema. Producir documentos para fases posteriores.
	      
	      Proceso de razonamiento de resolución: Búsqueda de inferencias, Analizar casos buscando, Comprobación de suposiciones obvias y Analizar si es necesario el uso de la incertidumbre.
	\item Evaluación
\end{itemize}

\chapter{Tema 3: Conceptualización. Introducción}
Consiste en estructurar todo el conocimiento adquirido y establecer que conocimientos maneja el experto, como los utiliza, donde y cuando. 

Es independiente de la implementación y herramienta.

\textbf{Análisis: estructurar...}
\begin{itemize}
	\item \textbf{Conocimiento factual}, la información que se conoce (conceptos)
	\item \textbf{Conocimiento táctico}, como y cuando se añade información (inferencia)
	\item \textbf{Conocimiento estratégico}, que hacer, donde y por qué (pasos)
	\item \textbf{Metaconocimiento}, conocimiento sobre el conocimiento.
\end{itemize}
\textbf{Síntesis: modelo conceptual}
\begin{itemize}
	\item \textbf{Modelo factual:} Tabla Conceptos-Atributos-Valores y Relaciones.
	\item \textbf{Modelo de procesos:} Inferencias, tareas, procedimientos, estrategias, control, restricciones y operaciones que actúan sobre el modelo estático.
	\item \textbf{Mapa de conocimiento:} Integra los dos modelos.
\end{itemize}

\subsection{Concepto}
Cualquier cosa que se nos ocurra acerca de la cual se quiere decir algo, pueden ser cosas concretas, abstractas, de ficción, descripción de una tarea, función, acción, estrategias o tareas de razonamiento.

Aunque se pueden generar infinidad de conceptos es conveniente reducir el número de conceptos mediante:
\begin{itemize}
	\item \textbf{Generalización:} Considerar el conjunto que contiene un concepto, de manera que este contenga a muchos conceptos. Ejemplo: Herramienta con martillo, sierra, destornillador...
	\item \textbf{Abstracción:} Concentrarse en las cualidades esenciales de algo, en lugar de en sus relaciones concretas o casos.
\end{itemize}
\textbf{Universo del discurso:} Conjunto de conceptos acerca del cual se expresan los conocimientos.

\subsubsection{Tabla Conceptos/Atributos/Valores}
\begin{table}[H]
	\centering
	\caption{Ejemplo Tabla Conceptos/Atributos/Valores}
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Concepto} & \textbf{Atributo}          & \textbf{Posible valor}     \\ \hline
		Herramienta       & \begin{tabular}[c]{@{}l@{}}Nombre \\ Modelo \\ Coste \\ Fecha de compra \\ Fabricante \\ N.º de registro \\ Color\end{tabular} & \begin{tabular}[c]{@{}l@{}}Martillo1, Sierra1, Taladro1, Cincel1…\\ Un nombre\\ Un número\\ dd/mm/aa\\ Un nombre\\ Un n.º de 7 dígitos\\ Rojo, Verde, Blanco …\end{tabular} \\ \hline
	\end{tabular}
\end{table}

Las relaciones se pueden representar como concepto y las partes implicadas como atributos, si existen más características en la relación serian atributos extras.

\subsection{Relaciones entre conceptos}
Interacción entre conceptos en un universo de discurso.

Las relaciones más habituales son:
\begin{table}[H]
	\centering
	\caption{Tipos de relaciones entre conceptos}
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Tipo}              & \textbf{Ejemplos}          \\ \hline
		\begin{tabular}[c]{@{}l@{}}Taxonómica \\ Estructurante \\ Topológica \\ Causal \\ Funcional \\ Cronológica \\ Similaridad \\ Condicional \\ Finalidad\end{tabular} & \begin{tabular}[c]{@{}l@{}}A es B. A puede clasificarse como un B, un C, o un D\\ A es parte de B. A está formado por B y C\\ A esta encima de B. A contiene a B. A intersecta a B\\ A causa B. A es efecto de B. Siempre que A, B\\ A permite B. A necesita B. A dispara B\\ A sucede antes de B. A y B ocurren simultáneamente\\ La válvula A esta abierta = admite gasolina\\ Si A y B entonces B\\ Los códigos se crearon para transmitir ideas\end{tabular} \\ \hline
	\end{tabular}
\end{table}
\pagebreak

\subsection{Atributos}
Propiedad o característica de un concepto.

\textbf{Lista atributos:} lista de elementos necesarios para inferir la/s meta/s del SE.

En el ejemplo de la herramienta los atributos podrían ser: Nombre de la herramienta, Número de registro, Coste, Fecha de compra, Fabricante y Modelo.

Para identificar los atributos nos podemos preguntar: 

¿Es \textit{sustantivo1} un atributo del concepto \textit{sustantivo2}? $\equiv$ ¿Tiene sentido hablar acerca del \textit{sustantivo1} de un \textit{sustantivo2}?

\subsubsection{Definición de un Atributo}
Los atributos de los atributos se llaman facetas y deben ser definidos sobre los atributos de la Tabla Conceptos/Atributos/Valores.

Los fundamentales son los que están en negrita.
\begin{table}[H]
	\centering
	\caption{Definición de un Atributo}
	\begin{tabular}{|l|l|}
		\hline
		\textbf{INFORMACIÓN}       & \textbf{DESCRIPCIÓN}                                \\ \hline
		Nombre                     & Termino estándar que nombra ese atributo            \\ \hline
		Descripción                & Breve explicación de lo que representa ese atributo \\ \hline
		\textbf{Tipo Valor}        & \begin{tabular}[c]{@{}l@{}}Que puede contener el atributo\\ (Entero, real, cadena, símbolo, ...)\end{tabular}                          \\ \hline
		\textbf{Rango de valores}  & \begin{tabular}[c]{@{}l@{}}Una lista de posibles valores\\ Un rango de valores numéricos\end{tabular}                          \\ \hline
		\textbf{Cardinalidad}      & \begin{tabular}[c]{@{}l@{}}Máxima y mínima que puede tener\\ (normalmente uno o muchos)\end{tabular}                          \\ \hline
		\textbf{Valor por defecto} & En caso de no especificar un valor                  \\ \hline
		Grado de certeza           & En caso de incertidumbre                            \\ \hline
	\end{tabular}
\end{table}

\subsection{Relaciones entre Conceptos}
Dependencia entre conceptos. Ejemplo: Herramienta y Persona la relación es de Propietario

Es necesario que exista alguna instancia de los conceptos padres.

Tipos de relación: Uno-a-Uno y Uno-a-Muchos.

Las relaciones y conceptos se pueden representar en un Mapa Conceptual, las cajas son los conceptos y las flechas son las relaciones en las que se indica el nombre y tipo.
\pagebreak

\subsection{Conocimientos Estratégicos}
\begin{enumerate}
	\item Definir pasos de alto nivel para realizar la tarea: Identificar los pasos de alto nivel a ejecutar, Establecer el orden y Definir las condiciones en que debería ejecutarse cada paso.
	\item Descomponer pasos de alto nivel en subpasos.
	\item Para cada subpaso descubrir: Entrada, Modo de razonamiento y Salida.
\end{enumerate}

\subsection{Conocimientos Táctico. Inferencias}
Una inferencia consta de una parte de condición y otra de conclusión.

Hay múltiples posibles representaciones, pero la más habitual es: 
\begin{itemize}
	\item \textbf{SI} condiciones \textbf{ENTONCES} acciones
\end{itemize}

\textbf{Paso de inferencia:} Hay que indicar que atributo/s usar para inferir nueva información (concluir un atributo específico)

\chapter{Tema 4: Conceptualización. Ontologías}
Una ontología es una especificación formal y explicita de una conceptualización compartida (Thomas Gruber), nosotros las utilizaremos para conceptualizar normal.
\begin{itemize}
	\item \textbf{Conceptualización:} desarrollo de un modelo abstracto del dominio basado esencialmente en el empleo de conceptos, atributos, valores, relaciones y funciones.
	\item \textbf{Especificación explicita:} descripción y representación de un dominio concreto mediante conceptos, atributos, valores, relaciones y funciones, definidos explícitamente.
	\item \textbf{Formal:} expresado mediante un formalismo (siempre idéntico) de manera que pueda ser reutilizada y leída por cualquier máquina.
	\item \textbf{Compartida:} favorablemente acogida por todos los usuarios de esta. Se supone que se comparten entre usuarios para usarla con diferentes propósitos.
\end{itemize}
\pagebreak

\subsection{Características de las Ontologías}
\begin{itemize}
	\item Disponibilidad, facilidad de gestión y divulgación
	\item Ingeniería ontológica
	      \begin{itemize}
		      \item \textbf{Ciclo de vida:} construcción, refinamiento, modificaciones, uso, explotación y retiro.
		      \item Requieren metodologías.
	      \end{itemize}
	\item No son cerrados y están sujetos a procesos evolutivos.
\end{itemize}

\subsection{Algunos problemas}
\begin{itemize}
	\item Imposibilidad de utilización directa de las ontologías previamente desarrolladas, almacenen el conocimiento junto, pero para hacer razonamientos hay que extraerlo (con un parser) y adaptarlo.
	\item \textbf{Web semántica:} se necesita desarrollar buscadores semánticos.
\end{itemize}

\subsection{Terminología Básica}
\begin{itemize}
	\item \textbf{Clase:} representa un concepto.
	\item \textbf{Subclase:} concepto más específico que dicha clase, cuando se da es-un, no cuando se da la relación es-parte-de o compone-a, en esos casos se crea su propia clase o se pone como atributo.
	      
	      Las subclases heredan todas las propiedades de la clase.
	      
	      Si A es subclase de B, una instancia de A también lo es de B.
	      
	      Una nueva subclase puede tener nuevas propiedades, diferentes valores de las propiedades y participar en nuevas relaciones. Aunque no tienen por qué introducir nuevas propiedades.
	\item \textbf{Clase abstracta:} clase que no permite que existan instancias de ella. Se usa para agrupar conceptos e introducir cierto orden en la jerarquía.
	\item \textbf{Propiedad o atributo (slot):} característica de la clase que se concretara mediante un valor, pueden ser tipos básicos o incluso otra clase o instancia.
	\item \textbf{Faceta:} propiedad de los atributos. Tipo de dato, la cardinalidad, valor por defecto…
	      \pagebreak
	      
	\item \textbf{Instancia:} representan objetos concretos del dominio.
	      \begin{itemize}
		      \item Pertenecen a una clase.
		      \item Todos los atributos toman un valor concreto.
		      \item La colección de instancias constituye la base de hechos.
	      \end{itemize}
	\item \textbf{Relación:} interacción o enlace entre los conceptos o clases del dominio.
	      \begin{itemize}
		      \item Relaciones semánticas básicas: subclase de (’es un’), parte de…
		      \item Se pueden modelar mediante atributos de una clase o definiendo clases nuevas
	      \end{itemize}
	\item \textbf{Axioma:} reglas que son siempre ciertas. Se usan para Incluir restricciones, Verificar la corrección o Deducir conocimiento no codificado explícitamente.
	\item \textbf{Herencia:} propiedad de la relación ‘es un’, las clases relacionadas (heredadas) cuentan con los atributos de la clase padre.
	\item \textbf{Herencia múltiple:} una clase hereda o cuenta con las propiedades de dos clases padre.
	\item \textbf{Derivación:} organización de las clases de la ontología en un árbol de jerarquía mediante sucesivas relaciones ‘es un’ (kind of, is a) con la propiedad de herencia.
\end{itemize}

\subsection{Metodologías para Hacer Ontologías}
Son las metodologías para que dado un problema diseñar una ontología que lo represente.
\begin{itemize}
	\item \textbf{Diligence:} basada en la colaboración de múltiples participantes
	\item \textbf{Competency Questions (‘Preguntas Relevantes o ‘Preguntas de Verificación’):} determina el dominio y el alcance de la ontología mediante la lista de preguntas
	\item \textbf{Methontology:} propone un ciclo de vida de construcción de la ontología basado en prototipos evolutivos
	\item \textbf{On-To-Knowledge:} hace hincapié en las aplicaciones futuras de la ontología a la hora de diseñarla.
\end{itemize}
\pagebreak

\subsection{Desarrollo de una Ontología}
\textbf{Algunas reglas:}
\begin{itemize}
	\item No existe un único modo correcto de modelizar un dominio.
	\item El desarrollo de una ontología es necesariamente un proceso iterativo, se va refinando.
	\item Los conceptos o clases de una ontología deberían ser muy cercanos a objetos o entes (tanto físicos como lógicos) y a las relaciones existentes en nuestro dominio de interés.
\end{itemize}

\textbf{Pasos:}
\begin{enumerate}
	\item Determinar el dominio y alcance de la ontología
	      \begin{itemize}
		      \item ¿Qué dominio cubrirá la ontología?
		      \item ¿Para qué se va a emplear la ontología?
		      \item ¿Qué preguntas debería contestar la ontología?
		      \item ¿Quién usará y mantendrá la ontología?
	      \end{itemize}
	\item Considerar la reutilización de ontologías existentes
	      \begin{itemize}
		      \item Ontolingua
		      \item DAML Library
		      \item UNSPSC
		      \item RosettaNet
		      \item DMOZ
	      \end{itemize}
	\item Enumerar términos importantes de la ontología
	      
	      Listar todos los términos del dominio basándose en documentación o expertos.
	      
	      Al principio ignorar: relaciones, varios se enmarcan en un mismo concepto (sinónimos), o si corresponden a conceptos o propiedades.
	      
	      Algunos de estos términos se transformarán en clases, otros en propiedades y otros en instancias.
	      
	\item Definir las clases y la jerarquía de clases
	      \begin{itemize}
		      \item \textbf{Top-down:} comienza con las clases \textbf{más generales} del dominio y posteriormente se lleva a cabo su especialización
		      \item \textbf{Botom-up:} comienza con la definición de las clases \textbf{más específicas}, reagrupando posteriormente estas clases en conceptos más generales
		      \item \textbf{Combinación de las anteriores:} comienza con la enumeración de las clases \textbf{más destacadas y posteriormente se generalizan} y especializan apropiadamente
	      \end{itemize}
	\item Definir las propiedades/slots de las clases
	      
	      Características que pueden convertirse en slots: Características intrínsecas, extrínsecas, Partes del objeto y Relaciones con otras clases.
	      
	      \textbf{Relaciones inversas:} el valor de una propiedad puede depender de otra propiedad. Ej. Vino fue fabricado por una bodega, entonces, la bodega produce ese vino.
	      
	\item Definir las facetas o restricciones de las propiedades o slots
	      \begin{itemize}
		      \item \textbf{Tipo de valor:} String, Número (Entero o Float), Boolean, Enumerado, Instancias
		      \item \textbf{Cardinalidad:} cuantos valores puede tener una propiedad
		      \item \textbf{Rango:} clases permitidas para una propiedad de tipo Instancia, valores numéricos o valores permitidos.
		      \item \textbf{Valor por defecto:} Si la mayoría de las instancias de la clase toman un valor concreto, el sistema lo completara automáticamente, pero se puede cambiar el valor posteriormente. No es lo mismo que el valor fijado.
	      \end{itemize}
	\item Crear instancias
	      
	      Las instancias son los objetos más específicos representados en una ontología: Se debe elegir una clase para la que crear la instancia y rellenar todos los valores de propiedades.
\end{enumerate}

\subsection{Jerarquía de clases}
\begin{itemize}
	\item Las instancias son los conceptos más específicos representados en una ontología.
	\item No debemos emplear sinónimos de un mismo concepto para clases diferentes.
	\item No deben aparecer ciclos o bucles en la jerarquía de clases.
	\item Los conceptos de un mismo nivel de la jerarquía o clases hermanas deben presentar el mismo nivel de generalidad (excepto en la raíz).
	\item Dominio del discurso: no es necesario especializar o generalizar más de lo que necesitemos.
	\item Si los conceptos de un dominio forman una jerarquía natural, podríamos representarlos como clases abstractas.
\end{itemize}

\subsection{Herramientas de Edición de Ontologías}
\begin{itemize}
	\item Protege (Universidad de Stanford)
	\item KAON (Universidad de Karlsruhe, Alemania)
	\item WebOnto (Open University, UK)
	\item OntoEdit (comercializada por Ontoprise GmbH)
	\item Ontolingua (Universidad de Stanford)
	\item OntoSaurus (Universidad de Southern California). Lenguaje LOOM
\end{itemize}

\chapter{Tema 5: Formalización e implementación. Representación del conocimiento}
Modelización del problema desde el punto de vista del sistema.

Un modelo formal es una representación computable (entendible por la máquina) de los conocimientos y conducta del experto.

Formalizar consiste en: Representar simbólicamente los conceptos mediante alguno de los formalismos existentes, organizarlos de acuerdo con algún modelo de diseño y determinar los métodos de inferencia.

El modelo formal debe contener los conocimientos del modelo conceptual y se expresa mediante el uso de un formalismo de representación del conocimiento.

Se puede suponer la existencia de un motor de inferencias (programación propia o herramienta) independiente del dominio de aplicación

Normalmente la técnica de resolución del problema viene dada por el formalismo de representación elegido. En sistemas grandes se pueden combinar varios formalismos. 

Algunos formalismos son:
\begin{itemize}
	\item \textbf{Basados en acciones:} Sistemas de producción y guiones.
	\item \textbf{Basados en conceptos:} Marcos.
	\item \textbf{Basados en relaciones:} Lógica y Redes semánticas.
\end{itemize}

Cuando se formaliza hay que pensar en el problema para poder representar las preguntas correctamente (que la representación facilita las reglas).

La representación en el ordenador no siempre refleja la realidad. 

Todas las representaciones son imperfectas.

Una misma información se puede representar de múltiples formas.

La representación que se utilice puede facilitar las inferencias, no es lo mismo representar (Red car12), que (car12, Red) o (Propiedad color car12 Red).

\chapter{Tema 6: Formalización e implementación. Sistemas de producción}
\subsection{Componentes de un Sistema de Producción}
\textbf{Base de hechos o memoria de trabajo (BH o WM):} conocimiento sobre el dominio en un determinado momento

\textbf{Base de reglas (BR):} conjunto de reglas (producciones) SI Condiciones ENTONCES Acciones

Estrategia de control, interprete de reglas, o \textbf{motor de inferencias (EC o MI):} responsable de encadenar los ciclos de funcionamiento.
\subsubsection{Base de Hechos}
Almacena el estado actual de la tarea o problema

Los datos almacenados pueden ser permanentes, temporales, generales y específicos

Inicialmente se representa todo el problema con los hechos iniciales, se va desarrollando hasta llegar al finalmente a un estado meta.

La BH presenta tres estados:
\begin{itemize}
	\item \textbf{Estado inicial:} situación origen del problema.
	\item \textbf{Estados metas:} situación objetivo.
	\item \textbf{Estados intermedios:} representan en cada instante, el estado del problema en curso de solución.
\end{itemize}
\subsubsection{Base de Reglas}
Está el conocimiento de cómo cambiar entre estados.

La mayor parte de los conocimientos sobre la resolución del problema se representan en un conjunto de reglas o producciones.

Cada regla presenta la forma: \textbf{SI} Condiciones \textbf{ENTONCES Acciones}
\begin{itemize}
	\item \textbf{Condición o antecedente:} lista de cosas a verificar en la BH
	\item \textbf{Consecuente o acción:} conjunto de acciones a realizar sobre la BH
\end{itemize}

Las reglas van cambiando el estado muy poco a poco, no tratar de hacer una regla que lo haga todo.
\subsubsection{Motor de Inferencia}
Examina en cada ciclo de funcionamiento la BH y decide que regla ejecutar, encadenando las reglas en los ciclos de resolución.

Funcionamiento:
\begin{enumerate}
	\item \textbf{Fase de decisión:} selección de la regla.
	\begin{itemize}
		\item (Etapa de restricción (opcional))
		\item \textbf{Etapa de equiparación o filtrado.} Coge todas las reglas y comprueba las precondiciones con los hechos y ver cuál se puede ejecutar.
		\item \textbf{Etapa de resolución del conjunto conflicto.} Según la estrategia selecciona una regla.
	\end{itemize}
	
	Una regla se activa cuando sus precondiciones son ciertas en el estado
	actual de la BH
	\item \textbf{Fase de acción:} ejecución de la regla.
\end{enumerate}

Las reglas se pueden hacer en dos sentidos:
\begin{itemize}
	\item \textbf{Encadenamiento hacia Adelante:} Partiendo de los hechos se va viendo que reglas se pueden ejecutar y utilizando las salidas y los hechos generados se van encadenando las reglas hasta llegar a una meta.
	\item \textbf{Encadenamiento hacia Atrás:} Pensar desde el estado final (meta) que necesito para que retrocediendo se llegue a los hechos iniciales que se tienen.
\end{itemize}
\subsubsection{Estrategias de Resolución del Conjunto Conflicto}
\begin{itemize}
	\item Primera regla.
	\item Más prioridad.
	\item Más específica.
	\item Más general.
	\item Aleatoriamente.
	\item …
\end{itemize}

\section{Ejercicios}
\begin{enumerate}
	\item \textbf{Se tienen 5 monedas dispuestas como se muestra a continuación: ARARA}
	
	\textbf{El anverso de la moneda está representado por A y el reverso por R. En cada movimiento se puede dar la vuelta a cualquier par de monedas contiguas. La situación final que se quiere obtener es la siguiente: RRRAR.} 
	
	\textbf{Se pide:}
	\begin{itemize}
		\item \textbf{Descripción de la Base de Hechos}
		\item \textbf{Descripción de las reglas que forman la Base de Reglas}
		\item \textbf{Determinar las reglas que se ejecutan para pasar a la situación final}
	\end{itemize}
	\textbf{Base de Hechos}
	\begin{itemize}
		\item (moneda A 1)
		\item (moneda R 2)
		\item (moneda A 3)
		\item (moneda R 4)
		\item (moneda A 5)
		\item (inverso A R)
		\item (inverso R A)
	\end{itemize}
	\textbf{Base de Reglas}
\begin{lstlisting}
(defrule volcar
	?mn1 <- (moneda ?v1 ?p1)
	?mn2 <- (moneda ?v2 ?p2)
	(inverso ?v1 ?nv1)
	(inverso ?v2 ?nv2)
	(test (= ?p1 (+ 1 ?p2)))
=>
	(retract ?mn1)
	(retract ?mn2)
	(assert (moneda ?nv1 ?p1))
	(assert(moneda ?nv2 ?p2))
)	
\end{lstlisting}

	Regla final con los valores esperados para cada moneda.

	\item \textbf{Imprimir por pantalla los n.º del 1 al 100.}
	
	Crear un contador con valor 1 y una regla, que lo que haga es ir sumando 1 al número mientras este sea menor que 100 (cuando sea 99 sumara por última vez y dará el 100)
	\item \textbf{Contar el n.º de instancias de un ti p o particular.}
	
	Crear un contador que parte de 0 e ira subiendo el valor según las va contando, cuando cuenta una instancia crea un hecho de que esa instancia se ha contado, esto es necesario dado que al actualizar el contador tratara de aplicar de nuevo la regla sobre los mismos hechos.
\end{enumerate}

\chapter{Tema 7: Formalización e implementación. Marcos}
Tenemos que representar todo el conocimiento en tablas del tipo objeto-atributo-valor.

Cada marco representa un prototipo de algo, debe representar un concepto, en el que cada slot es un atributo. Se diferencia entre:
\begin{itemize}
	\item \textbf{Marco clase}: concepto (prototipo)
	\item \textbf{Marco instancia}: objeto (individuos de la clase)
\end{itemize}

Unificación de todas las propiedades de un objeto en la misma estructura y se establece una estructura de jerarquía con herencia.

Los desarrolló Minsky en 1975
\begin{itemize}
	\item \textbf{Conceptos}: Marcos = Clases = Frames
	\item \textbf{Subconceptos}: subclases.
	\item \textbf{Herencia}: simple o múltiple.
	\item \textbf{Instancias}: objetos.
	\item \textbf{Atributos}: slots, campos, características\dots
	\item \textbf{Facetas}: atributos de atributos (valor, tipo, cardinalidad, …)
	\item \textbf{Relaciones}: subclase-de (herencia), parte-de (entre atributos), instancia-de.
	\item \textbf{Demonios}: Funciones que vigilan las operaciones sobre los atributos. Esta al acecho de que ocurra un evento para realizar una serie de operaciones.
	\item \textbf{Métodos}: Funciones asociadas a los marcos, que facilita mucho la inferencia.
\end{itemize}
\pagebreak

\section{Descripción de un Marco}
\begin{lstlisting}
(CLASE o MARCO equivale a Concepto (es-un CLASE-PADRE)
	(Atributo1 equivale a SLOT O CAMPO
		(FACETAS) 
		tipo de dato
		cardinalidad minima/maxima
		valor por defecto
		valores permitidos
		DEMONIO1 DEMONIO2 ...)
	(Atributo2 ...)
	...
	(AtributoN ...)
	METODO1 METODO2 ...
)	
\end{lstlisting}

\section{Relaciones entre Marcos}
Relaciones estándar:
\begin{itemize}
	\item Son independientes del dominio 
	\item Son dos: Subclase-de e Instancia-de
\end{itemize}
Relaciones no estándar:
\begin{itemize}
	\item Representan dependencias entre conceptos de un dominio.
	\item Hay que buscar formas de implementarlas: atributos cuyo valor es una referencia a otro marco.
\end{itemize}

\subsection{Relación Subclase-de}
Se utiliza para la herencia, una clase hija hereda todos los atributos de la clase padre. Tener cuidado que no es una relación parte-de (elefante y trompa).
\begin{itemize}
	\item Ej. Un elefante es un animal, pero una trompa NO es un elefante.
\end{itemize}

Especialización de conceptos generales en conceptos más específicos

Semántica: el concepto representado por $M_h$ es una especialización o subconjunto del concepto representado por $M_p$. 

Permite la herencia de propiedades: la clase hija tiene todas las propiedades (atributos) de la clase padre y de las clases anteriores en la jerarquía.

Definir los atributos comunes en la clase más abstracta y en las subclases los atributos particulares.

\subsection{Relación Instancia-de}
Representa un ejemplar o individuo de una clase.

Siempre están relacionados con un marco clase.

Tienen todos los atributos rellenos: Bien con valores específicos dado por el usuario o  valores por defecto asignados por el sistema.

Los mecanismos de inferencias trabajan sobre instancias de marcos.

\section{Facetas}
\begin{itemize}
    \item Tipo.
    \item Cardinalidad Mínima.
    \item Cardinalidad Máxima. 
    \item Multivaluada. 
    \item Propiedades que se rellenan en las instancias.
\begin{itemize}
    \item Valor por omisión (defecto).
    \item Valores permitidos.
    \item Demonios: procedimientos o reglas que se ejecutan automáticamente.
\end{itemize}
\item Propiedades de clase/relación.
\begin{itemize}
    \item Propiedad general: valor o puntero a marco.
\end{itemize}
\end{itemize}

\section{Inferencia en un Sistema de Marcos}
\begin{enumerate}
	\item Con reglas.
	\item Usando métodos y demonios.
	\item Combinación de ambas.
\end{enumerate}

\section{Relaciones}
El uso de clases/marcos nos permite no solo crear una jerarquía entre conceptos, sino además generalizar a la hora de definir las reglas de inferencias pudiéndonos referir a la clase padre para operar con los hijos.

A la hora de relacionar conceptos, no se crea un slot con un puntero hacia la otra instancia, sino que utilizaremos identificadores en las instancias para que a la hora de referirnos lo hagamos de esta manera. Cuando se hace en una regla nos permite obligar a que la instancia relacionada tenga ese identificador.

Cuando la relación es 1 a 1 se puede hacer como se ha descrito antes, pero cuando se trata de una relación 1 a n o n a n, lo que se hace es crear una clase cuyas instancias estarán compuestas por los identificadores relacionados de manera que se recojan todas. (produce bodega vino1) (produce bodega vino2) aunque en este caso se podría haber puesto en vino, pero si fuese necesario en bodega se haría de esta manera.

\section{Métodos}
Funciones definidas sobre una CLASE para manipular los atributos.

Los métodos se definen de forma genérica en la definición del marco, pero se invocan  (ejecutan) a través de una INSTANCIA de la clase.

Posible pseudocódigo:
\begin{itemize}
	\item \textbf{send} o enviar: llama a algún método de una INSTANCIA.
	
	send ?alumno matricular ?self Se manda así mismo, instancia como argumento de la función matricular de la clase alumno
	\item \textbf{get}: coge el valor de un atributo de una instancia.
	\item \textbf{set}: da valor al atributo de una instancia.
	\item \textbf{add} o añadir: añadir: añade un valor a un multislot.
	
	añadir ?self.alumnos ?alumno
	\item \textbf{self}: referencia a la propia instancia.
	
	?self.numero\_alumnos = ?self.numero\_alumnos + 1
\end{itemize}
\pagebreak

No nos aprenderemos la sintaxis de CLIPS, usaremos pseudocódigo, incluso en el examen. Con los métodos anteriores es suficiente para realizar las tareas.
\begin{itemize}
	\item Primero se define como se invoca el método, nombre y argumentos.
	\item Después los pasos que sigue el método, lo que devuelve o modifica sobre la base de hechos.
\end{itemize}

Ejemplo:
\begin{lstlisting}
Metodo ASIGNATURA.matricular (?alumno in ALUMNO)
	anadir ?self.alumnos ?alumno
	?self.numero-alumnos= (?self.numero-alumnos) + 1
	enviar ?self.titulacion matricular ?alumno
	enviar ?alumno matricular ?self

Metodo TITULACION.matricular (?alumno 2 ALUMNO)
	if not(member(?alumno, ?self.alumnos)))
	then anadir ?self.alumnos ?alumno
		?self.numero-alumnos=(?self.numero-alumnos) + 1
\end{lstlisting}

\section{Demonios}
Son funciones que se ejecutan automáticamente, cuando le ocurre algo a un determinado atributo de una clase se disparan.

Se definen sobre ATRIBUTOS de las clases.

Además de definir qué es lo que hacer hay que definir que evento es el que lo dispara, pueden ser:
\begin{itemize}
	\item \textbf{if-need}: antes de leer el valor del atributo.
	\item \textbf{if-set}: después de cambiar el valor.
	\item \textbf{if-added}: antes de añadir un valor a un multislot.
\end{itemize}

Se utilizan para:
\begin{itemize}
	\item Requerir el valor de un atributo.
	\item Mantener la integridad de la base de conocimiento.
	\item Gestión dinámica de valores (actualizar valores a partir de otros)
\end{itemize}

Aquí no nos queda otra manera de referirnos a las instancias que apuntando a ellas, no podemos emplear los identificadores. El tipo instancia o lista de instancias se utilizará.
\pagebreak

Ejemplo:
\begin{lstlisting}
Demonio UNIVERSIDAD.numero-alumnos:if-needed ()
	numero=0
	For ?titulacion in ?self.titulaciones
		numero=numero+(enviar ?titulacion dame-numero-alumnos)
	self.numero-alumnos=numero
\end{lstlisting}

\chapter{Tema 8: Planificación Automática (PA)}

\section{Introducción}
La idea es resolver problemas de manera automática. Tenemos un problema de planificación con determinadas características, si somos capaces de representar el problema con una determinada sintaxis podremos aplicar un planificar que lo resuelva, es fundamental poderlo representar en estos lenguajes.

Son problemas en los que estamos en un estado inicial, poseemos unos recursos y podemos realizar una serie de acciones para llegar al estado final deseado. La solución al problema será la secuencia de acciones que permiten llegar hasta este estado meta.

\textbf{Entradas:} Estado inicial $s_0$ (donde estamos), Metas $G$ (que queremos conseguir) y Acciones $A: s \rightarrow s', \gamma(s, a) = s'$ (nos permite pasar de un estado a otro)

\textbf{Solución:} Un plan $\pi$, secuencia de acciones que nos lleva desde el estado inicial $s_0$ hasta una meta $s_n \subseteq G$.

\subsection{Representación en Planificación}
Es necesario para que un ordenador pueda resolver los problemas que estén descritos estos problemas en un lenguaje  que este pueda entender. Hay muchas formas de expresar esta información.

Lógica de predicados es la más usada. Hay que representar estado y operadores. Los predicados en lógica permiten representar la verdad o falsedad de los hechos del mundo.
\begin{itemize}
	\item Emplea: términos, predicados, conectivas y cuantificadores.
\end{itemize}

No existe una única representación válida, pero habrá diferentes niveles de abstracción del problema a los que se debe adaptar.

\subsubsection{Lógica de Predicados}
Elementos:
\begin{itemize}
	\item \textbf{Términos:} constantes, variables y funciones.
	\item \textbf{Predicados}, los cuales representan: Relaciones, propiedades o igualdad.
	\item \textbf{Cuantificadores:} $\forall$ y $\exists$.
	\item \textbf{Conectiva:} $\vee$, $\wedge$, $\neg$, $\rightarrow$.
\end{itemize}
	
\textbf{Inferencia:} Modus Ponens
\begin{itemize}
	\item SI P, P $\rightarrow$ Q ENTONCES Q
\end{itemize}	

\textbf{Unificación:} encontrar los valores de las variables que hacen que la parte izquierda de la implicación sea igual a P(a).
\begin{itemize}
	\item $\forall X (P(X) \rightarrow Q(X))$ tenemos P(a)
	\item $X=a$
	\item $P(a) \rightarrow Q(a)$ como tenemos P(a) entonces Q(a)
\end{itemize}

El proceso de planificación ira mirando los estados y en función de las acciones que pueda aplicar ira avanzando, este proceso es una búsqueda del estado meta y una vez se encuentra el camino ya tenemos la solución.

Esta clase de problema son PSPACE-Complete, requieren tanta memoria que no somos capaces de resolverlos, se verán algunos problemas de los que es posible encontrar la solución.

\section{Representación}
\textbf{Simplificaciones:} planificación clásica
\begin{itemize}
	\item Se supone que los \textbf{estados son finitos}
	\item \textbf{Mundo aislado}, no hay factores externos que puedan variar nuestro estado, todo está controlado por nuestras acciones.
	\item \textbf{Determinista y acciones instantáneas}, siempre ocurren las acciones que se lanzan y se hacen al momento.
\end{itemize}

\textbf{Necesitamos representar}
\begin{itemize}
	\item \textbf{Estados:} inicial, final y estados intermedios
	\item \textbf{Acciones:} cambian el estado
\end{itemize}

\textbf{Formalización:} lenguajes de representación que el ordenador entienda. La mayoría están basados en lógica de predicados

\subsubsection{Estados y Acciones}
Los estados se describen:
\begin{itemize}
	\item Conjunto de \textbf{tipos de objetos}: persona, transporte, sitio, monumento.
	\item Conjunto de \textbf{objetos}: yo, bus1, castellana, Cibeles…
	\item Conjunto de \textbf{predicados genéricos}: at(?persona, ?lugar).
	\item Un \textbf{estado se representa por un conjunto de predicados instanciados}: at(yo, mi-casa), at(Bernabé, castellana).
\end{itemize}


Para representar una \textbf{acción} tenemos que saber \textbf{en qué estado} se puede ejecutar y \textbf{como cambia el estado y sus parámetros}.
\begin{itemize}
	\item viajar-en-metro(?persona, ?linea, ?estacion1, ?estacion2)
	\item \textbf{Estado:} at(?persona, ?estacion1), link(?linea, ?estacion1, ?estacion2)
	\item \textbf{Cambio estado:} at(?persona, ?estacion2), at(?persona, ?estacion1)
\end{itemize}

Hipótesis del mundo cerrado

\subsection{Representación en STRIPS}
Los estados $s \in S$ se representan mediante variables proposicionales.

El \textbf{estado inicial} $s_0$ es I.

Los \textbf{estados metas} $s_G \in S$ son aquellos tales que $G \subseteq s_G$.

Las \textbf{acciones} A(s) son los $a \in A$ que cumplen $Pre(a) \subseteq s$.

El estado resultante al aplicar a en s es $s’ = s – Del(a) + Add(a)$ (función de \textbf{transición de estados}).

El \textbf{coste} c(a, s) es siempre 1, por ahora siempre será mejor el plan más corto, pero se pueden asociar costes.

$P = (P, A, I, G)$
\begin{itemize}
	\item \textbf{P:} conjunto proposiciones (variables lógicas).
	\item \textbf{A:} conjunto de acciones.
	\item \textbf{I:} estado inicial.
	\item \textbf{G:} metas.
\end{itemize}

Cada operador se representa por:
\begin{itemize}
	\item Lista con los tipos de los objetos involucrados.
	\item \textbf{Pre(a) $\subseteq$ P}: precondiciones.
	\item \textbf{Add(a) $\subseteq$ P}: literales que pasan a ser verdaderos tras ejecutar a.
	\item \textbf{Del(a) $\subseteq$ P}: literales que pasan a ser falsos tras ejecutar a.
\end{itemize}

\subsection{Definición Problemas Planificación}
$\sqcap$ = (F, O, I, G)
\begin{itemize}
	\item \textbf{F:} conjunto de fluents (cosa que es verdadera o falsa) (describen los estados, s $\subseteq$ F)
	\item \textbf{O:} conjunto de operadores
	\item \textbf{I $\subseteq$ F:} estado inicial
	\item \textbf{G $\subseteq$ F:} metas del problema
\end{itemize}

Un \textbf{plan} es una secuencia de acciones que convierte el estado inicial en un estado donde se alcanzan todas las metas

\textbf{Heurísticas:} conocimiento utilizado para elegir las acciones. 

A partir del fichero \textbf{dominio D} y el de \textbf{problema P} se genera $\sqcap$.

\section{Implementación}
\textbf{Fichero de dominio D} (genérico), define el problema, como serán los estados y las acciones que se pueden aplicar.
\begin{itemize}
	\item \textbf{Predicados genéricos} para definir los estados. (at ?person ?place) (link ?s1 ?s2)
	\item \textbf{Operadores genéricos}: Move
	\begin{itemize}
		\item Parámetros: (?p ?from ?to)
		\item Precondiciones: (at ?p ?from)
		\item Efectos:
		\begin{itemize}
			\item Añadir: (at ?p ?to)
			\item Borrado: not(at ?p ?from)
		\end{itemize}
	\end{itemize}	
\end{itemize}
\pagebreak	

\textbf{Fichero de problema P} (instanciado), fichero con todo los objetos, estado inicial y meta.
\begin{itemize}
	\item \textbf{Objetos:} John, castellana, Cibeles…
	\item \textbf{Estados iniciales:} (at John castellana)…
	\item \textbf{Metas:} (at John Cibeles)…
\end{itemize}	

Tendremos un Parser para instanciar estados a partir de D y P, se definirán los elementos de P con la forma que define en D. 

Algoritmo de búsqueda.

\section{Lenguaje PDDL}

\subsection{PDDL 1.0}

\subsection{PDDL 2.1}

\subsection{PDDL 2.2}

\subsection{PDDL 3.0}

\section{Algoritmos de Planificación}

\end{document}