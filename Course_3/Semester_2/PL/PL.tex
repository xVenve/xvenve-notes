\documentclass[12pt, twoside, openright]{report} %fuente a 12pt, formato doble pagina y chapter a la derecha
\raggedbottom % No ajustar el contenido con un salto de pagina

% MÁRGENES: 2,5 cm sup. e inf.; 3 cm izdo. y dcho.
\usepackage[
a4paper,
vmargin=2.5cm,
hmargin=3cm
]{geometry}

% INTERLINEADO: Estrecho (6 ptos./interlineado 1,15) o Moderado (6 ptos./interlineado 1,5)
\renewcommand{\baselinestretch}{1.15}
\parskip=6pt

% DEFINICIÓN DE COLORES para portada y listados de código
\usepackage[table]{xcolor}
\definecolor{azulUC3M}{RGB}{0,0,102}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

% Soporte para GENERAR PDF/A
\usepackage[a-1b]{pdfx}

% ENLACES
\usepackage{hyperref}
\hypersetup{colorlinks=true,
	linkcolor=black, % enlaces a partes del documento (p.e. índice) en color negro
	urlcolor=blue} % enlaces a recursos fuera del documento en azul

% Añadir pdfs como partes del documento
\usepackage{pdfpages}
\usepackage{multicol}

% Quitar la indentación de principio de los parrafos
\setlength{\parindent}{0em}

% EXPRESIONES MATEMATICAS
\usepackage{amsmath,amssymb,amsfonts,amsthm}

\usepackage{txfonts} 
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

% Insertar graficas y fotos
\usepackage{tikz}
\usepackage{pgfplots}

\usepackage[spanish, es-tabla]{babel} 
\usepackage[babel, spanish=spanish]{csquotes}
\AtBeginEnvironment{quote}{\small}

% diseño de PIE DE PÁGINA
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\fancyfoot[LE,RO]{\thepage}
\fancypagestyle{plain}{\pagestyle{fancy}}

% DISEÑO DE LOS TÍTULOS de las partes del trabajo (capítulos y epígrafes o subcapítulos)
\usepackage{titlesec}
\usepackage{titletoc}
\titleformat{\chapter}[block]
{\large\bfseries\filcenter}
{\thechapter.}
{5pt}
{\MakeUppercase}
{}
\titlespacing{\chapter}{0pt}{0pt}{*3}
\titlecontents{chapter}
[0pt]                                               
{}
{\contentsmargin{0pt}\thecontentslabel.\enspace\uppercase}
{\contentsmargin{0pt}\uppercase}                        
{\titlerule*[.7pc]{.}\contentspage}                 

\titleformat{\section}
{\bfseries}
{\thesection.}
{5pt}
{}
\titlecontents{section}
[5pt]                                               
{}
{\contentsmargin{0pt}\thecontentslabel.\enspace}
{\contentsmargin{0pt}}
{\titlerule*[.7pc]{.}\contentspage}

\titleformat{\subsection}
{\normalsize\bfseries}
{\thesubsection.}
{5pt}
{}
\titlecontents{subsection}
[10pt]                                               
{}
{\contentsmargin{0pt}                          
	\thecontentslabel.\enspace}
{\contentsmargin{0pt}}                        
{\titlerule*[.7pc]{.}\contentspage}  


% DISEÑO DE TABLAS.
\usepackage{multirow} % permite combinar celdas 
\usepackage{caption} % para personalizar el título de tablas y figuras
\usepackage{floatrow} % utilizamos este paquete y sus macros \ttabbox y \ffigbox para alinear los nombres de tablas y figuras de acuerdo con el estilo definido. Para su uso ver archivo de ejemplo 
\usepackage{array} % con este paquete podemos definir en la siguiente línea un nuevo tipo de columna para tablas: ancho personalizado y contenido centrado
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\DeclareCaptionFormat{upper}{#1#2\uppercase{#3}\par}

% Diseño de tabla para ingeniería
\captionsetup[table]{
	format=hang,
	name=Tabla,
	justification=centering,
	labelsep=colon,
	width=.75\linewidth,
	labelfont=small,
	font=small,
}

% DISEÑO DE FIGURAS.
\usepackage{graphicx}
\graphicspath{{img/}} %ruta a la carpeta de imágenes

% Diseño de figuras para ingeniería
\captionsetup[figure]{
	format=hang,
	name=Fig.,
	singlelinecheck=off,
	labelsep=colon,
	labelfont=small,
	font=small		
}

% NOTAS A PIE DE PÁGINA
\usepackage{chngcntr} %para numeración continua de las notas al pie
\counterwithout{footnote}{chapter}

% LISTADOS DE CÓDIGO
% soporte y estilo para listados de código. Más información en https://es.wikibooks.org/wiki/Manual_de_LaTeX/Listados_de_código/Listados_con_listings
\usepackage{listings}

% definimos un estilo de listings
\lstdefinestyle{estilo}{ frame=Ltb,
	framerule=0pt,
	aboveskip=0.5cm,
	framextopmargin=3pt,
	framexbottommargin=3pt,
	framexleftmargin=0.4cm,
	framesep=0pt,
	rulesep=.4pt,
	backgroundcolor=\color{gray97},
	rulesepcolor=\color{black},
	%
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\bfseries,
	stringstyle=\ttfamily,
	showstringspaces = false,
	commentstyle=\color{gray45},     
	%
	numbers=left,
	numbersep=15pt,
	numberstyle=\tiny,
	numberfirstline = false,
	breaklines=true,
	xleftmargin=\parindent
}

\captionsetup[lstlisting]{font=small, labelsep=period}
% fijamos el estilo a utilizar 
\lstset{style=estilo}
\renewcommand{\lstlistingname}{\uppercase{Código}}

\pgfplotsset{compat=1.17} 
%-------------
%	DOCUMENTO
%-------------

\begin{document}
\pagenumbering{roman} % Se utilizan cifras romanas en la numeración de las páginas previas al cuerpo del trabajo
	
%----------
%	PORTADA
%----------	
\begin{titlepage}
	\begin{sffamily}
	\color{azulUC3M}
	\begin{center}
		\begin{figure}[H] %incluimos el logotipo de la Universidad
			\makebox[\textwidth][c]{\includegraphics[width=16cm]{Portada_Logo.png}}
		\end{figure}
		\vspace{2.5cm}
		\begin{Large}
			Grado en Ingeniería Informática\\			
			2020-2021\\
			\vspace{2cm}		
			\textsl{Apuntes}\\
			\bigskip
		\end{Large}
		 	{\Huge Procesadores de Lenguaje}\\
		 	\vspace*{0.5cm}
	 		\rule{10.5cm}{0.1mm}\\
			\vspace*{0.9cm}
			{\LARGE Jorge Rodríguez Fraile\footnote{\href{mailto:100405951@alumnos.uc3m.es}{Universidad: 100405951@alumnos.uc3m.es}  |  \href{mailto:jrf1616@gmail.com}{Personal: jrf1616@gmail.com}}}\\ 
			\vspace*{1cm}
	\end{center}
	\vfill
	\color{black}
		\includegraphics[width=4.2cm]{img/creativecommons.png}\\
		Esta obra se encuentra sujeta a la licencia Creative Commons\\ \textbf{Reconocimiento - No Comercial - Sin Obra Derivada}
	\end{sffamily}
\end{titlepage}

%----------
%	ÍNDICES
%----------	

%--
% Índice general
%-
\tableofcontents
\thispagestyle{fancy}

%--
% Índice de figuras. Si no se incluyen, comenta las líneas siguientes
%-
\listoffigures
\thispagestyle{fancy}

%----------
%	TRABAJO
%----------	
\clearpage
\pagenumbering{arabic} % numeración con números arábigos para el resto de la publicación	


%----------
%	COMENZAR A ESCRIBIR AQUI
%----------	

\chapter{Información}
\section{Profesores}

\begin{quote}
Teorías: Antonio Berlanga de Jesús y Jesús García Herrero

Prácticas: Juan Manuel Alonso Weber jmaw@ia.uc3m.es
\end{quote}

\section{Presentación}

Prácticas semanales por parejas.

Hay clases en el cronograma de más, algunas se usarán para recuperar clases.

Las prácticas las haremos en Linux, se puede utilizar máquina virtual, guernika y WSL2, lo importante es tener un terminal.

Vamos a usar bison y flex, programaremos en C.

\chapter{Repaso de TALF}

\section{Definiciones}

\textbf{Forma sentencial}: Aplicando reglas de producción llego a \(x \in \sum^*\)

\textbf{Sentencia}: Forma sentencial en el que x solo tiene Terminales.

\textbf{Lenguaje asociado a una gramática}: Todas las sentencias, secuencias de Terminales, de una gramática.

\textbf{Recursividad}: Aparece el terminal de la parte izquierda a la derecha.

\begin{itemize}
\item
  Recursividad a izquierda: $A \rightarrow Ay$
\item
  Recursividad a derechas: $A \rightarrow xA$
\end{itemize}

\textbf{Reglas compresoras}: Aquellas que producen menos símbolos de los
que hay a la izquierda. Como lo es \(x::= \lambda\)

\section{Gramática}

\(G=\{ \sum_T, \sum_N, S, P\}\)

\begin{itemize}
\item
  \(\sum_T\): Conjunto de símbolos \textbf{terminales}, alfabeto del
  lenguaje.
\item
  \(\sum_N\): Conjunto de símbolos \textbf{no terminales}.
\item
  \(S\): \textbf{Axioma} \(S \in \sum_N\)
\item
  \(P\): Conjunto de \textbf{Reglas de producción}.
\item
  Backus Normal Form: \(P_i ::= P_d\)
\item
  \(P_i \in (\sum_T \cup \sum_N)^+\) Al menos un símbolo
\item
  \(P_d \in (\sum_T \cup \sum_N)^*\) De 0 a infinitos símbolos
\item
  \(\lambda\) Clausula vacía
\end{itemize}


\subsection{Tipos de Gramáticas}

\textbf{Tipo 3}: Autómata Finito Determinista y Autómata Finito No
Determinista.

\begin{itemize}
\item
  Expresiones regulares o lineales.
\item
  Un solo No Terminal para dar:
  \(P_d ::= a | aN | Na; a \in \sum_T, N \in \sum_N\)
\item
  Lineal izquierda: \(P_d ::= a | Na\)
\item
  Lineal derecha: \(P_d ::= a | aN\)
\end{itemize}

\textbf{Tipo 2}: Autómata a Pila.

\begin{itemize}
\item
  Lenguaje Independiente del Contexto.
\item
  Un No Terminal para dar cualquier sentencia, excepto lambda que solo
  lo puede dar el axioma.
\end{itemize}

\textbf{Tipo 1}: Máquina Linealmente Acotada.

\begin{itemize}
\item
  Lenguaje de contexto libre.
\item
  Cualquier sentencia para dar cualquier secuencia, pero que no sea una
  regla reductora(tampoco se puede No Terminal para dar lambda).
\end{itemize}

\textbf{Tipo 0}: Máquina de Turing.

\begin{itemize}
\item
  Lenguaje sin restricciones.
\item
  Cualquier sentencia para dar cualquier secuencia de símbolos, incluso
  reglas reductoras.
\end{itemize}

\section{Problemas de lectura de sentencias}

\textbf{Precedencia}: Hay operadores con mayor prioridad. Se debe hacer
desde lo último derivado hacia arriba. Esto provoca ambigüedad, que es
nuestro enemigo.

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Ejemplo Precedencia}}
	{\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

  \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
  %uncomment if require: \path (0,161); %set diagram left start at 0, and has height of 161
  
  %Straight Lines [id:da45072977805155023] 
  \draw    (225,95) -- (225,110) ;
  %Straight Lines [id:da2749727219932785] 
  \draw    (250,95) -- (250,110) ;
  %Straight Lines [id:da8716593878972485] 
  \draw    (270,65) -- (270,110) ;
  %Straight Lines [id:da4949071295340721] 
  \draw    (250,65) -- (250,75) ;
  %Straight Lines [id:da021799402318489314] 
  \draw    (260,35) -- (260,45) ;
  %Straight Lines [id:da16431659853465352] 
  \draw    (340,95) -- (340,110) ;
  %Straight Lines [id:da9657613545307073] 
  \draw    (361,95) -- (361,110) ;
  %Straight Lines [id:da43212636732503995] 
  \draw    (320,65) -- (320,110) ;
  %Straight Lines [id:da3961826548029601] 
  \draw    (340,65) -- (340,75) ;
  %Straight Lines [id:da6475380278259601] 
  \draw    (330,35) -- (330,45) ;
  %Shape: Brace [id:dp2548873557192568] 
  \draw   (372.25,130.08) .. controls (376.92,130.07) and (379.25,127.74) .. (379.24,123.07) -- (379.18,88.66) .. controls (379.17,81.99) and (381.5,78.65) .. (386.17,78.64) .. controls (381.5,78.65) and (379.16,75.33) .. (379.15,68.66)(379.16,71.66) -- (379.1,34.24) .. controls (379.09,29.57) and (376.76,27.24) .. (372.09,27.25) ;
  
  % Text Node
  \draw (194,0) node [anchor=north west][inner sep=0.75pt]   [align=left] {Se hace desde lo último derivando hacia arriba};
  % Text Node
  \draw (392.75,57) node [anchor=north west][inner sep=0.75pt]   [align=left] {Ambigüedad\\(enemigo)};
  % Text Node
  \draw (325,22.4) node [anchor=north west][inner sep=0.75pt]    {$e$};
  % Text Node
  \draw (336,77.4) node [anchor=north west][inner sep=0.75pt]    {$e\cdot e$};
  % Text Node
  \draw (312,47.4) node [anchor=north west][inner sep=0.75pt]    {$e+e$};
  % Text Node
  \draw (314,112.4) node [anchor=north west][inner sep=0.75pt]    {$1$};
  % Text Node
  \draw (335,112.4) node [anchor=north west][inner sep=0.75pt]    {$2$};
  % Text Node
  \draw (356,112.4) node [anchor=north west][inner sep=0.75pt]    {$3$};
  % Text Node
  \draw (256,22.4) node [anchor=north west][inner sep=0.75pt]    {$e$};
  % Text Node
  \draw (247,47.4) node [anchor=north west][inner sep=0.75pt]    {$e\cdot e$};
  % Text Node
  \draw (221,77.4) node [anchor=north west][inner sep=0.75pt]    {$e+e$};
  % Text Node
  \draw (220,112.4) node [anchor=north west][inner sep=0.75pt]    {$1$};
  % Text Node
  \draw (245,112.4) node [anchor=north west][inner sep=0.75pt]    {$2$};
  % Text Node
  \draw (265,112.4) node [anchor=north west][inner sep=0.75pt]    {$3$};
\end{tikzpicture}
}
\end{figure}

\textbf{Dangling Else}: Sobre a quién pertenece el else, en C el else
pertenece al último else.

\begin{lstlisting}[language=C]
if C1 then A else if C2
then B else C
\end{lstlisting}

\textbf{Asociatividad}: Entre operaciones con la misma precedencia.
1-1-1-1


\section{Derivación}

Aplicación de una producción a una forma sentencial.

\textbf{Derivación más a la izquierda}: Sustituye el símbolo no terminal
más a la izquierda.

\textbf{Derivación más a la derecha}: Sustituye el símbolo no terminal
más a la derecha.


\section{Ambigüedad}

Hay distintos niveles:

\begin{itemize}

\item
  \textbf{Sentencia}: Se puede obtener por dos derivaciones diferentes.
\item
  \textbf{Gramática}: Si puede obtener una sentencia con dos
  derivaciones.
\item
  \textbf{Lenguaje}: Todas las gramáticas que lo generan son ambiguas
  entonces es inherentemente ambiguo.
\end{itemize}


\section{Bien formar Gramáticas}

\textbf{Limpiar}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Sin \textbf{reglas innecesarias}: Un terminal que se da a sí mismo.
  A→A
\item
  Sin \textbf{símbolos inaccesibles}: Poner T y NT, e ir tachando según
  aparecen, los que no aparecen regla fuera.
\item
  Sin \textbf{símbolos superfluos}: Empezamos con las reglas que solo
  producen terminales e ir subiendo por pasos.
\end{enumerate}

Sin reglas \textbf{no generativas}: Las que dan lambda, quitarlas y
sustituir sus apariciones por lambda(nada).

Sin reglas de \textbf{redenominación}: Las que llaman aun solo símbolo
No Terminal, poner las reglas de ese símbolo en el que lo invoca.


\section{Transformaciones útiles en compiladores}

Estas transformaciones facilitan a los analizadores predictivos. Estos
analizadores implican que nunca se va a hacer backtracking siempre
sabemos que regla de producción hay que aplicar o no hay más, pero no se
retrocede.

\textbf{Factorización a izquierdas}

\begin{itemize}
\item
  Cuando hay una estructura común en las reglas de producción.
\item
  Se crea un nuevo No terminal para dar los símbolos que acompañan a esa
  parte común, en el original se pone la parte común seguida del nuevo
  símbolo.
\end{itemize}

P: $A \rightarrow \beta \cdot \alpha_1 | \beta \cdot \alpha_2$ Hay una estructura comun

\begin{enumerate}
  \item $\Sigma_N = \Sigma_N \cup \{ A'\}$ Nuevo no terminal
  \item $B = (B - P)$ Se quitan las reglas
  \item $B' = B \cup \{ A \rightarrow \beta \cdot A',{ } A' \rightarrow \alpha_1 | \alpha_2 \}$
\end{enumerate}

\textbf{Eliminar recursividad por la izquierda}

\begin{itemize}
\item
  Para evitar recursividades pendientes, ya que leemos de izquierda a
  derecha, así reconocemos mientras aplicamos reglas.
\item
  A las reglas no recursivas a izquierda se le concatena un nuevo No
  Terminal (quitamos las que eran recursivas).
\item
  Ese nuevo símbolo produce \(\lambda\) y lo que producía originalmente
  que era recursivo a izquierda, pero en recursividad a la derecha.
\end{itemize}

$\forall P \subseteq B | P = (A \rightarrow A \cdot \alpha | B)$
\begin{enumerate}
  \item $\Sigma_N = \Sigma_N \cup \{ A'\}$
  \item $B = (B - P)$ 
  \item $B' = B \cup \{ A \rightarrow \beta \cdot A',{ } A' \rightarrow \alpha \cdot A' | \lambda \}$
\end{enumerate}

\section{Autómata Finito Determinista}

\(AFD=( \sum, Q, f, q_o, F)\)

\textbf{Donde:}

\begin{itemize}
\item
  \(\sum\) Símbolos de entrada, Tokens.
\item
  \(Q\) Estados.
\item
  \(q_o \in Q\) Estado inicial.
\item
  \(F \subseteq Q\) Estados finales.
\item
  \(f(q,a \cdot x)\) Función de transición. Con un estado y un símbolo,
  voy a un estado.
\end{itemize}

\begin{multicols}{2}
\begin{table}[H]
\centering
\begin{tabular}{r|c|c|}
\cline{2-3}
\multicolumn{1}{l|}{}                                & \textbf{a} & \textbf{b} \\ \hline
\multicolumn{1}{|r|}{$\boldsymbol{\rightarrow q_0}$} & $q_1$      & $q_2$      \\
\multicolumn{1}{|r|}{$\boldsymbol{q_1}$}             & $q_1$      & $q_0$      \\
\multicolumn{1}{|r|}{$\boldsymbol{*q_2}$}            & $q_1$      & $q_2$      \\ \hline
\end{tabular}
\caption{Tabla de transiciones}
\end{table}

\columnbreak
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Diagrama de transiciones}}
	{\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Flowchart: Connector [id:dp07993535049485034] 
\draw   (271,66) .. controls (271,57.72) and (277.49,51) .. (285.5,51) .. controls (293.51,51) and (300,57.72) .. (300,66) .. controls (300,74.28) and (293.51,81) .. (285.5,81) .. controls (277.49,81) and (271,74.28) .. (271,66) -- cycle ;
%Flowchart: Connector [id:dp7169760176687654] 
\draw   (310.75,139.5) .. controls (310.75,131.22) and (317.24,124.5) .. (325.25,124.5) .. controls (333.26,124.5) and (339.75,131.22) .. (339.75,139.5) .. controls (339.75,147.78) and (333.26,154.5) .. (325.25,154.5) .. controls (317.24,154.5) and (310.75,147.78) .. (310.75,139.5) -- cycle ;
%Flowchart: Connector [id:dp3068425266497352] 
\draw   (381,57) .. controls (381,48.72) and (387.49,42) .. (395.5,42) .. controls (403.51,42) and (410,48.72) .. (410,57) .. controls (410,65.28) and (403.51,72) .. (395.5,72) .. controls (387.49,72) and (381,65.28) .. (381,57) -- cycle ;
%Flowchart: Connector [id:dp3953211758173052] 
\draw   (309,139.5) .. controls (309,130.39) and (316.28,123) .. (325.25,123) .. controls (334.22,123) and (341.5,130.39) .. (341.5,139.5) .. controls (341.5,148.61) and (334.22,156) .. (325.25,156) .. controls (316.28,156) and (309,148.61) .. (309,139.5) -- cycle ;
%Straight Lines [id:da011534921262301268] 
\draw    (249,66) -- (268,66) ;
\draw [shift={(271,66)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Curve Lines [id:da9910642337450042] 
\draw    (404,42) .. controls (432.52,32.11) and (445.42,49.87) .. (416.78,56.43) ;
\draw [shift={(414,57)}, rotate = 349.44] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (7.14,-3.43) -- (0,0) -- (7.14,3.43) -- cycle    ;
%Curve Lines [id:da062406182328217374] 
\draw    (342,147) .. controls (367.81,163.15) and (327.25,210.74) .. (324.12,161.33) ;
\draw [shift={(324,159)}, rotate = 447.85] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (7.14,-3.43) -- (0,0) -- (7.14,3.43) -- cycle    ;

% Text Node
\draw (279,56.4) node [anchor=north west][inner sep=0.75pt]    {$q_{0}$};
% Text Node
\draw (387,46.4) node [anchor=north west][inner sep=0.75pt]    {$q_{1}$};
% Text Node
\draw (316,127.4) node [anchor=north west][inner sep=0.75pt]    {$q_{2}$};
% Text Node
\draw (309,20) node [anchor=north west][inner sep=0.75pt]   [align=left] {a};
% Text Node
\draw (334,71) node [anchor=north west][inner sep=0.75pt]   [align=left] {b};
% Text Node
\draw (276,110) node [anchor=north west][inner sep=0.75pt]   [align=left] {b};
% Text Node
\draw (372,101) node [anchor=north west][inner sep=0.75pt]   [align=left] {a};
% Text Node
\draw (438,32) node [anchor=north west][inner sep=0.75pt]   [align=left] {a};
% Text Node
\draw (355,152) node [anchor=north west][inner sep=0.75pt]   [align=left] {b};
% Connection
\draw    (297.31,52) .. controls (323.41,28.89) and (351.54,25.86) .. (381.68,42.91) ;
\draw [shift={(384,44.26)}, rotate = 210.87] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (7.14,-3.43) -- (0,0) -- (7.14,3.43) -- cycle    ;
% Connection
\draw    (385.69,68) .. controls (359.59,91.11) and (331.46,94.14) .. (301.32,77.09) ;
\draw [shift={(299,75.74)}, rotate = 390.87] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (7.14,-3.43) -- (0,0) -- (7.14,3.43) -- cycle    ;
% Connection
\draw    (285.11,78) .. controls (278.09,103.09) and (286.5,120.35) .. (310.34,129.78) ;
\draw [shift={(313,130.78)}, rotate = 199.55] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (7.14,-3.43) -- (0,0) -- (7.14,3.43) -- cycle    ;
% Connection
\draw    (336,133.43) .. controls (390.21,122.75) and (411.62,101.75) .. (400.24,70.43) ;
\draw [shift={(399.3,68)}, rotate = 427.69] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (7.14,-3.43) -- (0,0) -- (7.14,3.43) -- cycle    ;

\end{tikzpicture}}
\end{figure}
\end{multicols}
Extensión a palabras: Recibe una palabra y va cogiendo los símbolos de
entrada, y aplicando reglas sucesivas. Palabras que partiendo del
inicial nos permite llegar a uno final.

\textbf{Lenguaje asociado:} Aquellas palabras tales que aplicando
extensión a palabra el \(q_o\) alcanza su estado de F, final.

\textbf{Equivalencia de AFD:} Si el lenguaje que reconocen es el mismo.

\textbf{Minimización de AFD:} Autómata finito mínimo equivalente es
aquel con menor número de estado, pero mismo lenguaje.

Siempre se puede pasar de G3 a AFD, aunque puede que no directo, por
medio de AFND.


\section{Autómata Finito No Determinista}

\begin{itemize}
\item
  Admite \(\lambda\) y más de una posibilidad por símbolo.
\item
  \(AFND=( \sum, Q, f, q_o, F)\) Los símbolos representan lo mismo que
  en AFD.
\item
  En este caso se permite transicionar sin recibir símbolo, lambda,
  además, varias transiciones para un mismo símbolo en un mismo estado.
\end{itemize}

Para cualquier AFD existe uno no determinista equivalente.

Para toda gramática G3 existe un autómata determinista y no
determinista.


\section{Autómata a Pila (G2)}

\(AP=(\sum, \Gamma, Q, A_0, q_0, f, F)\)

\textbf{Donde:}

\begin{itemize}
\item
  \(\Gamma\) Conjunto de símbolos de pila
\item
  \(A_0\) Símbolo de pila inicial
\item
  \(f(q,\lambda,A)\) Transita a uno o varios estados y puede escribir o
  no en pila, cuando escribe pueden ser más de 1.
\item
  Para toda gramática G2 existe un AP.
\item
  El AP puede ser no determinista y en general
  \(APND \nrightarrow APD\).
\item
  Lenguaje aceptado por un AP, palabras que reconoce, y el final lo
  determina:
\end{itemize}

\textbf{Por estado final:} Cuando llega a un estado final y la secuencia
de entrada, está vacía, termina.

\textbf{Por vaciado de pila:} Entrada y pila vacía, termina.


\section{Expresiones Regulares G3}
\begin{multicols}{2}
\textbf{Definición:}

\begin{itemize}
\item
  \(\empty\) es una ER.
\item
  \(\lambda\) es una ER.
\item
  a es una ER, siendo a un Tokens.
\item
  \(\alpha + \beta\) es una ER, la unión.
\item
  \(\alpha \cdot \beta\) es una ER, la concatenación.
\item
  \(\alpha ^*\) es una ER, la clausura.
\end{itemize}
\columnbreak
\textbf{ER útiles:}

\begin{itemize}
\item
  \(\alpha ^+ =\alpha \cdot \alpha ^*= \alpha ^* \cdot \alpha\) Al menos
  1
\item
  \(\alpha? = \alpha | \lambda\) Puede ser alpha o lambda
\item
  \([abc] = a|b|c\) Es a o b o c
\item
  \([a-z] = a|b|...|z\)
\end{itemize}
\end{multicols}

Dos EERR son equivalentes si describen el mismo lenguaje.

\textbf{Lenguaje asociado a una ER}
\begin{itemize}
  \item si $\alpha = \emptyset, L(\alpha) = \emptyset$
  \item si $\alpha = \lambda , L(\alpha) = \lambda$
  \item si $\alpha = a | a \in \Sigma, L(\alpha) = \{a\}$
  \item si $\alpha$ y $\beta$ son EERR $\Rightarrow L(\alpha+\beta)= L(\alpha) \cup L(\beta)$ 
  \item si $\alpha$ y $\beta$ son EERR $\Rightarrow L(\alpha\cdot\beta)= L(\alpha) \cdot L(\beta)$ 
  \item si $\alpha^*$ es una ER $\Rightarrow L(\alpha^*)= L(\alpha)^*$ 
\end{itemize}

\textbf{Propiedades}
\begin{multicols}{2}
\begin{enumerate}
  \item $(\alpha+\beta)+\sigma = \alpha + (\beta + \sigma)$
  \item $\alpha + \beta = \beta + \alpha$
  \item $(\alpha \cdot \beta)\cdot\sigma = \alpha \cdot (\beta\cdot\sigma)$
  \item $\alpha \cdot (\beta +\sigma) = (\alpha \cdot \beta) + (\alpha \cdot \sigma)$
  
  $(\beta +\sigma) \cdot \alpha  = (\beta \cdot \alpha) + (\sigma \cdot \alpha)$
  \item $\alpha \cdot \lambda = \lambda \cdot \alpha = \alpha$
  \item $\alpha + \phi = \phi + \alpha = \alpha$
  \item $\lambda^* = \lambda$
  \item $\alpha \cdot \phi = \phi \cdot \alpha= \phi$
  \item $\phi^* = \lambda$
  \item $\alpha^* \cdot \alpha^* = \alpha^*$
  \item $\alpha \cdot \alpha^* = \alpha^* \cdot \alpha$
  \columnbreak
  \item $(\alpha^*)^*=\alpha^*$
  \item $\alpha^* = \lambda + \alpha + \alpha^2 + ... + \alpha^n + \alpha^{n+1} \cdot \alpha^*$
  \item $\alpha^* = \lambda + \alpha \cdot \alpha^*$
  \item $\alpha^* = (\lambda + \alpha)n-1 + \alpha n \cdot \alpha^*$
  \item Sea $f$ una función, $f: E_{\Sigma^n} \rightarrow E_\Sigma$ se verifica: 
  
  $f(\alpha, \beta, ..., \sigma) + (\alpha + \beta + ... + \sigma)^* = (\alpha + \beta + ... + \sigma)^*$

  \item Sea $f$ una función, $f: E_{\Sigma^n} \rightarrow E_\Sigma$ se verifica: 
  
  $(f(\alpha^*, \beta^*, ..., \sigma^*))^* = (\alpha + \beta + ... + \sigma)^*$

  \item $(\alpha^* + \beta^*)^* = (\alpha^* \cdot \beta^*)^* = (\alpha + \beta)^*$ (IMPORTANTE)
  \item $(\alpha \cdot \beta)^*\cdot \alpha = \alpha \cdot (\beta \cdot \alpha)^*$
  \item $(\alpha^* \cdot \beta)^*\cdot \alpha^* =(\alpha + \beta)^*$  
  \item $(\alpha^* \cdot \beta)^*\cdot \alpha^* = \lambda + (\alpha + \beta)^*\cdot \beta$
  \item Regla de Inferencia: 
  
  Si $X=AX+B$ entonces $X=A^*B$
\end{enumerate}
\end{multicols}

\chapter{Tema 1: Introducción}

\textbf{Compilador}: Proceso de traducción que convierte un programa
fuente escrito en un lenguaje de alto nivel a un programa objeto en
código máquina y listo por tanto para ejecutarse en el ordenador. Solo
se genera el programa objeto cuando no hay errores.

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Diagrama tipos de programación}}
	{\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Left Arrow [id:dp1857161983900779] 
\draw   (210,75) -- (242,65) -- (242,70) -- (290,70) -- (290,80) -- (242,80) -- (242,85) -- cycle ;
%Left Arrow [id:dp7925392290496789] 
\draw   (410,75) -- (442,65) -- (442,70) -- (490,70) -- (490,80) -- (442,80) -- (442,85) -- cycle ;

% Text Node
\draw    (498,48) -- (602,48) -- (602,102) -- (498,102) -- cycle  ;
\draw (550,75) node   [align=left] {\begin{minipage}[lt]{68pt}\setlength\topsep{0pt}
\begin{center}
Lenguaje de alto Nivel
\end{center}

\end{minipage}};
% Text Node
\draw    (298,48) -- (402,48) -- (402,102) -- (298,102) -- cycle  ;
\draw (350,75) node   [align=left] {\begin{minipage}[lt]{68pt}\setlength\topsep{0pt}
\begin{center}
Lenguaje\\Ensamblador
\end{center}

\end{minipage}};
% Text Node
\draw    (98,48) -- (202,48) -- (202,102) -- (98,102) -- cycle  ;
\draw (150,75) node   [align=left] {\begin{minipage}[lt]{68pt}\setlength\topsep{0pt}
\begin{center}
Codigo\\Máquina
\end{center}

\end{minipage}};
% Text Node
\draw    (450, 25) circle [x radius= 70.71, y radius= 21.21]   ;
\draw (450,25) node   [align=left] {\begin{minipage}[lt]{68pt}\setlength\topsep{0pt}
\begin{center}
Compilador
\end{center}

\end{minipage}};
% Text Node
\draw    (250, 25) circle [x radius= 70.71, y radius= 21.21]   ;
\draw (250,25) node   [align=left] {\begin{minipage}[lt]{68pt}\setlength\topsep{0pt}
\begin{center}
Ensamblador
\end{center}

\end{minipage}};


\end{tikzpicture}}
\end{figure}

\textbf{Programa fuente → Compilador → Programa objeto/Mensajes de
error.}

Originalmente, cuando no existía se metía con 1's y 0's, código máquina.

Después, se creó el ensamblador que traduce un código nemotécnico
(lenguaje ensamblador) a código máquina.

Por último, el compilador sobre el ensamblador, esto facilito mucho las
cosas.

En los 50 se consideraban los programas más difíciles.

Con el tiempo se ha facilitado mucho con entornos de programación y
herramientas, no hay una fecha exacta del primer compilador.

Los primeros traducían fórmulas aritméticas a código máquina.

\textbf{Motivación}:

\begin{itemize}

\item
  Saber cómo se obtiene un ejecutable para alcanzar mejor eficiencia y
  corrección.
\item
  Para entender mejor los lenguajes de programación.
\item
  Conocer la teoría que hace posible su funcionamiento y como se ha
  llegado hasta este punto.
\item
  Aplicar la teoría y herramientas a otros campos:

  \begin{itemize}
  
  \item
    Intérpretes de comandos y consultas
  \item
    Formateadores de texto (LaTeX, HTML)

    \begin{itemize}
    
    \item
      Gráficos, ecuaciones,\ldots{} (PS, GIF, EQN, \ldots)
    \item
      Lenguajes de simulación (GPSS)
    \end{itemize}
  \end{itemize}
\end{itemize}
\pagebreak
\textbf{Aplicación}:

\begin{itemize}

\item
  Desarrollo de interfaces de texto.
\item
  Tratamiento de ficheros de texto estructurado.
\item
  Procesadores de texto.
\item
  Formateo de texto y descripción gráfica.
\item
  Procesamiento del lenguaje natural.
\item
  \ldots{}
\end{itemize}

\textbf{Diferencia entre un compilador y un intérprete}: El compilador solo
hace la traducción a algo que se puede ejecutar, sin embargo, el
intérprete no solo lo traduce, sino que lo va ejecutando.

\textbf{Ensamblador}: Compilador sencillo, traduce a código máquina
sentencias simples de lenguaje fuente.

\textbf{Traductor}: Normalmente se refiere a la traducción entre dos
lenguajes al mismo nivel de abstracción.

\textbf{Interprete}: Es un programa que simultáneamente analiza y
ejecuta un programa escrito en lenguaje fuente.

\textbf{Compilador cruzado}: Compilador que traduce un lenguaje fuente a
objeto donde el objeto es para un ordenador distinto del que compila.

\textbf{Compile-Link-Go frente a Compile-Go}: Uno Fragmenta, Compila,
Enlaza las partes y tras crearlo lo ejecuta, y el otro Compila en un
módulo cargable y Ejecuta el módulo.

\textbf{Compilador de una o varias pasadas}.

Una pasada es un recorrido total de todo el código fuente con una misión
específica.

\textbf{Traductor o compilador incremental}: Encontrados y corregidos
los errores después solo se compilan estos.

\textbf{Autocompilador}: Compilador escrito en el propio lenguaje que
compila. Esto facilita la portabilidad.

\textbf{Metacompilador}: Programa que recibe la definición de un
lenguaje (Gramática) y genera un compilador para ese lenguaje.

\textbf{Ejecutable}: Código objeto enlazado con las librerías.


\section{Compilación}


\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Esquema de Compilación}}
	{\def\svgwidth{.8\textwidth}
  \input{./img/procesoCompilador.eps_tex}}
\end{figure}

Antes del pasar al compilador se pasa al \textbf{preprocesador que hace muchas funciones}, entre ellas, sustituir las constantes por su valor y quita los comentarios. Cuando termina pasa el programa fuente al compilador.
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Diagrama de Fases de un Compilador}}
	{\input{./img/fasesCompilador.eps_tex}}
\end{figure}

\textbf{Análisis}: Parte que solo depende de la estructura del lenguaje, no de la arquitectura de la máquina.
\begin{itemize}
  \item \textbf{Analizador léxico (scanner)}: Convierte la entrada (y::= 3+b*3) en Símbolos terminales (id op num op id op num) de una gramática. A este llegan directamente los datos, no al resto. Su salida va al siguiente.

    Análisis lineal: La cadena de entrada se lee de izquierda a derecha y se agrupa en componentes léxicos (tokens)
    
    \begin{figure}[H]
      \ffigbox[\FBwidth]
      {\caption{Diagrama Analizador Léxico}}
      {\def\svgwidth{.8\textwidth}
      \input{./img/DAL.eps_tex}}
    \end{figure}
    
  \item \textbf{Analizador sintáctico:} Agrupa los componentes léxicos en frases
    gramaticales que el compilador utiliza. A partir de los tokens produce
    un árbol sintáctico.
    
    \begin{itemize}
    \item
      Recibe tokens → crea un árbol.
    \item
      En las hojas tiene los terminales en la manera en la que identifica el
      token.
    \end{itemize}
    
    \begin{figure}[H]
      \ffigbox[\FBwidth]
      {\caption{Diagrama Analizador Sintáctico}}
      {\def\svgwidth{.8\textwidth}
      \input{./img/DAS.eps_tex}}
    \end{figure}
  \pagebreak
  \item \textbf{Analizador semántico:} Busca errores semánticos, reúne información de tipos, identifica operadores y operandos.
  
    \begin{itemize}
    \item
      Recibe el árbol sintáctico explícita o implícitamente, y trata de
      determinar si tiene sentido las distintas operaciones.
    
      Por ejemplo: Sumar un número y una cadena de caracteres.
    \end{itemize}
\end{itemize}


\textbf{Generación}: Depende de la arquitectura, pero no del lenguaje.
\begin{itemize}
  \item \textbf{Generador de código intermedio}: A veces se encuentra en análisis y otras
  en generación. Convierte el árbol en instrucciones, código
  intermedio (ensamblador). El recorrido es importante, ya que al generar
  código no se ve la jerarquía. Por ejemplo: Primero se tienen que hacer
  las operaciones antes de asignar el valor.
  
  El recorrido es importante ya que al generar codigo no se ve la jerarquia.
  
  \item \textbf{Optimizador:} Trata de darse cuenta de subárboles comunes para
  no repetir operaciones en las que no cambian variables. En vez de volver
  a poner esa estructura apunta a ella.
  
  \item \textbf{Generador de código:} El uso de código intermedio reduce la
  complejidad del desarrollo de compiladores. m front ends y n back-ends
  comparten un código intermedio común.

\end{itemize}

\textbf{Front-end}: Etapa inicial. Fases que dependen del lenguaje
fuente y que son independientes de la máquina. Análisis léxico,
sintáctico, semántico y generación de código intermedio, manejo de
errores de cada parte.

\textbf{Back-end}: Etapa final. Fases que dependen de la máquina,
dependen del lenguaje intermedio. Optimización de código, generación de
código, operaciones con la tabla de símbolos.

\pagebreak
\section{Diagramas de Tombstone}

Conjunto de piezas de puzzle útiles para razonar acerca de los
procesadores de lenguaje y los programas.

Está formado por piezas que deben encajar, encajan según unas reglas de
formación.

La máquina y el lenguaje deben coincidir.

\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Diagrama Tombstone Programas y Máquinas}}
  {\def\svgwidth{.8\textwidth}
  \input{./img/tombstone.eps_tex}}
\end{figure}

\chapter{Tema 2: Análisis Léxico}

\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Diagrama AL}}
  {\def\svgwidth{.8\textwidth}
  \input{./img/DAL2.eps_tex}}
\end{figure}

\section{Funciones del Análisis Léxico}

\textbf{Manejar el fichero fuente:} Leer los caracteres de la entrada.
Eliminar comentarios y delimitadores. Relacionar los mensajes de error
con las líneas del programa fuente.

\textbf{Interfaz con las otras fases de análisis:} Generar la secuencia
de componentes léxicos (tokens). Introducir los identificadores en la
\textbf{tabla de símbolos}. Manejar macros. pi→3,14

\textbf{Controlar si es de formato libre o no:} Libre: PASCAL. No libre:
FORTRAN.


\section{Aspectos del Análisis Léxico}

\textbf{Diseño más sencillo:} Los símbolos que trata el scanner se
describen con una gramática más simple que la del parser.

\textbf{Mejora la eficiencia:} Gran parte del tiempo de compilación se
consume en la lectura y exploración.

\textbf{Mejora la portabilidad:} Se pueden tener varias versiones del
scanner una para distintos códigos.

\textbf{Tokens}: Unidades sintácticas de un lenguaje. Símbolos
terminales de una gramática, identificadores, palabras reservadas.

\begin{itemize}

\item
  num es el token.
\end{itemize}

\textbf{Categoría:}

\begin{itemize}
\item
  \textbf{Palabras reservadas}: IF, THEN, DO\ldots{}
\item
  \textbf{Identificadores}: main, suma, identificadores\ldots{}
\item
  \textbf{Símbolos especiales}: Como \textless, \textgreater\ldots{}
\item
  \textbf{Constantes y literales.}
\end{itemize}

\textbf{Lexema:} Secuencias válidas para un token. Secuencia de
caracteres del código fuente que son identificados como un token
específico.

\begin{itemize}

\item
  El lexema de num son los valores que puede tomar: 12, 34, 480
\end{itemize}

\textbf{Atributos:} Información adicional que tiene el token.

\begin{itemize}

\item
  id.lexema=``x'' id.tipo id.ámbito
\end{itemize}

\textbf{Patrón:} Define la secuencia de caracteres válidos para un
tokens, formato de los lexemas.

\begin{itemize}
\item
  \([0-9]^+\) Naturales \(-?[0-9]^+\) Enteros de -9 a 9
\item
  El + al final, indica que hay 1 o más ocurrencias. Para poner
  determinados símbolos se ponen ""
\end{itemize}

\textbf{Especificar tokens:} Con expresiones regulares, patrones, o
Autómatas Finitos.

\begin{itemize}
\item
  Los elementos básicos en un lenguaje deben ser tokens.
\item
  Se pueden usar Expresiones regulares o Autómatas Finitos.
\end{itemize}

\textbf{Tabla de símbolos:} Almacenan la correspondencia entre tokens y lexemas. 
En muchos lenguajes hay palabras claves (reservadas) para las que no se puede declarar una variable, y estas se almacenan en la tabla.

\begin{itemize}

\item
  Los atributos de los identificadores se pueden guardar en la tabla de
  símbolos. Los otros en otra tabla.
\end{itemize}

\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Diagramas A. Lexico}}
  {\def\svgwidth{.9\textwidth}
  \input{./img/DTransiciones.eps_tex}}
\end{figure}

Un AF no devuelve el token, se usa otra cosa para que nos dé el token
cuando reconoce símbolos.

Nosotros vamos a usar DT para representar.


\section{Diagrama de Transiciones - DT}

\textbf{Definir formalmente un AL es hacer los DT de los tokens} (ojo
con los separadores que llevan a finales, si no hay nada, que no salga)

Se usa para especificar el funcionamiento de un Analizador Léxico
mediante un AFD. \textbf{UNO POR TOKEN}

Se diferencian porque el DT reconoce un token cuando reconoce un
delimitador y devuelve entonces el token. \textbf{Lee caracteres hasta
completar un token entonces: Devuelve el token leído} y Deja el buffer
listo para la siguiente llamada.

No tiene estados de error. De los estados de aceptación no salen
transiciones, necesita una transición más que no pertenece al token, que
le hace salir y devolver el token.

Esto quiere decir que aquellos estados que son terminales y pueden
transitar a otro estado tengan una transición para otro tipo de carácter
que hace que salga como final.

\section{Construcción de un AFD para AL}

Normalmente se parte de representación de las reglas de tokens con
expresiones regulares.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}

\item
  Toda expresión regular tiene un AFND asociado.
\item
  Construir un AFD para el mismo lenguaje del AFND
\item
  Optimización del AFD.
\end{enumerate}


\section{Tabla de Transiciones de DT}

\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Diagrama Tabla de Transiciones}}
  {\def\svgwidth{.9\textwidth}
  \input{./img/DTransiciones2.eps_tex}}
\end{figure}

\section{Autómata programado}

Es la manera de programar un Analizador Léxico.

Representa directamente con un programa al DT en cuestión.

\begin{lstlisting}[language=C]
estado := 1 # El inicial es el estado 1
while estado<>6 do
  Leecar {devuelve en car el siguiente carater leido}
  case estado of
    1: if car="a" then estado:=2 else
       if car="d" then esatdo:=5 else error
    2: if car="c" then estado:=3 else
       if car="b" then estado:=2 else error
    3: if car="a" then estado:=4 else error
    4: if car="$" then estado:=6 else error
    5: if car="d" then estado:=3 else error
    3: error
  end case
end while
\end{lstlisting}

\section{Implementación de un AL}

\subsection{Utilizando un generador de Analizadores Léxicos (es lo que usaremos)}

\begin{itemize}
\item
  \textbf{Ventajas}: Comodidad y Rapidez de desarrollo.
\item
  \textbf{Inconvenientes}: Ineficiencia.
\item
  \textbf{Recomendación}: Ordenar las reglas de acuerdo con la frecuencia
  de utilización.
\end{itemize}


\subsection{Utilizando ensamblador}

\begin{itemize}

\item
  \textbf{Ventajas}: Más eficiente y compacto.
\item
  \textbf{Inconvenientes}: Más difícil de desarrollar y Dificultad de
  mantenimiento de código generado.
\end{itemize}


\subsection{Utilizando un lenguaje de alto nivel}

\begin{itemize}
\item
  \textbf{Ventajas}: Eficiente y Compacto.
\item
  \textbf{Inconveniente}: Realizar todo a mano.
\item
  Técnicas:

  \begin{itemize}
  \item \textbf{Programación}: Muy eficiente.    
  \item \textbf{Controlado por tablas}: Código pequeño, general y
    manejable.
  \end{itemize}
\end{itemize}


\section{Programación de un AL}

\textbf{Dos punteros} de lectura:

\begin{itemize}
\item
  \textbf{Puntero actual}: El último carácter aceptado.
\item
  \textbf{Puntero de búsqueda}: El último carácter leído.
\end{itemize}

\begin{table}[H]
\centering
\begin{tabular}{ccccccccccccccccc}
\hline
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{m} & \multicolumn{1}{c|}{a} & \multicolumn{1}{c|}{t} & \multicolumn{1}{c|}{1} & \multicolumn{1}{c|}{{[}} & \multicolumn{1}{c|}{i} & \multicolumn{1}{c|}{n} & \multicolumn{1}{c|}{d} & \multicolumn{1}{c|}{{]}} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{=} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{3} & \multicolumn{1}{c|}{+} & \multicolumn{1}{c|}{2} & \multicolumn{1}{c|}{} \\ \hline
                       & pA                     &                        &                        & pB                     &                          &                        &                        &                        &                          &                       &                        &                       &                        &                        &                        &                      
\end{tabular}
\caption{Diagrama punteros AL}
\end{table}

\textbf{Funciones de lectura}: GetChar (avanza uno del avanzado y da el
valor), Fail (Mueve el puntero avanzado de vuelta al aceptado),
Retract (mueve el puntero avanzado uno atrás) y Accept (mueve el puntero
actual hasta el avanzado).

\textbf{Primitivas}: IsLetter (letra), IsDigit (número) e IsDelimiter (separadores).

\textbf{Acciones}: InstallName (introduce un nombre en la tabla de
símbolos).


\section{Errores Léxicos}

Hay pocos detectables por el analizador léxico.

\textbf{Detectables, según el diseñador:}

\begin{itemize}

\item
  Número de caracteres de los identificadores.
\item
  Caracteres ilegales.
\item
  Otros, como admitir números sin la parte entera.
\item
  Cadena que no concuerda con ningún token.
\end{itemize}

\textbf{En caso de error:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}

\item
  Anotar el error, indicarlos.
\item
  Recuperarme del error para continuar con el análisis. Ignorar, Borrar,
  Insertar o Corregir.
\item
  Seguir.
\end{enumerate}


\section{Identificación de palabras reservadas}

Mediante \textbf{resolución implícita}, todas identificadas en el
comienzo de la tabla de símbolos, o \textbf{resolución explícita},
usando patrones para las palabras reservadas.


\section{Prioridad de los tokens}

\textbf{Criterio}: Se utilizan heurística para dar prioridad al token
que concuerda con \textbf{el lexema más largo}.

\textbf{En el caso de que arios tokens tengan la misma longitud} se asocia al que
esté \textbf{en primer lugar}.

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Diagrama Prioridad de los tokens}}
	{\includegraphics[scale=.3]{image-20210305191616426.png}
	\includegraphics[scale=.3]{image-20210305191651759.png}}
\end{figure}

\section{AL y Lenguajes de Programación}

El \textbf{AL agrupa caracteres para formar tokens}, por tanto, es
importante definir el ``delimitador''.

\begin{itemize}

\item
  Carácter que \textbf{delimita el token sin pertenecer} a él.
\end{itemize}

Otro concepto importante es el de ``\textbf{palabra reservada}''

\begin{itemize}

\item
  El lenguaje \textbf{prohíbe el uso libre al programador de
  determinadas palabras} que tienen un significado específico y único en
  el lenguaje
\end{itemize}

\textbf{Lenguajes según uso de delimitadores y palabras reservadas:}

\begin{itemize}

\item
  \textbf{Delimitadores blancos; con palabras reservadas}

  \begin{itemize}
  
  \item
    Caso más sencillo de lenguaje (PASCAL, COBOL)
  \end{itemize}
\item
  \textbf{Delimitadores blancos; sin palabras reservadas}

  \begin{itemize}
  
  \item
    PL/I
  \end{itemize}
\item
  \textbf{Blancos se ignoran; sin palabras reservadas}

  \begin{itemize}
  
  \item
    El tipo más difícil de lenguaje, aparecen ambigüedades (FORTRAN)
  \item
    El espacio en blanco se elimina con un preprocesador.
  \item
    El AL tiene que retroceder y comenzar de nuevo.
  \end{itemize}
\end{itemize}

\section{Ejemplo de crear un AL y ASI}

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Ejemplo de crear un AL y ASI I}}
	{\includegraphics[scale=.2]{image-20210305192603381.png}}
\end{figure}

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Ejemplo de crear un AL y ASI II}}
	{\includegraphics[scale=.3]{image-20210305192620642.png}}
\end{figure}

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Ejemplo de crear un AL y ASI III}}
	{\includegraphics[scale=.2]{image-20210305192648153.png}}
\end{figure}

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Ejemplo de crear un AL y ASI IV}}
	{\includegraphics[scale=.25]{image-20210305192718592.png}}
\end{figure}

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Ejemplo de crear un AL y ASI V}}
	{\includegraphics[scale=.3]{image-20210305192731385.png}}
\end{figure}

\chapter{Tema 3: Análisis Sintáctico}


\section{Introducción}

Su función es comprobar que la secuencia de componentes léxicos es una
secuencia del lenguaje y generar el árbol sintáctico (explicito o no)

Los lenguajes de programación que debe reconocer normalmente son
independientes del contexto, por lo que se representan con gramáticas de
tipo 2, diagramas de sintaxis o autómatas a pila.

\textbf{Ventajas de utilizar gramáticas:}

\begin{itemize}

\item
  Son especificaciones sintácticas y precisas de lenguajes.
\item
  Se puede generar automáticamente un analizador.
\item
  Mientras se construye se pueden descubrir inconsistencias,
  ambigüedades,\ldots{}
\item
  Da estructura al lenguaje de programación lo que hace que sea más
  fácil de generar código y detectar errores.
\item
  Fácil de ampliar y modificar el lenguaje.
\end{itemize}

Nos interesan los analizadores deterministas, que son los que de un
estado con un símbolo solo puede ir a 1 estado. También admitiremos las
transiciones con \(\lambda\).

\textbf{Tipos de analizadores:}

\begin{itemize}
\item \textbf{Descendente}: Va desde la raíz (axioma) hasta las hojas
  (tokens, símbolos terminales). Nosotros trataremos los predictivos
  solo, que son capaces de elegir el token correcto en cada momento, no
  los que tienen retroceso.

  \textbf{LL(k)}, LL(1) Tengo que leer k tokens para identificar que
  regla de producción usar.
\item \textbf{Ascendente}: Va de los nodos hojas (secuencia de tokens) hasta
  la raíz (axioma). Es predictivo.

  \textbf{LR(k)}, que puede ser LR(0), SLR(1), LALR(1) y LR(1)
\end{itemize}

LR significa que lee de izquierda a derecha (LX) y elige la producción
más a la derecha (XR, right).

\section{Análisis Sintáctico Descendiente}

Tenemos una secuencia de tokens x y el objetivo es \textbf{determinar si
la secuencia es una secuencia del lenguaje} definido por la gramática G.
El proceso que seguimos es:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}

\item
  \textbf{Partir del axioma} la forma sentencial.
\item
  \textbf{Coger un token de izquierda a derecha.}
\item
  \textbf{Seleccionar una regla de producción}. Se debe saber
  
  \textbf{según el token actual} la regla que usar.
\item
  \textbf{Si coinciden} token y símbolo de la forma sentencial, se
  \textbf{lee el siguiente token}.
\item
  \textbf{Sustituir el símbolo no terminal} de la forma sentencial por
  la parte derecha de la regla elegida.
\item
  \textbf{Repetir} el proceso hasta que la entrada haya sido procesada.
\end{enumerate}


\subsection{Con Retroceso}

Lo que cambia es la manera de seleccionar la regla, este \textbf{lo hace
por búsqueda en profundidad con retroceso} lo que hace que tenga una
\textbf{complejidad de \(O(k^n)\)}.


\subsection{Predictivo}

\textbf{Analizador que solo necesita conocer \(k\) tokens de la cadena
de entrada, para determinar la regla de producción} que debe aplicarse.
El número de tokens, \(k\), necesarios para tomar la decisión de que
regla de producción aplicar, define el nombre del analizador, \(LL(k)\),
\(LR(k)\)

\textbf{Características:}

\begin{itemize}

\item
  Son autómatas a pila deterministas por vaciado.
\item
  No hay retroceso, usa autómatas a pila deterministas predictivos.
\item
  La \textbf{complejidad es lineal} \(O(n)\), tal que n es el número de
  tokens que hay en la sentencia (preferible al exponencial del con
  retroceso)
\end{itemize}

Para evitar problemas a la hora de seleccionar una regla de selección
\textbf{se debe eliminar la Recursividad a izquierdas y Factorizar a
izquierdas}. La recursividad a izquierdas hay que evitarla desde el
principio, pero la factorización si se produce no es un gran problema es
fácil de resolverla.

\begin{multicols}{2}
    \begin{table}[H]
    \centering
    \begin{tabular}{l}
        $S \rightarrow var = E$         \\
        $E \rightarrow O E'$            \\
        $E' \rightarrow \lambda | op E$ \\
        $O \rightarrow var | num$      
    \end{tabular}
    \caption{Gramatica para Análisis Sintáctico}
    \end{table}
    
    \columnbreak
    
    \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
        %uncomment if require: \path (0,203); %set diagram left start at 0, and has height of 203
        
        %Flowchart: Connector [id:dp1982303226214901] 
        \draw   (318,24.5) .. controls (318,16.49) and (324.27,10) .. (332,10) .. controls (339.73,10) and (346,16.49) .. (346,24.5) .. controls (346,32.51) and (339.73,39) .. (332,39) .. controls (324.27,39) and (318,32.51) .. (318,24.5) -- cycle ;
        
        %Straight Lines [id:da8394180713642054] 
        \draw    (332,39) -- (302,69) ;
        %Straight Lines [id:da763913616535143] 
        \draw    (332,39) -- (332,69) ;
        %Straight Lines [id:da46188120699320967] 
        \draw    (332,39) -- (362,69) ;
        %Straight Lines [id:da09823187282004309] 
        \draw    (362,89) -- (332,119) ;
        %Straight Lines [id:da8988050860357433] 
        \draw    (392,119) -- (362,89) ;
        %Straight Lines [id:da006191610664388225] 
        \draw    (332,139) -- (332,159) ;
        %Straight Lines [id:da6073536262668413] 
        \draw    (392,139) -- (392,159) ;
        
        % Text Node
        \draw (326,16) node [anchor=north west][inner sep=0.75pt]   [align=left] {S};
        % Text Node
        \draw (291,70) node [anchor=north west][inner sep=0.75pt]   [align=left] {var};
        % Text Node
        \draw (327,72) node [anchor=north west][inner sep=0.75pt]   [align=left] {=};
        % Text Node
        \draw (356,70) node [anchor=north west][inner sep=0.75pt]   [align=left] {E};
        % Text Node
        \draw (325,121) node [anchor=north west][inner sep=0.75pt]   [align=left] {O};
        % Text Node
        \draw (386,120) node [anchor=north west][inner sep=0.75pt]   [align=left] {E'};
        % Text Node
        \draw (319,161) node [anchor=north west][inner sep=0.75pt]   [align=left] {num};
        % Text Node
        \draw (386,161) node [anchor=north west][inner sep=0.75pt]    {$\lambda $};
    \end{tikzpicture}
    
\end{multicols}

$$S \rightarrow var = E \rightarrow var = O E'\rightarrow var = num E' \rightarrow var = num$$


En los casos que se tienen varias reglas de producción entre las que
elegir usará el conjunto primero del terminar más a la izquierda.


\subsubsection{Conjunto Primero}

\(PRIMERO(\alpha)\) Todos los Terminales que aparecen más a la izquierda
que se derivan de esa forma sentencial. \textbf{Son los posibles
terminales que pueden aparecer más a la izquierda de cualquier secuencia
de producciones de \(\alpha\).} 
\begin{figure}[H]
  $PRIMERO(\alpha)=\{ x | (\alpha \rightarrow _* x \cdot \beta), (x \in \Sigma_T \cup \Sigma^*)\}$

  \captionsetup{justification=centering}
  \caption{Conjunto Primero}
\end{figure}
Si \(X=\lambda \Rightarrow PRIMERO(X)=\{\lambda\}\)

Si \(X \in \Sigma_T \Rightarrow PRIMERO(X)=\{X\}\) El conjunto primero
de un terminal es él mismo.

Si X tiene alguna regla que empieza por un No Terminal es como calcular
el conjunto primero de este. Ojo con lambda.


\subsubsection{Conjunto Siguiente}

Conjunto primero de todo lo que aparece concatenado de un símbolo No
terminal en todas las formas senténciales que se derivan del axioma. Son
todos los símbolos Terminales que se producen al derivar desde el
axioma.

El conjunto siguiente nunca va a contener a \(\lambda\). \$ es el token
que indica fin de sentencia.

Se aplica sobre los No Terminales de la parte de la derecha de todas las
producciones. 
\begin{figure}[H]
  $SIGUIENTE(A)=\{ x | (S \rightarrow _*\alpha A \beta), (A \in \Sigma_N), (\alpha \in \Sigma^*), (\beta \in \Sigma^+),(x\in PRIMERO(\beta)-\{\lambda\})\}$

  \captionsetup{justification=centering}
  \caption{Conjunto Siguiente}
\end{figure}
Fases:

\begin{itemize}

\item
  Obtener las reglas de formación de los conjuntos siguientes. Se aplica
  sobre todos los NT de la derecha de la regla de producción. Tiene la
  forma de \(A \rightarrow \alpha B \beta\), se asocian las partes de la
  regla con los símbolos, donde B es el NT sobre del que queremos el
  S(B).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  El conjunto siguiente del axioma es \$ siempre, pero hay que aplicar
  el conjunto siguiente sobre sus reglas.
\item
  Se aplica \(S(B)=S(B)\cup PRIMERO(\beta)-\{\lambda\}\), que si no hay
  \(\beta\) hace que esta regla no haga nada y se haga la siguiente.
\item
  Si \(PRIMERO(\beta)\) contiene a \(\lambda\) también se aplica,
  \(S(B)=S(B)\cup S(A)\)
\end{enumerate}


\item
  Ir aplicando las reglas, escribiendo los T en una tabla, hasta que el
  conjunto siguiente no cambie en una iteración.
\end{itemize}

\subsubsection{Conjunto de Predicción}

Es el criterio para determinar que regla expandir para un símbolo no
terminal, y se aplica sobre las reglas de producción completa.

Dado \(A \rightarrow \alpha\):

\begin{figure}[H]
 \begin{eqnarray*}
    PREDICCION(A \rightarrow \alpha) &=& PRIMERO(\alpha) / \lambda \notin PRIMERO(\alpha) \\
    PREDICCION(A \rightarrow \alpha) &=& [PRIMERO(\alpha)-\{\lambda\}] \cup S(A) / \lambda \in PRIMERO(\alpha)
 \end{eqnarray*}

  \captionsetup{justification=centering}
  \caption{Conjunto de Predicción}
\end{figure}

\pagebreak
\subsubsection{Condiciones LL}

Condiciones que debe tener para hacer Análisis Sintáctico Descendente
Predictivo.
Estas condiciones se aplican sobre NT que tienen más de una regla de
producción.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}

\item
  \textbf{Condición PRIMERO-PRIMERO:} Los conjuntos primeros de las
  reglas de producción del NT deben ser disjuntos (no tengan símbolos en
  común).

  \(A \rightarrow \alpha_1 |...|\alpha_n, P(\alpha_1) \cap ... \cap P(\alpha_n) = \empty\)
\item
  \textbf{Condición PRIMERO-SIGUIENTE}: Esta se aplica cuando alguna de
  las reglas tienen en su conjunto primero \(\lambda\), entonces el
  conjunto primero del resto de las reglas (sin incluir la de lambda)
  deben ser disjuntos con el conjunto siguiente del NT de la izquierda.
\end{enumerate}


\subsubsection{Análisis Descendente Recursivo}


\paragraph{Estrategia}

Para construirlo se crea un procedimiento por cada NT que sea capaz de
reconocer las distintas reglas de producción que tiene asociadas, para
ello va leyendo símbolo a símbolo con token\_actual, siguiendo las
siguientes reglas:

\begin{itemize}

\item
\textbf{Si se lee un Terminal}: Si coincide el token\_actual con lo esperado
  lee el siguiente token, si no coincide da error sintáctico.
\item
\textbf{Si se lee un NT}: Se llama al procedimiento del NT que se encargara de
  reconocerlo.
\item
\textbf{Si se lee una lambda}: No se hace nada.
\end{itemize}

Si la pila se vacía y la entrada ha sido procesada entonces la secuencia
de tokens es reconocida, entonces iría al analizador semántico.


\paragraph{Ventajas}

\begin{itemize}

\item
  Requieren formalizar una gramática.
\item
  Son fáciles de escribir e interpretar.
\item
  Adecuados para analizadores simples.
\end{itemize}


\paragraph{Inconvenientes}

\begin{itemize}

\item
  Difíciles de ampliar y mantener.
\item
  Coste computacional asociado a la recursividad.
\item
  Construcción específica para el lenguaje reconocido.
\item
  Conjunto reducido de lenguajes independientes de contexto.
\end{itemize}
 
\pagebreak

\subsubsection{Ejemplo:}

\begin{table}[H]
\centering
\begin{tabular}{l|c}
                          & \textbf{Predicción}  \\ \hline
$S \rightarrow A S'$      & $\{ id \}$           \\ \hline
$S' \rightarrow S$        & $\{ id \}$           \\ \hline
$S' \rightarrow \lambda$  & $\{ \$ \}$           \\ \hline
$A\rightarrow id = E$     & $\{ id \}$           \\ \hline
$E \rightarrow O E'$      & $\{ num, id, fun \}$ \\ \hline
$E' \rightarrow op E$     & $\{ op \}$           \\ \hline
$E' \rightarrow \lambda$  & $\{ id, \$, )\}$     \\ \hline
$O \rightarrow num$       & $\{ num \}$          \\ \hline
$O \rightarrow id$        & $\{ id \}$           \\ \hline
$O \rightarrow fun ( E )$ & $\{ fun \}$          \\ \hline
\end{tabular}
\caption{Descendente Recursivo: Gramática y Procedimiento Axioma}
\end{table}

\begin{lstlisting}[language=C]
main {
  $ al final de la entrada
  leer_tok()
  S()
  si tok_act = "$"
    ACEPTAR
  sino
    ERROR
}
\end{lstlisting}
\begin{lstlisting}[language=C]
S {
  A()
  S'()
}
\end{lstlisting}
\begin{lstlisting}[language=C]
S' {
  si tok_act = "id"
    S()
  sino
    si tok_act = "$"
    sino
      ERROR 
}
\end{lstlisting}
\pagebreak
\begin{lstlisting}[language=C]
A {
  si tok_act = "id"
    leer_tok()
    si tok_act = "="
      leer_tok()
      E()
    sino
      ERROR
  sino
    ERROR
}
\end{lstlisting}
\begin{lstlisting}[language=C]
E {
  O()
  E'()
}
\end{lstlisting}
\begin{lstlisting}[language=C]
E' {
  si tok_act = "op"
    leer_tok()
    E()
  sino
    si tok_act = "id" | "$" | ")"
    sino
      ERROR
}
\end{lstlisting}
\begin{lstlisting}[language=C]
O {
  si tok_act = "num"
    leer_tok()
  sino
    si tok_act = "id"
      leer_tok()
    sino
      si tok_act = "fun"
        leer_tok()
        si tok_act = "("
          leer_tok()
          E()
          si tok_act() = ")"
            leer_tok()
          sino
            ERROR
        sino
          ERROR
}
\end{lstlisting}

\begin{table}[H]
\centering
\begin{tabular}{r|l}
id = fun ( num op id ) \$ & S                 \\
= fun ( num op id ) \$    & A S               \\
fun ( num op id ) \$      & E A S             \\
( num op id ) \$          & O E A S           \\
num op id ) \$            & E O E A S         \\
op id ) \$                & O E O E A S       \\
op id ) \$                & E O E A S         \\
id ) \$                   & E' E O E A S      \\
id ) \$                   & E E' E O E A S    \\
) \$                      & O E E' E O E A S  \\
) \$                      & E E' E O E A S    \\
) \$                      & E' E E'E O E A S  \\
) \$                      & E E'E O E A S     \\
) \$                      & E' E E' E O E A S \\
) \$                      & E E' E O E A S    \\
\$                        & O E A S           \\
\$                        & E A S             \\
\$                        & S                 \\
\$                        & S' S              \\
\$                        & S                 \\
                          & ACEPTAR          
\end{tabular}
\caption{Descendente Recursivo: Reconocimiento secuencia}
\end{table}

\pagebreak

\subsubsection{Análisis Sintáctico LL(1)}

Es un analizador predictivo que procesa los tokens de izquierda a
derecha, con derivaciones más a la izquierda.

Necesita solo 1 símbolo de preanálisis para determinar qué producción
aplicar.


\subsubsection{Análisis Descendente Dirigido por tablas}

Características:

\begin{itemize}

\item
  Se construye en árbol de derivación desde el axioma.
\item
  La cima de la pila determina la operación a realizar.
\item
  La sustitución de los símbolos no terminales por producciones está
  definida en una tabla, en la que las filas son los NT y las columnas
  los T.
\item
  Debe cumplir las condiciones LL para analizarse con LL(1)
\end{itemize}

Construcción de la tabla: Se construye con el Conjunto de Predicción,
filas NT y columnas Terminales y \$.

\begin{itemize}

\item
  Dentro se ponen las reglas de producción, que se ponen en la fila del
  NT de la izquierda de la regla y en las columnas de todos los T del
  conjunto de predicción de la regla.
\end{itemize}

La idea general es:

\begin{itemize}

\item
  Si el símbolo de preanálisis y la cima de la pila son \$ es que hemos
  terminado con éxito.
\item
  Si el símbolo de preanálisis es en un T y la cima de pila es el mismo,
  pero no \$ (sería final), se saca de la pila y se lee token (lo que lo
  saca de la secuencia a reconocer)
\item
  Si el símbolo de cima de pila es un NT, se consulta la fila del NT y
  la columna del símbolo de preanálisis, si esta está vacía, error, sino
  se meta en la cima de la pila.
\end{itemize}

\pagebreak

\subsubsection{Ejemplo completo}

\begin{table}[H]
  \begin{tabular}{ll}
  $S \rightarrow A S'$      & $E' \rightarrow op E$     \\ 
  $S' \rightarrow S$        & $E' \rightarrow \lambda$  \\ 
  $S' \rightarrow \lambda$  & $O \rightarrow num$       \\ 
  $A\rightarrow id = E$     & $O \rightarrow id$        \\ 
  $E \rightarrow O E'$      & $O \rightarrow fun ( E )$ \\ 
  \end{tabular}
\caption{Gramatica ejemplo}
\end{table}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}

\item
  Calcular Conjuntos Primeros.

\begin{table}[H]
    \centering
    \begin{tabular}{c|c|}
    \textbf{}   & \textbf{Primero}        \\ \hline
    \textbf{S}  & $\{ id \}$              \\ \hline
    \textbf{S'} & $\{ id, \lambda \}$     \\ \hline
    \textbf{A}  & $\{ id \}$              \\ \hline
    \textbf{E}  & $\{ num, id, fun \}$    \\ \hline
    \textbf{E'} & $\{ op, \lambda \}$     \\ \hline
    \textbf{O}  & $\{ num, id, fun \}$    \\ \hline
    \end{tabular}
    \caption{Ejem. Conjuntos Primeros}
\end{table}

\item
  Calcular Conjuntos Siguientes.

\begin{multicols}{2}

\begin{table}[H]
    \centering
    \begin{tabular}{c|c|c|}
    \textbf{}   & \textbf{Siguiente} \\ \hline
    \textbf{S}  & $\{ \$ \}$         \\ \hline
    \textbf{S'} & $\{ \$ \}$         \\ \hline
    \textbf{A}  & $\{ id, \$ \}$     \\ \hline
    \textbf{E}  & $\{ id, \$, ) \}$  \\ \hline
    \textbf{E'} & $\{ id, \$, ) \}$  \\ \hline
    \textbf{O}  & $\{ op, id, \$ \}$ \\ \hline
    \end{tabular}
    \caption{Ejem. Conjuntos Siguientes}
\end{table}

\begin{align*}
  &A \rightarrow \alpha B \beta\\
  &\textit{1) } S(B) = S(B) \cup P(\beta) - \{ \lambda\} \\
  &\textit{2) Si } \lambda \in P(\beta) \Rightarrow \\
  &S(B) = S(B) \cup S(A)
\end{align*}

\columnbreak
\begin{table}[H]
    \centering
    \begin{tabular}{l}
    $\boldsymbol{S \rightarrow A S'}$        \\
    $S(A) = S(A) \cup P(S') - \{ \lambda\}$  \\
    $S(A) = S(A) \cup S(S)$                  \\
    $S(S') = S(S') \cup S(S)$                \\
    $\boldsymbol{S' \rightarrow S}$          \\
    $S(S) = S(S) \cup S(S')$                 \\
    $\boldsymbol{A\rightarrow id = E}$       \\
    $S(E) = S(E) \cup S(A)$                  \\
    $\boldsymbol{E \rightarrow O E'}$        \\
    $S(O) = S(O) \cup P(E') - \{ \lambda\}$  \\
    $S(O) = S(O) \cup S(E)$                  \\
    $S(E') = S(E') \cup S(E)$                \\
    $\boldsymbol{E' \rightarrow op E}$       \\
    $S(E) = S(E) \cup S(E')$                 \\
    $\boldsymbol{O \rightarrow fun ( E )}$   \\
    $S(E) = S(E) \cup P(")") - \{ \lambda\}$
    \end{tabular}
\end{table}
\end{multicols}
\pagebreak
\item
  Calcular Conjuntos de Predicción.

  \begin{multicols}{2}
\begin{table}[H]
\centering
\begin{tabular}{l|c}
                          & \textbf{Predicción}  \\ \hline
$S \rightarrow A S'$      & $\{ id \}$           \\ \hline
$S' \rightarrow S$        & $\{ id \}$           \\ \hline
$S' \rightarrow \lambda$  & $\{ \$ \}$           \\ \hline
$A\rightarrow id = E$     & $\{ id \}$           \\ \hline
$E \rightarrow O E'$      & $\{ num, id, fun \}$ \\ \hline
$E' \rightarrow op E$     & $\{ op \}$           \\ \hline
$E' \rightarrow \lambda$  & $\{ id, \$, )\}$     \\ \hline
$O \rightarrow num$       & $\{ num \}$          \\ \hline
$O \rightarrow id$        & $\{ id \}$           \\ \hline
$O \rightarrow fun ( E )$ & $\{ fun \}$          \\ \hline
\end{tabular}
\caption{Ejem. Conjuntos de Predicción}
\end{table}
\columnbreak
\begin{align*}
  &A \rightarrow \alpha \\
  &\textit{Si } \lambda \notin P(\alpha) \Rightarrow \textit{Pred} = P(\alpha) \\
  &\textit{Si } \lambda \in P(\alpha) \Rightarrow \textit{Pred} = P(\alpha) - \{\alpha\} \cup S(A)
\end{align*}
\end{multicols}

\item Comprobación de las Condiciones de LL(1)

Condiciones de LL(1)
$$\left. PP
\begin{matrix}
S' 
\begin{cases}
S' \rightarrow S & \{ id \} \\
S' \rightarrow \lambda & \{ \lambda \}
\end{cases} \\ 
E' 
\begin{cases}
E' \rightarrow op E & \{ op \} \\
E' \rightarrow \lambda & \{ \lambda \}
\end{cases} 
\end{matrix}
\right|
PS
\begin{matrix}
S' 
\begin{cases}
S' \rightarrow S & \{ id \} \\
S' \rightarrow \lambda & \{ \$ \}
\end{cases} \\ 
E' 
\begin{cases}
E' \rightarrow op E & \{ op \} \\
E' \rightarrow \lambda & \{ id, \$, ) \}
\end{cases}  
\end{matrix}
$$

\item
  Tabla de Conjuntos de Predicción

\begin{table}[H]
  \centering
  \begin{tabular}{c|c|c|c|c|c|c|c|c|}
              & \textbf{id} & \textbf{=} & \textbf{op} & \textbf{num} & \textbf{fun} & \textbf{(} & \textbf{)} & \textbf{\$} \\ \hline
  \textbf{S}  & 1           &            &             &              &              &            &            &             \\ \hline
  \textbf{S'} & 2           &            &             &              &              &            &            & 3           \\ \hline
  \textbf{A}  & 4           &            &             &              &              &            &            &             \\ \hline
  \textbf{E}  & 5           &            &             & 5            & 5            &            &            &             \\ \hline
  \textbf{E'} & 7           &            & 6           &              &              &            & 7          & 7           \\ \hline
  \textbf{O}  & 9           &            &             & 8            & 10           &            &            &             \\ \hline
  \end{tabular}
  \caption{Ejem. Tabla de Conjuntos de Predicción}
  \end{table}
\pagebreak
\item
  Prueba de lectura de secuencia de entrada (falta que se vaya) y los
  NT que quedan se van con el \$)

\begin{table}[H]
    \centering
    \begin{tabular}{r|l}
    id = fun ( num op id ) \$ & S \$               \\
    id = fun ( num op id ) \$ & A S' \$            \\
    id = fun ( num op id ) \$ & id = E S' \$       \\
    = fun ( num op id ) \$    & = E S' \$          \\
    fun ( num op id ) \$      & E S' \$            \\
    fun ( num op id ) \$      & O E' S' \$         \\
    fun ( num op id ) \$      & fun ( E ) E' S' \$ \\
    ( num op id ) \$          & ( E ) E' S' \$     \\
    num op id ) \$            & E ) E' S' \$       \\
    num op id ) \$            & O E' ) E' S' \$    \\
    num op id ) \$            & num E' ) E' S' \$  \\
    op id ) \$                & E' ) E' S' \$      \\
    op id ) \$                & op E ) E' S' \$    \\
    id ) \$                   & E ) E' S' \$       \\
    id ) \$                   & O E' ) E' S' \$    \\
    id ) \$                   & id E' ) E' S' \$   \\
    ) \$                      & E' ) E' S' \$      \\
    ) \$                      & ) E' S' \$         \\
    \$                        & E' S' \$           \\
    \$                        & S' \$              \\
    \$                        & \$
    \end{tabular}
    \caption{Prueba de lectura de secuencias ASI}
  \end{table}
  
\end{enumerate}
\pagebreak
\section{Análisis Sintáctico Ascendente}

Una secuencia de tokens x pertenece al lenguaje definido por G si genera una secuencia válida del lenguaje. Se van aplicando reglas de producción que generan un árbol sintáctico.

\begin{enumerate}
  \item Coger tokens de izquierda a derecha.
  \item Buscar el pivote de reducción (que reduciremos)
  \item Aplicar derivaciones más a la derecha, sustituyen por NT.
  \item Repetir el proceso hasta que la entrada ha sido procesada y reducida al axioma.
\end{enumerate}

\textbf{Pivote de reducción:} Subcadena w de una forma sentencial x, $x \in \sum^+$, que es la parte derecha de una regla de producción y se sustituye a la inversa, es decir se mete el NT del lado izquierdo. 

La decisión es si añadir otro terminal al pivote (desplazar) o aplicar la producción en orden inverso.
\begin{itemize}
  \item $x=uwv, A \rightarrow w | S \rightarrow uAv$
  \item Reduce el pivote más a la izquierda.
  \item A la derecha del pivote solo hay terminales o $\lambda$.
  \item El pivote se puede buscar utilizando una pila.
\end{itemize}

\subsection{Prefijo} 
Terminales y No Terminales que se pueden encontrar en pila, que nos permite llegar al axioma.

\subsection{Prefijo viable} 
Terminales y No Terminales que pueden encontrarse en la pila y pueden formar parte de un pivote que permita reducir hasta el axioma. 

Un prefijo de un prefijo viable también es un prefijo viable.

La estrategia es construir un autómata que reconozca los prefijos viables de la gramática, el autómata LR(0) los reconoce.
\vspace{-10px}
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Prefijos viables}}
	{\includegraphics[scale=.4]{2021-03-26 18_27_20-ASintactico.pdf - Foxit Reader.png}}
\end{figure}
  
\subsection{Análisis LR}
Para algunas gramáticas independientes de contexto, LR(k), se puede construir un autómata a pila determinista.

\begin{itemize}
  \item k es la cantidad de símbolos de preanálisis necesarios para tomar una decisión.
\end{itemize}

Tipos de analizadores:
\begin{itemize}
  \item \textbf{SLR(1)} es un LR simple. La clase más pequeña de gramáticas, número de estados más pequeño, simple y rápida.
  \item \textbf{LR(1)}. La clase más grande de gramáticas, el mayor número de estados, construcción larga y penosa.
  \item \textbf{LALR(1)}. La clase intermedia de gramáticas, número de estados como SLR(1), construcción larga y penosa.
\end{itemize}
En cuanto a que gramáticas pueden representas: $G2>LR>LALR>SLR$

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Comparación de grámaticas}}
	{\includegraphics[scale=.57]{2021-04-13 15_35_24-ASintactico.pdf - Foxit Reader.png}}
\end{figure}

\subsection{Análisis Sintáctico LR(1)}

\subsubsection{Esquema del Análisis Ascendente dirigido por tabla}
En este caso las filas son el Conjunto LR(0), también llamado \textbf{conjunto LR canónico}, que son todos los estados resultados de hacer el cierre del axioma y los sucesivos Ir$\_$a.

Las columnas son \textbf{Acciones}, Terminales y \$, y por otro lado \textbf{Ir$\_$a}, No Terminales.

\subsubsection{Item LR(0)}

Son reglas de producción con $\cdot$, que indica que lo de la izquierda está en la pila.
\begin{itemize}
  \item $A \rightarrow \alpha \beta \cdot \gamma$, $\alpha,\beta$ en pila.
  \item Los símbolos a la derecha todavía no se han procesado. $\gamma$ sin procesar.
  \item Cuando se produce que a la derecha de $\cdot$ no hay símbolos es posible que haya encontrado un pivote de reducción.
\end{itemize}

\subsubsection{Analizador LR(0)}
A partir de los ítems se puede construir un AFD que realice el análisis de prefijos viables.

Los estados de ese AFD se les llama \textbf{Conjunto canónico LR(0)}, que es lo que buscamos para la tabla, cada uno de esos estados está formado por un conjunto de ítems.

Cuando el axioma tenga varias producciones, se amplía la gramática, haciendo que un nuevo NT sea el axioma y produzca el axioma anterior. $S'\rightarrow S$

\textbf{Para crear los estados del Conjunto canónico LR(0) utilizaremos:}
\begin{itemize}
  \item \textbf{Cierre(ítems)} Determina los ítems que pertenecen a un estado. 
  
  Lo que hace es añadir a todas las reglas de producción del NT izquierdo, el punto $\cdot$ a la izquierda. Además, si el punto está justo a la izquierda de un NT se hace también para sus reglas. 
  
  \item \textbf{Ir$\_$a(ítems, Símbolo)} Genera un nuevo estado a partir de los ítems de un estado y símbolo gramaticales.
  
  Hace el cierre de pasar el punto al otro lado de Símbolo, que se pasa como parámetro. Es vacío cuando no hay ningún item que tenga el punto a su izquierda.
\end{itemize}
\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Cierre(ítems) e Ir$\_$a(ítems, Símbolo)}}
  {\includegraphics[scale=.4]{2021-03-26 19_10_20-ASintactico.pdf - Foxit Reader.png}
  \includegraphics[scale=.4]{2021-03-26 19_14_19-ASintactico.pdf - Foxit Reader.png}}
\end{figure}

El analizador LR(0) es un Autómata a Pila Determinista, los estados del analizador son conjuntos de ítems.

\textbf{Algoritmo de creación del analizador LR(0)}
\begin{enumerate}
  \item Crear el conjunto canónico LR(0)
  \begin{enumerate}
    \item Ampliar la gramática $S'\rightarrow S$, cuando axioma tiene más de una regla.
    \item $E_0 = Cierre(S'\rightarrow S)$.
    \item Repetir mientras son creados nuevos estados, $E_i = Ir\_a(I_k, \alpha), \forall \alpha \in \sum^+$, hacer para aquellos símbolos que estén a la derecha de un punto, si no darán vacío y no nos son de utilidad. Que crea tantos estados como posibles aplicaciones de la función Ir$\_$a en todos los estados, mientras no genere estados exactamente iguales, pero puede haber reglas repetidas.
  \end{enumerate}
  \item Asociar acciones a los ítems de los estados, que son: Desplazar, Reducir, Ir a otro estado, Aceptar y Error.
\end{enumerate}

Ejemplo: 
\begin{table}[H]
  \centering
  \begin{tabular}{l}
  $S' \rightarrow S$     \\
  $S \rightarrow T$      \\
  $S \rightarrow S \textit{op} T$ \\
  $T \rightarrow \textit{num}$    \\
  $T \rightarrow ( S )$ 
  \end{tabular}
  \end{table}
  
  \begin{enumerate}
  \item Ampliamos: $S' \rightarrow S$
  \begin{table}[H]
    \centering
    \begin{tabular}{l}
    $S' \rightarrow S$     \\
    $S' \rightarrow S$     \\
    $S \rightarrow T$      \\
    $S \rightarrow S \textit{op} T$ \\
    $T \rightarrow \textit{num}$    \\
    $T \rightarrow ( S )$ 
    \end{tabular}
    \end{table}
  \item Hacer el cierre de la ampliación del axioma
  \begin{flalign*}
          E_0:& S' \rightarrow \cdot S \\
          &S \rightarrow \cdot T \\
          &S \rightarrow \cdot S \textit{op} T \\
          &T \cdot \rightarrow \textit{num} \\
          &T \cdot \rightarrow ( S ) \\
        \end{flalign*}
  \item Hacer Ir\_a para $\Sigma = \{S, T, \textit{op}, \textit{num}, (, )\}$, no hace falta hacer todos, solo tiene sentido para aquellos que tienen un punto a la izquierda. Un estado por cada Ir\_a que se puede hacer desde $E_0$
  \begin{multicols}{2}
  \begin{flalign*}
          E_1:& S' \rightarrow S \cdot \\
          &S \rightarrow S \cdot \textit{op} T \\
          E_2:& S \rightarrow T \cdot \\
          E_3:& T \rightarrow \textit{num} \cdot \\
          E_4:& T \rightarrow ( \cdot S ) \\
          &S \rightarrow \cdot T \\
          &S \rightarrow \cdot S \textit{op} T \\
          &T \rightarrow \cdot \textit{num} \\
          &T \rightarrow \cdot ( S ) \\
  \end{flalign*}
  \columnbreak
  
  \begin{flalign*}
          E_5:& S \rightarrow S \textit{op} \cdot T \\
          &T \rightarrow \cdot \textit{num} \\
          &T \rightarrow \cdot ( S ) \\
          E_6:& T \rightarrow  ( S \cdot ) \\
          &S \rightarrow S \cdot \textit{op} T \\
          E_7:& S \rightarrow S \textit{op} T \cdot \\
          E_8:& T \rightarrow  ( S ) \cdot \\
  \end{flalign*}
  \end{multicols}
  
  \end{enumerate}

\textbf{Asociar acciones a los ítems de los estados:}
\begin{itemize}
  \item $\forall I_k = \{ A \rightarrow \alpha \cdot x \beta\} I_k \in E_j \space y \space x\in \sum_T, Accion(E_j, x)=Desplazar E_n, E_n = Ir\_a(E_j,x)$
  \item $\forall I_k = \{ A \rightarrow \alpha \cdot X \beta\} I_k \in E_j \space y \space X\in \sum_N, Ir\_a(E_j,X) = E_n$
  \item $\forall I_k = \{ A \rightarrow \alpha \cdot \} I_k \in E_j, Accion(E_j, x)= Reducir A \rightarrow \alpha, \forall x \in \{ \sum_T, \$ \}$
  \item $I_k = \{ S' \rightarrow S \cdot \} I_k \in E_j, Accion(E_j, \$)= Aceptar$
\end{itemize}

Ejemplo: 

\begin{table}[H]
  \centering
  \begin{tabular}{c|c|c|c|c|c|c|c|c|}
  \cline{2-9}
  \multirow{2}{*}{}                & \multirow{2}{*}{\textbf{Acción}} & \multicolumn{5}{c|}{\textbf{Entrada}}                              & \multicolumn{2}{c|}{\textbf{Ir\_a}} \\ \cline{3-9} 
                                   &                                  & \textbf{(} & \textbf{num} & \textbf{)} & \textbf{op} & \textbf{\$} & \textbf{S}       & \textbf{T}       \\ \hline
  \multicolumn{1}{|c|}{\textbf{0}} & Desplazar                        & 4          & 3            &            &             &             & 1                & 2                \\ \hline
  \multicolumn{1}{|c|}{\textbf{1}} & Desplazar                        &            &              &            & 5           & ACP         &                  &                  \\ \hline
  \multicolumn{1}{|c|}{\textbf{2}} & Reducir                          & \multicolumn{5}{c|}{$S \rightarrow T$}                             &                  &                  \\ \hline
  \multicolumn{1}{|c|}{\textbf{3}} & Reducir                          & \multicolumn{5}{c|}{$T \rightarrow ( S )$}                         &                  &                  \\ \hline
  \multicolumn{1}{|c|}{\textbf{4}} & Desplazar                        & 4          & 3            &            &             &             & 6                & 2                \\ \hline
  \multicolumn{1}{|c|}{\textbf{5}} & Desplazar                        & 4          & 3            &            &             &             &                  & 7                \\ \hline
  \multicolumn{1}{|c|}{\textbf{6}} & Desplazar                        &            &              &            &             &             &                  &                  \\ \hline
  \multicolumn{1}{|c|}{\textbf{7}} & Reducir                          & \multicolumn{5}{c|}{$S \rightarrow S \textit{op} T$}               &                  &                  \\ \hline
  \multicolumn{1}{|c|}{\textbf{8}} & Reducir                          & \multicolumn{5}{c|}{$T \rightarrow ( S )$}                         &                  &                  \\ \hline
  \end{tabular}
  \caption{Analizador LR(0)}
  \end{table}

LR(0) toma la decisión de desplazar o reducir SIN depender del token de entrada, solo del estado, pero si del estado al que transita.

Se puede producir \textbf{Conflicto de Reducción-Desplazamiento}, cuando para un mismo estado y símbolo hay dos acciones.
Para solventar esto se amplía el LR(0) a SLR(1)

\textbf{Ventajas}
\begin{itemize}
  \item Fáciles de construir.
  \item Las reducciones están asociadas a estados.
\end{itemize}

\textbf{Inconvenientes}
\begin{enumerate}
  \item Son muy pocas las que se pueden utilizar.
  \item Estrategias de recuperación de error.
\end{enumerate}

\subsection{Análisis SLR(1)}
Es un Autómata a Pila Determinista.
\begin{itemize}
  \item Los estados del analizador son conjuntos de ítems.
\end{itemize}

Se construye igual que el analizar LR(0), pero la asignación de la acción Reducir cambia.

\textbf{Algoritmo de creación del analizador SLR(1)}
\begin{itemize}
  \item Crear el conjunto canónico LR(0), los estados.
  \item Asociar acciones (Desplazar, Reducir, Ir\_a, Aceptar, Error) a los ítems de los estados.
\end{itemize}

\textbf{Asociar acciones a los ítems de los estados:}
\begin{itemize}
  \item $\forall I_k = \{ A \rightarrow \alpha \cdot x \beta\} I_k \in E_j \space y \space x\in \sum_T, Accion(E_j, x)=Desplazar E_n, E_n = Ir\_a(E_j,x)$
  \item $\forall I_k = \{ A \rightarrow \alpha \cdot X \beta\} I_k \in E_j \space y \space X\in \sum_N, Ir\_a(E_j,X) = E_n$
  \item $\forall I_k = \{ A \rightarrow \alpha \cdot \} I_k \in E_j, Accion(E_j, x)= Reducir A \rightarrow \alpha, \forall x \in Siguiente(A), \alpha \in \sum ^*$ Se pone reducción solo para los T de $S(A)$
  \item $I_k = \{ S' \rightarrow S \cdot \} I_k \in E_j, Accion(E_j, \$)= Aceptar$
\end{itemize}

Cuando se indica R2, indica que la regla que se reduce es la numerada como 2.

\textbf{Condiciones SLR(1):}
Tienen que cumplirse dos condiciones para poder hace un análisis SLR(1). 

No es necesario eliminar la recursividad a derechas e izquierda y ni es necesario factorizar.

\begin{itemize}
  \item Sin conflictos \textbf{Desplazamiento-Reducción}, debe darse que en los estados que haya reducciones no haya otro item que tenga desplazar para un símbolo del conjunto siguiente de la reducción.
  
  $A \rightarrow \alpha \cdot x \beta$

  $B \rightarrow \alpha \cdot$

  Entonces $x \notin Siguiente(B)$

  \item Sin conflictos \textbf{Reducción-Reducción}, debe cumplir que cuando haya más de una regla de reducción en un estado, sus conjuntos siguientes sean disjuntos.
    
  $A \rightarrow \alpha \cdot $

  $B \rightarrow \gamma \cdot$

  Entonces $Siguiente(A) \cap Siguiente(B)$
\end{itemize}

\includepdf[pages=78]{docs/ASintactico.pdf}

\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Ejemplo analizador SLR(1)}}
  {\includegraphics[scale=.5]{2021-04-13 14_59_35-ASintactico.pdf - Foxit Reader.png}}
\end{figure}

\subsection{Comparación LL vs LR}
\textbf{Simplicidad:} LL es más fácil de construir y completar.

\textbf{Tamaño:} LL es más pequeño.

\textbf{Generalidad:} Todas las LL son LR, pero no al contrario.

\textbf{Detección de error:} LR requiere menos acciones para detectar el error.

\textbf{Recuperación de errores:} LL es más sencillo de implementar.

\chapter{Tema 4: Tratamiento de Ambiguedad y Error}
\includepdf[pages=-]{docs/04_TErrores.pdf}

\chapter{Tema 5: Análisis Semántico}

\section{Introducción}
El análisis semántico es una \textbf{extensión del análisis sintáctico para la compresión del programa}, para comprobar que tiene sentido y que está conectado. Destaca por la verificación de tipos.

Es un paso \textbf{previo a su traducción, aunque hay partes que se pueden ir haciendo}. También modifica la tabla de símbolos.

Las gramáticas independientes del contexto \textbf{(G2) no son suficientes para este análisis}, se necesita realizar comprobaciones de larga distancia en el árbol sintáctico (que no se pueden representar con reglas de producción) y no solo comprobar que se deriva de la gramática del lenguaje.

Para cumplir lo anterior se utilizan Gramáticas de atributos (gramáticas atribuidas), que son más ricas.

\textbf{Algunas de las comprobaciones que se realizan durante el Análisis Semántico:}
\begin{itemize}
  \item Comprobación de \textbf{tipos}, los operadores y operandos deben ser compatibles.
  \item Comprobaciones de \textbf{unicidad}, en aquellas situaciones en las que un objeto solo puede definirse una vez exclusivamente.
  \item Comprobaciones \textbf{relacionadas con nombres}, cuando el mismo nombre debe aparecer dos o más veces.
  \item Comprobación del \textbf{flujo de control}, controlar las proposiciones para abandonar el flujo de control, que tiene finalización.
\end{itemize}
\pagebreak
\section{Gramáticas atribuidas}
Son gramáticas G2 a las que se añaden atributos y reglas de evaluación de atributos (reglas semánticas).
\begin{itemize}
  \item Cada \textbf{atributo} es una variable que representa una propiedad del símbolo terminal o no terminal, puede ser una cadena, número, tipo, posición de memoria, etc.
  \item \textbf{Reglas semánticas} (Reglas para calcular/Reglas para comprobar), se asocian a las producciones sintácticas (reglas de producción). Se definen en función de los atributos de los símbolos en la producción.
  \item Sobre los atributos y reglas hay unas \textbf{condiciones semánticas}.
\end{itemize}

Se pueden construir Árboles adornados o decorados, donde se muestra la relación entre atributos de una misma regla de producción.

\textbf{Gramáticas atribuida $GA=\{G,A,R,B\}$}
\begin{itemize}
  \item G - \textbf{Gramática} libre de contexto (G2), $G = \{\Sigma_N, \Sigma_T, S, P\}$.
  \item A - Conjunto de \textbf{atributos} asociados a cada símbolo X. Son disjuntos.
  \item R - \textbf{Reglas semánticas} asociadas a cada regla en P.
  \item B - \textbf{Condiciones} asociadas a cada regla de P.
\end{itemize}

\textbf{Existen diferentes Especificaciones:}
\begin{itemize}
  \item \textbf{DDS - Definición dirigida por la sintaxis}, acciones tras cada producción (sin orden específico).
  
  \begin{figure}[H]
    \ffigbox[\FBwidth]
    {\caption{Ejemplo DDS}}
    {\includegraphics[scale=.3]{2021-04-21 10_49_57-05_resum_Sem_2021.pdf - Foxit Reader.png}}
  \end{figure}

  \item \textbf{EDT - Esquema de Traducción}, las acciones semánticas se intercalan con los símbolos de la producción, indicando el orden de ejecución de las acciones semánticas. Es una notación para hacer un traductor. Tiene dos tipos:
  \begin{itemize}
    \item EDT \textbf{solo con atributos sintetizados}, las acciones se ponen al final de la producción.
    \item EDT con \textbf{atributos sintetizados y heredados}, la posición de las acciones debe tener en cuenta los cálculos y atributos que contribuyen.
    \begin{itemize}
      \item Un atributo heredado (en la parte derecha de la producción) DEBE calculará con una acción antes de dicho símbolo.
      \item Una acción NO debe referirse a un atributo sintetizado de un símbolo que esté a la derecha de la acción.
      \item Para calcular el No Terminal izquierdo DEBE haberse calculado previamente todos los atributos de los símbolos que participen.
    \end{itemize}
  \end{itemize}
  \begin{figure}[H]
    \ffigbox[\FBwidth]
    {\caption{Ejemplo EDT}}
    {\includegraphics[scale=.3]{2021-04-21 11_14_06-05_resum_Sem_2021.pdf - Foxit Reader.png}
    \includegraphics[scale=.24]{2021-04-21 11_14_40-05_resum_Sem_2021.pdf - Foxit Reader.png}}
  \end{figure}
\end{itemize}

Una gramática atribuida GA es \textbf{completa} si, para todo atributo de toda regla hay una acción semántica asociada para calcularlo.
\begin{itemize}
  \item Para toda regla P: $X\rightarrow\alpha$ en P, AS(X) está en AC(P).
  \item Para toda regla Q: $Y\rightarrow\alpha X \beta$ en Q, AH(X) está en AC(Q).
  \item $AS(X) \cup AH(X) = A(X)$, $AS(X) \cap AH(X)=\emptyset$
\end{itemize}

Una gramática atribuida GA está \textbf{bien definida} si, para cualquier sentencia en L(GA), todos los atributos pueden ser calculados (este proceso se llama evaluación de la gramática). Además, una sentencia de su lenguaje tiene atributos correctos si se verifican las condiciones en B(P) para cada regla P de la gramática.
\begin{itemize}
  \item \textbf{Gramática Atribuida bien definida $\Rightarrow$ Gramática Atribuida completa}
\end{itemize}
En el caso de buscar que esté bien definido es más fácil buscar un fallo (para decir que no lo es), que comprobar que se cumple para todas las sentencias del lenguaje (que es inabarcable). Si no se encuentra el contraejemplo se dice que no se puede demostrar que no lo es.

\section{Tipos de atributos y gramáticas}
\subsection{Atributos heredados y sintetizados}
\textbf{Dos tipos de atributos:}
\begin{itemize}
  \item \textbf{Sintetizados:} El valor de un nodo (parte izquierda) depende solo de los valores de los nodos hijos (parte derecha). Se hace de abajo hacia arriba.
  \begin{figure}[H]
    \ffigbox[\FBwidth]
    {\caption{A. sintetizado}}
    {\includegraphics[scale=.3]{2021-04-21 10_46_33-05_resum_Sem_2021.pdf - Foxit Reader.png}}
  \end{figure}

  \item \textbf{Heredados:} Los valores se pasan a niveles inferiores del árbol, el valor depende de los hermanos y del padre (como un sumidero de datos).
  
  \begin{figure}[H]
    \ffigbox[\FBwidth]
    {\caption{A. heredado}}
    {\includegraphics[scale=.3]{2021-04-21 10_47_58-05_resum_Sem_2021.pdf - Foxit Reader.png}}
  \end{figure}

\end{itemize}
Los atributos mantienen su tipo en toda la gramática, y los tokens (símbolos terminales) solo tienen atributos sintetizados.

Los atributos heredados se tratan utilizando estructuras auxiliares para pasar los datos, como puede ser una tabla o una pila.

\textbf{Atributos calculados AC(P):} Atributos calculados con producción P, que exista una regla de cálculo asociada a la obtención de su valor.
\begin{itemize}
  \item \textbf{Atributos sintetizados AS(X):} Cuando lo que se calcula es el símbolo de la parte izquierda de la regla.
  \item \textbf{Atributos heredados AH(X):} Cuando el valor que se calcula es el producido en una regla de producción.
\end{itemize}
\pagebreak
\subsection{Evaluación de las reglas semánticas}
\textbf{Hay dos métodos:}
\begin{itemize}
  \item Métodos con \textbf{árbol de análisis sintáctico}: Se realizan en el momento de compilación y el orden que se sigue viene dado por el grafo de dependencias (ordenamiento topológico) de cada nodo construido según el árbol de análisis sintáctico. No funciona para gramáticas con ciclos.
  \item Métodos de evaluación \textbf{durante el análisis sintáctico}: La evaluación se hace en una sola pasada y no es necesario construir un grafo de dependencias de forma explícita, lo que lo hace más eficiente. 
  \begin{itemize}
    \item Hay métodos \textbf{basados en reglas}, en el que las acciones semánticas asociadas a las producciones se analizan a mano o con alguna herramienta.
    \item Hay métodos \textbf{sin recuerdo}, el orden de evaluación no tiene en cuenta las reglas semánticas.
  \end{itemize}
\end{itemize}

\subsection{Evaluación durante el análisis sintáctico}
\begin{itemize}
  \item \textbf{S-A Grammars - Gramáticas de Atributos Sintetizados:} Gramática donde solo existen atributos sintetizados.
  
  Se puede evaluar con un analizador ascendente, mediante una pila, y descendente por medio de rutinas y valores devueltos.
  \item \textbf{L-A Grammars - Gramáticas de Atributos por la Izquierda:} Gramática donde todos los atributos heredados de cualquier producción dependen solo de atributos de símbolos a su izquierda o del símbolo de la parte izquierda de la producción.
  
  La información debe fluir de izquierda a derecha.

  Las L-A de tipo LL(1) pueden evaluarse con analizadores descendentes y ascendentes.

  Solo algunas de las LR(1) que NO son LL(1) pueden evaluarse con L-A mediante un analizador ascendente.
\end{itemize}
\pagebreak
\section{Evaluación de Atributos}
\subsection{Evaluación Ascendente con Atributos Sintetizados}
Los atributos sintetizados se pueden evaluar durante el análisis de la entrada con un analizador sintáctico ascendente.

La pila de estados LR tiene asociados los símbolos gramaticales.
Basta con crear otra pila con los valores de los atributos sintetizados asociados.

Con cada reducción se calculan los nuevos atributos sintetizados accediendo en la pila a los atributos de símbolos gramaticales del lado derecho de la producción

\subsection{Grafos de dependencia}
La manera de resolver las gramáticas en el peor caso se consigue construyendo uno de estos grafos.

Los atributos no pueden evaluarse en cualquier orden, tras tenerlo construido se pasa un algoritmo que lo determina.

Nos permite representar interdependencias entre atributos heredados y sintetizados de un árbol de análisis sintáctico.

\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Grafo de dependencia}}
  {\def\svgwidth{.9\textwidth}
  \input{./img/grafoDependencias.eps_tex}}
\end{figure}

\textbf{Creación:} Cada una de las reglas de producción $A \rightarrow X_1 ... X_n$ representan una parte del grafo, de tal manera que la unión de todas es el grafo completo.
\begin{enumerate}
  \item Se crea un nodo por cada atributo $X_i.a_j$ de cada símbolo de la producción.
  \begin{itemize}
    \item Atributos heredados - Izquierda.
    \item Atributos sintetizados - Derecha.
  \end{itemize}
  \item Para cada regla semántica $X_i.a_j = f(...,X_k.a_l, ...)$ se hacen arcos desde cada nodo $X_k.a_l$ hacia el nodo $X_i.a_j$, esto se repite para cada k y l afectada por la regla.
\end{enumerate}
\pagebreak
\subsection{Árbol de Sintaxis abstracta}
Es una alternativa más sencilla, el grafo de dependencias es más completo. Se utiliza cuando no es una Gramática de atributos por la izquierda mediante esquema de traducción con atributos sintetizados (siempre).

Se usa para los casos en los que la gramática no se puede evaluar durante el análisis sintáctico.

Evaluación en varias pasadas: Se construye el árbol explícitamente y se evalúa en función del orden de recorrido.

\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Árbol Sintáctico Abstracto}}
  {\includegraphics[scale=.25]{2021-05-01 01_21_28-05_resum_Sem_2021.pdf - Foxit Reader.png}}
\end{figure}

El Árbol sintáctico abstracto es una estructura de datos que condensa un árbol de análisis sintáctico. 
\begin{itemize}
  \item Las operaciones y las palabras claves no forman parte de las hojas, sino que son absorbidas por el padre. 
  \item Los elementos que tienen información semántica representan las hojas.
\end{itemize}

Construcción en la programación:
\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Árbol de sintaxis abstracta}}
  {\includegraphics[scale=.25]{2021-05-01 01_30_29-05_resum_Sem_2021.pdf - Foxit Reader.png}}
\end{figure}
\begin{itemize}
  \item Un nodo para cada operador y cada operando.
  \item Un nodo almacena su tipo y su valor si es un operando, en caso de ser un operador en vez de valor almacena el puntero a los operadores. Los punteros y tipo son atributos sintetizados
  \begin{itemize}
    \item hazNodo (operador, izquierda, derecha)
    \item hazHoja (id, entrada)
    \item hazHoja (núm, val)
  \end{itemize}
\end{itemize}

\section{Orden de recorrido del árbol}

Los atributos heredados los calculamos antes y los sintetizados después. 

Nos vamos moviendo de izquierda a derecha.

Una vez calculado el heredado se puede pasar al sintetizado.

\textbf{Complejidad de la evaluación}
\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Complejidad de la evaluación}}
  {\includegraphics[scale=.25]{2021-05-01 01_46_28-05_resum_Sem_2021.pdf - Foxit Reader.png}}
\end{figure}
\begin{itemize}
  \item S-atribuida, Gramáticas atribuidas, va hacia arriba. Calculamos lo de los hijos y lo pasamos hacia arriba.
  \item L-atribuida, Gramáticas por la izquierda. De forma sistemática, se hace una sola visita, recorriendo el árbol.
  \item Combinada, hay que ver el orden de dependencia entre atributos para construir el orden.
\end{itemize}

\textbf{Orden dinámico:} Para aquellos que hasta que no lo construimos no sabemos el orden, cuando no está fijada la relación entre atributos.
  
Para estos casos es necesario construir el grafo de dependencias, no nos vale el Árbol Sintáctico Abstracto.

\textbf{Orden estático:} Analizando la gramática y las dependencias se establece el orden a priori.
  \begin{itemize}
    \item \textbf{Caso que no necesita un árbol de atributos:} Gramáticas S-A y L-A, las de una pasada.
    \item \textbf{Sobre el árbol de atributos:} Los 3 primeros se puede hacer de una sola pasada por el árbol en las que se calculan los atributos.
    \begin{itemize}
      \item \textbf{Recorrido post-orden}, depende solo de atributos sintetizados.
      \begin{figure}[H]
        \ffigbox[\FBwidth]
        {\caption{Recorrido post-orden}}
        {\includegraphics[scale=.25]{2021-05-01 01_50_04-05_resum_Sem_2021.pdf - Foxit Reader.png}}
      \end{figure}
      \item \textbf{Recorrido pre-orden}, aparecen atributos heredados, el caso de las Gramáticas L-A.
      \begin{figure}[H]
        \ffigbox[\FBwidth]
        {\caption{Recorrido pre-orden}}
        {\includegraphics[scale=.25]{2021-05-01 01_51_44-05_resum_Sem_2021.pdf - Foxit Reader.png}}
      \end{figure}
      \pagebreak
      \item \textbf{Recorrido combinado}, atributos sintetizados dependen de heredados.
      \begin{figure}[H]
        \ffigbox[\FBwidth]
        {\caption{Recorrido combinado}}
        {\includegraphics[scale=.25]{2021-05-01 01_52_19-05_resum_Sem_2021.pdf - Foxit Reader.png}}
      \end{figure}
      \item \textbf{Recorrido de varias pasadas, Recorrido combinado}, atributos heredados dependen de sintetizados.
    \end{itemize}
  \end{itemize}

\chapter{Tema 6: Comprobación de Tipos}
\section{Introducción}
Su función es representar y mantener la información de tipos (inferencia).

Comprueba que el tipo de una construcción tenga sentido en su contexto según el lenguaje.

Se encuentra tras la construcción del TSA (árbol sintáctico abstracto). ??

En la gramática atribuida es sencillo, pero no siempre es así y para los tipos más complejos se usan tablas.
\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Ejemplo Comprobación de Tipos}}
  {\includegraphics[scale=.25]{2021-05-01 02_14_46-06_resum_Tipos_2021.pdf - Foxit Reader.jpg}}
\end{figure}

Un lenguaje \textbf{especifica que operaciones son válidas para cada tipo}, mediante la formalización de reglas semánticas de verificación.

Se \textbf{detectan errores} como: Acceso incorrecto a memoria, Límites de abstracción, mal uso de estructuras, etc.

\textbf{Tipos de lenguajes:}
\begin{itemize}
  \item \textbf{Estáticamente tipificados:} La mayoría de las comprobaciones se realizan en tiempo de \textbf{compilación} (C, Java). Menos libres, pero más seguros.
  \item \textbf{Dinámicamente tipificados:} La mayoría de las comprobaciones en \textbf{ejecución} (Scheme, LISP)
  \item \textbf{No tipificados:} Ninguna comprobación (código ensamblador)
\end{itemize}

\section{Sistemas de tipos}
\subsection{Expresiones de tipos}
Representan el tipo de las construcciones los valores posibles, todos los tipos de datos y operaciones aplicables.
\begin{itemize}
  \item Tipo de Expresión resultante de aplicar operadores aritméticos.
  \item Resultado de aplicar operador \&.
  \item Tipo de llamada a función.
  \item …
\end{itemize}

\textbf{Pueden ser:}
\begin{itemize}
  \item \textbf{Tipos básicos:} El nombre de un tipo es una expresión de tipo. Su valor es una constante que lo representa.
  \begin{itemize}
    \item boolean, char, integer, real, vacío, error\_tipo,\dots
  \end{itemize}
  \item \textbf{Constructor de tipos y expresiones de tipos:} Son tipos más complejos formados de tipos básicos.
  \begin{itemize}
    \item \textbf{Array:} Es una estructura formada por una serie de elementos de un tipo, se especifica el número de elementos y el tipo de estos. $array[1\text{..}10]$
    \item \textbf{Productos cartesianos:} Asociación de tipos en una estructura.
    \item \textbf{Registros:} Es el producto de diferentes tipos, es decir usar como tipo productos cartesianos de otros tipos definidos.
    
    $record (("direccion" : integer) \times ("lexema" : array(1..15, Char)))$
    
    $array(1\text{..}10, record (("direccion" : integer) \times ("lexema" : array(1\text{..}15,char)))$

    \item \textbf{Punteros:} Dado un tipo $T$, el $Pointer(T)$ es el tipo del puntero hacia elementos de tipo T.
    \item \textbf{Funciones:} Es una relación entre un tipo origen y un tipo destino. El origen suele ser un producto cartesiano.
    
    Una función del tipo $f(a,b:char) : \hat{} integer$ tiene asociado $(char \times char) \rightarrow Pointer(integer)$
  \end{itemize}
\end{itemize}
\textbf{Representación de tipos:}
Las representaciones de expresiones de tipo se pueden hacer en forma de Árbol o con un Grafo dirigido acíclico.

Tipos anónimos: No se indica el tipo explícitamente.

Tipos declarados: Se declara el tipo (typedef) para luego crear variables.


\subsection{Comprobación estática y dinámica}
Estática en los lenguajes que los tipos no cambian.

Dinámica para los lenguajes más complejos, que pueden variar el tipo directamente.

Sistemas de tipos seguro: protege la integridad de abstracciones creadas por el programador, aunque algunas comprobaciones solo puede ser dinámicas.

\section{Especificación de un comprobador de tipos sencillo}

Ejemplo de lenguaje, con todos los identificadores declarados antes de uso.

\subsection{Tipos de lenguaje}
\begin{itemize}
  \item Tipos básicos
  \begin{itemize}
    \item Char
    \item Integer
    \item Error\_Tipo
  \end{itemize}
  \item Tipos complejos
  \begin{itemize}
    \item Array[n] of T
    \item \^ T
  \end{itemize}
\end{itemize}

\subsection{Gramatica del lenguaje}
\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Ej. Gramatica}}
  {\includegraphics[scale=.35]{Screenshot 2021-06-09 at 12.19.07.png}}
\end{figure}

\subsection{Acciones semanticas constructor de tipos}
\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Ej. Acciones semanticas constructor de tipos}}
  {\includegraphics[scale=.35]{Screenshot 2021-06-09 at 12.21.40.png}}
\end{figure}

\subsection{Acciones semanticas verificación de tipos}
\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Ej. Acciones semanticas verificación de tipos I}}
  {\includegraphics[scale=.3]{Screenshot 2021-06-09 at 12.23.29.png}}
\end{figure}
\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Ej. Acciones semanticas verificación de tipos II}}
  {\includegraphics[scale=.3]{Screenshot 2021-06-09 at 12.24.59.png}}
\end{figure}

\subsection{Tipos de sentencias}
\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Ej. Sentencias}}
  {\includegraphics[scale=.3]{Screenshot 2021-06-09 at 12.26.53.png}}
\end{figure}

\subsection{Conversiones de tipos}
Algunas operaciones pueden aplicarse a operandos de distintos tipos, a un tipo más grande  (coerción)

\section{Tablas de Símbolos}
Recogen las diferentes declaraciones del programa.
\begin{itemize}
  \item Constantes
  \item Variables
  \item Funciones
  \item Tipos
\end{itemize}

Tiene una estructura para buscar por identificador, hash. Almacena identificadores definidos en el programa.
\begin{itemize}
  \item Se usa en diferentes fases del análisis y síntesis.
  \item Funciones de inserción, búsqueda y eliminación.

\begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    \textbf{NOMBRE} & \textbf{TIPO} & \textbf{TAMAÑO} & \textbf{DIRECCIÓN} \\ \hline
    a               & Entero        & 4               & 100                \\ \hline
    b               & Entero        & 4               & 104                \\ \hline
    c               & Real          & 8               & 112                \\ \hline
    d               & Real          & 8               & 120                \\ \hline
    e               & Carácter      & 1               & 121                \\ \hline
    f               & Carácter      & 1               & 122                \\ \hline
    \end{tabular}
\end{table}
\end{itemize}
\pagebreak
Dos usos en la verificación semántica
\begin{itemize}
  \item Que en la declaración de una variable no haya colisiones.
  \item Al usar una variable que sea del tipo esperado.
\end{itemize}

Tablas para estructuras registro, se almacena en la tabla de tipos el registro y en la tabla de registros se definen sus componentes con sus tipos y el registro que pertenece.›
\begin{figure}[H]
  \ffigbox[\FBwidth]
  {\caption{Tabla para registros}}
  {\includegraphics[scale=.4]{Screenshot 2021-06-09 at 12.38.46.png}}
\end{figure}

\section{Implementación de Clases}
Las clases son tipos complejos que agrupan datos con operaciones (métodos) que lo usan y modifican.

\begin{table}[h]
  \begin{tabular}{|c|c|c|c|}
  \hline
  a & b & setA & getA \\ \hline
  \end{tabular}
\end{table}

Esta clase de registro (tipo class) guarda los valores y el puntero a los procedimientos en la sección de código.
\begin{itemize}
  \item a,  b son datos enteros
  \item setA, getA son punteros al código de la clase
\end{itemize}

\subsection{Esquema general de objetos}
Similar a un registro, con campos específicos en la cabecera:

Los métodos se declaran antes y después los valores de atributos

\begin{table}[h]
  \begin{tabular}{ccc}
                                                 &                                   & Offset \\ \cline{2-2}
  \multicolumn{1}{c|}{\multirow{3}{*}{Cabecera}} & \multicolumn{1}{c|}{Class Tag}    & 0      \\ \cline{2-2}
  \multicolumn{1}{c|}{}                          & \multicolumn{1}{c|}{Object Size}  & 4      \\ \cline{2-2}
  \multicolumn{1}{c|}{}                          & \multicolumn{1}{c|}{Dispatch Ptr} & 8      \\ \cline{2-2}
  \multicolumn{1}{c|}{\multirow{3}{*}{Datos}}    & \multicolumn{1}{c|}{Attribute 1}  & 12     \\ \cline{2-2}
  \multicolumn{1}{c|}{}                          & \multicolumn{1}{c|}{Attribute 2}  & 16     \\ \cline{2-2}
  \multicolumn{1}{c|}{}                          & \multicolumn{1}{c|}{...}          &        \\ \cline{2-2}
  \end{tabular}
\end{table}


\subsection{Acceso a miembtros de clase}
Para referirse a un atributo f del objeto como this.f o simplemente f.

Se genera el mismo código, que ponga el this. o no se usa una referencia implícita al objeto para cualquier método.

\subsection{Herencia}
El desplazamiento (offset) de un atributo es el mismo en una clase y en las heredadas. Cualquier método de una clase A1 se pueden usar una subclase A2.

\paragraph{Polimorfismos:} Que el mismo código se pueda comportar de diferentes maneras. Si llama una hija y la madre no hacen lo mismo. Para esto se usa una tabla de despacho dinámico.
Los métodos de las clases que heredan usan los de la original, se amplía manteniendo lo que siga igual.
\pagebreak
\subsection{Tablas de Despacho}
Cada clase tiene un conjunto fijo de métodos (incluidos los heredados)

Esta tabla indexa los métodos
\begin{itemize}
  \item Array de puntos de entrada a métodos
  \item Cada método f a una distancia fija en la tabla de despacho, para una clase y sus heredadas.
\end{itemize}

\begin{table}[H]
  \centering
  \begin{tabular}{ccccccccccccccccc}
                                  & \textbf{a}              & \textbf{b}              & \textbf{c}              & \textbf{d}              & \textbf{e}                                     & \textbf{f}                                     & \textbf{g}                                     & \textbf{h}                                     & \textbf{i}                                     & \textbf{j}                                     & \textbf{k}                                     & \textbf{l}                                     & \textbf{m}                                     & \textbf{n}                                     & \textbf{o}                                     & \textbf{p}                                     \\ \cline{2-17} 
  \multicolumn{1}{c|}{\textbf{A}} & \multicolumn{1}{c|}{01} & \multicolumn{1}{c|}{02} & \multicolumn{1}{c|}{03} & \multicolumn{1}{c|}{04} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} \\ \cline{2-17} 
  \multicolumn{1}{c|}{\textbf{B}} & \multicolumn{1}{c|}{01} & \multicolumn{1}{c|}{09} & \multicolumn{1}{c|}{03} & \multicolumn{1}{c|}{04} & \multicolumn{1}{c|}{06}                        & \multicolumn{1}{c|}{07}                        & \multicolumn{1}{c|}{08}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} \\ \cline{2-17} 
  \multicolumn{1}{c|}{\textbf{C}} & \multicolumn{1}{c|}{01} & \multicolumn{1}{c|}{09} & \multicolumn{1}{c|}{03} & \multicolumn{1}{c|}{04} & \multicolumn{1}{c|}{10}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{11}                        & \multicolumn{1}{c|}{12}                        & \multicolumn{1}{c|}{13}                        & \multicolumn{1}{c|}{14}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} \\ \cline{2-17} 
  \multicolumn{1}{c|}{\textbf{D}} & \multicolumn{1}{c|}{15} & \multicolumn{1}{c|}{09} & \multicolumn{1}{c|}{26} & \multicolumn{1}{c|}{04} & \multicolumn{1}{c|}{10}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{11}                        & \multicolumn{1}{c|}{12}                        & \multicolumn{1}{c|}{17}                        & \multicolumn{1}{c|}{18}                        & \multicolumn{1}{c|}{19}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} \\ \cline{2-17} 
  \multicolumn{1}{c|}{\textbf{E}} & \multicolumn{1}{c|}{01} & \multicolumn{1}{c|}{09} & \multicolumn{1}{c|}{03} & \multicolumn{1}{c|}{04} & \multicolumn{1}{c|}{10}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{11}                        & \multicolumn{1}{c|}{20}                        & \multicolumn{1}{c|}{21}                        & \multicolumn{1}{c|}{22}                        & \multicolumn{1}{c|}{23}                        & \multicolumn{1}{c|}{24}                        & \multicolumn{1}{c|}{25}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} \\ \cline{2-17} 
  \multicolumn{1}{c|}{\textbf{F}} & \multicolumn{1}{c|}{01} & \multicolumn{1}{c|}{09} & \multicolumn{1}{c|}{03} & \multicolumn{1}{c|}{04} & \multicolumn{1}{c|}{10}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{11}                        & \multicolumn{1}{c|}{12}                        & \multicolumn{1}{c|}{13}                        & \multicolumn{1}{c|}{14}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}0} & \multicolumn{1}{c|}{26}                        & \multicolumn{1}{c|}{27}                        \\ \cline{2-17} 
  \end{tabular}
  \caption{Tabla de despacho}
  \end{table}
    
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
    %uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300
    %Flowchart: Connector [id:dp8263106487253196] 
    \draw   (265,29.5) .. controls (265,23.98) and (269.48,19.5) .. (275,19.5) .. controls (280.52,19.5) and (285,23.98) .. (285,29.5) .. controls (285,35.02) and (280.52,39.5) .. (275,39.5) .. controls (269.48,39.5) and (265,35.02) .. (265,29.5) -- cycle ;
    %Flowchart: Connector [id:dp9156282731650551] 
    \draw   (230,69.5) .. controls (230,63.98) and (234.48,59.5) .. (240,59.5) .. controls (245.52,59.5) and (250,63.98) .. (250,69.5) .. controls (250,75.02) and (245.52,79.5) .. (240,79.5) .. controls (234.48,79.5) and (230,75.02) .. (230,69.5) -- cycle ;
    %Flowchart: Connector [id:dp44148600683534744] 
    \draw   (190,110.5) .. controls (190,104.98) and (194.48,100.5) .. (200,100.5) .. controls (205.52,100.5) and (210,104.98) .. (210,110.5) .. controls (210,116.02) and (205.52,120.5) .. (200,120.5) .. controls (194.48,120.5) and (190,116.02) .. (190,110.5) -- cycle ;
    %Flowchart: Connector [id:dp013202394940729612] 
    \draw   (300,69.5) .. controls (300,63.98) and (304.48,59.5) .. (310,59.5) .. controls (315.52,59.5) and (320,63.98) .. (320,69.5) .. controls (320,75.02) and (315.52,79.5) .. (310,79.5) .. controls (304.48,79.5) and (300,75.02) .. (300,69.5) -- cycle ;
    %Flowchart: Connector [id:dp35188985703112063] 
    \draw   (230,110.5) .. controls (230,104.98) and (234.48,100.5) .. (240,100.5) .. controls (245.52,100.5) and (250,104.98) .. (250,110.5) .. controls (250,116.02) and (245.52,120.5) .. (240,120.5) .. controls (234.48,120.5) and (230,116.02) .. (230,110.5) -- cycle ;
    %Flowchart: Connector [id:dp4241310610084512] 
    \draw   (270,110.5) .. controls (270,104.98) and (274.48,100.5) .. (280,100.5) .. controls (285.52,100.5) and (290,104.98) .. (290,110.5) .. controls (290,116.02) and (285.52,120.5) .. (280,120.5) .. controls (274.48,120.5) and (270,116.02) .. (270,110.5) -- cycle ;
    
    % Text Node
    \draw (234,61) node [anchor=north west][inner sep=0.75pt]   [align=left] {C};
    % Text Node
    \draw (304,61) node [anchor=north west][inner sep=0.75pt]   [align=left] {B};
    % Text Node
    \draw (194,102) node [anchor=north west][inner sep=0.75pt]   [align=left] {D};
    % Text Node
    \draw (234,102) node [anchor=north west][inner sep=0.75pt]   [align=left] {E};
    % Text Node
    \draw (274,102) node [anchor=north west][inner sep=0.75pt]   [align=left] {F};
    % Text Node
    \draw (269,21) node [anchor=north west][inner sep=0.75pt]   [align=left] {A};
    % Text Node
    \draw (291,22) node [anchor=north west][inner sep=0.75pt]   [align=left] {abcd};
    % Text Node
    \draw (188,62) node [anchor=north west][inner sep=0.75pt]   [align=left] {behijk};
    % Text Node
    \draw (321,62) node [anchor=north west][inner sep=0.75pt]   [align=left] {befg};
    % Text Node
    \draw (187,122) node [anchor=north west][inner sep=0.75pt]   [align=left] {acjkl};
    % Text Node
    \draw (221,122) node [anchor=north west][inner sep=0.75pt]   [align=left] {ijklmn};
    % Text Node
    \draw (270,122) node [anchor=north west][inner sep=0.75pt]   [align=left] {op};
    % Connection
    \draw    (231,79.24) -- (210,100.76) ;
    % Connection
    \draw    (240.35,82) -- (240.15,98) ;
    % Connection
    \draw    (250,79.49) -- (271,101.56) ;
    % Connection
    \draw    (266,39.93) -- (250,58.49) ;
    % Connection
    \draw    (284,39.79) -- (301,59.21) ;
    
    \end{tikzpicture}
  
\end{figure}
  
\chapter{Tema 7: Generación de código intermedio}
\includepdf[pages=2-]{docs/07_generacionCodigoInterm_2021.pdf}

\end{document}

