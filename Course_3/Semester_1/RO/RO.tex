\documentclass[12pt, twoside, openright]{report} %fuente a 12pt, formato doble pagina y chapter a la derecha
\raggedbottom % No ajustar el contenido con un salto de pagina

% MÁRGENES: 2,5 cm sup. e inf.; 3 cm izdo. y dcho.
\usepackage[
a4paper,
vmargin=2.5cm,
hmargin=3cm
]{geometry}

% INTERLINEADO: Estrecho (6 ptos./interlineado 1,15) o Moderado (6 ptos./interlineado 1,5)
\renewcommand{\baselinestretch}{1.15}
\parskip=6pt

% DEFINICIÓN DE COLORES para portada y listados de código
\usepackage[table]{xcolor}
\definecolor{azulUC3M}{RGB}{0,0,102}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

% Soporte para GENERAR PDF/A
\usepackage[a-1b]{pdfx}

% ENLACES
\usepackage{hyperref}
\hypersetup{colorlinks=true,
	linkcolor=black, % enlaces a partes del documento (p.e. índice) en color negro
	urlcolor=blue} % enlaces a recursos fuera del documento en azul

% Añadir pdfs como partes del documento
\usepackage{pdfpages}

% Quitar la indentación de principio de los parrafos
\setlength{\parindent}{0em}

% EXPRESIONES MATEMATICAS
\usepackage{amsmath,amssymb,amsfonts,amsthm}

\usepackage{txfonts} 
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

% Insertar graficas y fotos
\usepackage{tikz}
\usepackage{pgfplots}

\usepackage[spanish, es-tabla]{babel} 
\usepackage[babel, spanish=spanish]{csquotes}
\AtBeginEnvironment{quote}{\small}

% diseño de PIE DE PÁGINA
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\fancyfoot[LE,RO]{\thepage}
\fancypagestyle{plain}{\pagestyle{fancy}}

% DISEÑO DE LOS TÍTULOS de las partes del trabajo (capítulos y epígrafes o subcapítulos)
\usepackage{titlesec}
\usepackage{titletoc}
\titleformat{\chapter}[block]
{\large\bfseries\filcenter}
{\thechapter.}
{5pt}
{\MakeUppercase}
{}
\titlespacing{\chapter}{0pt}{0pt}{*3}
\titlecontents{chapter}
[0pt]                                               
{}
{\contentsmargin{0pt}\thecontentslabel.\enspace\uppercase}
{\contentsmargin{0pt}\uppercase}                        
{\titlerule*[.7pc]{.}\contentspage}                 

\titleformat{\section}
{\bfseries}
{\thesection.}
{5pt}
{}
\titlecontents{section}
[5pt]                                               
{}
{\contentsmargin{0pt}\thecontentslabel.\enspace}
{\contentsmargin{0pt}}
{\titlerule*[.7pc]{.}\contentspage}

\titleformat{\subsection}
{\normalsize\bfseries}
{\thesubsection.}
{5pt}
{}
\titlecontents{subsection}
[10pt]                                               
{}
{\contentsmargin{0pt}                          
	\thecontentslabel.\enspace}
{\contentsmargin{0pt}}                        
{\titlerule*[.7pc]{.}\contentspage}  


% DISEÑO DE TABLAS.
\usepackage{multirow} % permite combinar celdas 
\usepackage{caption} % para personalizar el título de tablas y figuras
\usepackage{floatrow} % utilizamos este paquete y sus macros \ttabbox y \ffigbox para alinear los nombres de tablas y figuras de acuerdo con el estilo definido. Para su uso ver archivo de ejemplo 
\usepackage{array} % con este paquete podemos definir en la siguiente línea un nuevo tipo de columna para tablas: ancho personalizado y contenido centrado
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\DeclareCaptionFormat{upper}{#1#2\uppercase{#3}\par}

% Diseño de tabla para ingeniería
\captionsetup[table]{
	format=hang,
	name=Tabla,
	justification=centering,
	labelsep=colon,
	width=.75\linewidth,
	labelfont=small,
	font=small,
}

% DISEÑO DE FIGURAS.
\usepackage{graphicx}
\graphicspath{{img/}} %ruta a la carpeta de imágenes

% Diseño de figuras para ingeniería
\captionsetup[figure]{
	format=hang,
	name=Fig.,
	singlelinecheck=off,
	labelsep=colon,
	labelfont=small,
	font=small		
}

% NOTAS A PIE DE PÁGINA
\usepackage{chngcntr} %para numeración continua de las notas al pie
\counterwithout{footnote}{chapter}

% LISTADOS DE CÓDIGO
% soporte y estilo para listados de código. Más información en https://es.wikibooks.org/wiki/Manual_de_LaTeX/Listados_de_código/Listados_con_listings
\usepackage{listings}

% definimos un estilo de listings
\lstdefinestyle{estilo}{ frame=Ltb,
	framerule=0pt,
	aboveskip=0.5cm,
	framextopmargin=3pt,
	framexbottommargin=3pt,
	framexleftmargin=0.4cm,
	framesep=0pt,
	rulesep=.4pt,
	backgroundcolor=\color{gray97},
	rulesepcolor=\color{black},
	%
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\bfseries,
	stringstyle=\ttfamily,
	showstringspaces = false,
	commentstyle=\color{gray45},     
	%
	numbers=left,
	numbersep=15pt,
	numberstyle=\tiny,
	numberfirstline = false,
	breaklines=true,
	xleftmargin=\parindent
}

\captionsetup[lstlisting]{font=small, labelsep=period}
% fijamos el estilo a utilizar 
\lstset{style=estilo}
\renewcommand{\lstlistingname}{\uppercase{Código}}

\pgfplotsset{compat=1.17} 
%-------------
%	DOCUMENTO
%-------------

\begin{document}
\pagenumbering{roman} % Se utilizan cifras romanas en la numeración de las páginas previas al cuerpo del trabajo

%----------
%	PORTADA
%----------	
\begin{titlepage}
	\begin{sffamily}
		\color{azulUC3M}
		\begin{center}
			\begin{figure}[H] %incluimos el logotipo de la Universidad
				\makebox[\textwidth][c]{\includegraphics[width=16cm]{Portada_Logo.png}}
			\end{figure}
			\vspace{2.5cm}
			\begin{Large}
				Grado en Ingeniería Informática\\
				2020-2021\\
				\vspace{2cm}
				\textsl{Apuntes}\\
				\bigskip
			\end{Large}
			{\Huge Redes de ordenadores}\\
			\vspace*{0.5cm}
			\rule{10.5cm}{0.1mm}\\
			\vspace*{0.9cm}
			{\LARGE Jorge Rodríguez Fraile\footnote{\href{mailto:100405951@alumnos.uc3m.es}{Universidad: 100405951@alumnos.uc3m.es}  |  \href{mailto:jrf1616@gmail.com}{Personal: jrf1616@gmail.com}}}\\
			\vspace*{1cm}
		\end{center}
		\vfill
		\color{black}
		\includegraphics[width=4.2cm]{img/creativecommons.png}\\
		Esta obra se encuentra sujeta a la licencia Creative Commons\\ \textbf{Reconocimiento - No Comercial - Sin Obra Derivada}
	\end{sffamily}
\end{titlepage}

%----------
%	ÍNDICES
%----------	

%--
% Índice general
%-
\tableofcontents
\thispagestyle{fancy}

%--
% Índice de figuras. Si no se incluyen, comenta las líneas siguientes
%-
\listoffigures
\thispagestyle{fancy}

%----------
%	TRABAJO
%----------	

\pagenumbering{arabic} % numeración con múmeros arábigos para el resto de la publicación	


%----------
%	COMENZAR A ESCRIBIR AQUI
%----------	

\chapter{Información}
\section{Profesores}
\begin{quote}
	Magistral: MARCELO GABRIEL BAGNULO BRAUN

	Prácticas: JUAN MAURICIO BARROSO FRESNEDA y MARCELO GABRIEL BAGNULO BRAUN:
\end{quote}

\section{Recursos}

\href{https://www.virtualbox.org/}{Oracle VM VirtualBox}

\href{https://www.nrl.navy.mil/itd/ncs/products/core}{Networks and
	Communication Systems Branch}

\url{https://www.youtube.com/watch?v=eow0I39diug}

\url{https://www.youtube.com/watch?v=7wVJQTu5H3E}

\href{http://www.ingebook.com/ib/NPcd/IB_Escritorio_Visualizar?cod_primaria=1000193\&libro=6752}{Escritorio Virtualizar}

\href{https://padlet.com/fvalera/8njxmoxyj4qgck6d}{Computer Networks}


\chapter{TEMA 1}

\section{1.1 y 1.3 Internet o Red de ordenadores}

Conjunto de ordenadores interconectados de tal forma que pueden
intercambiar información. Para los creadores de aplicaciones
distribuidas es el servicio de comunicación que nos permite enviar y
recibir mensajes mediante una API.

Hoy en día casi cualquier cosa se puede conectar a internet, por
tanto, el término de red de computadoras queda desactualizado, por
tanto, en la jerga de internet todos los dispositivos que se conectan
se denominan host o sistemas terminales.

\begin{itemize}
	\item Actualmente ya no son solo ordenadores, hay mucha variedad de
	      dispositivos.
	\item Infraestructura de comunicación:

	      \begin{itemize}
		      \item Dispositivos, que corren apps que conectan con la red. Hosts = end
		            systems.
		      \item Conmutadores = Packet switches y routers.
		      \item Enlaces de comunicación, conectan los dispositivos con los router
		            y los routers entre ellos, no es necesario conectar todos con
		            todos.

		            \begin{itemize}
			            \item Los enlaces entre routers deben ser más rápidos que los enlaces
			                  entre router-dispositivo, ya que el router transmite muchos
			                  paquetes a la vez.
			            \item La multiplexación estadística es la usada en la conmutación de
			                  paquetes, que asigna el uso del canal bajo demanda, es decir, no
			                  transmite de forma constante. Asigna dinámicamente los
			                  intervalos de tiempo de transmisión entre los terminales activos
			                  para no desaprovechar la capacidad del canal.
			            \item FDM: multiplexación en frecuencias, es el usado en radio en la
			                  conmutación de circuitos
			            \item La multiplexación por división de tiempo -- TDM tiene un tiempo
			                  de enlace asignado, por lo que se tarda igual independientemente
			                  de que haya más personas queriendo enviar información.
			                  Desaprovecha la capacidad del enlace, ya que dedica todo el
			                  ancho de banda del canal al transmisor en cada ranura de tiempo.
		            \end{itemize}
		      \item Network = Red, conjunto de dispositivos, routers y enlaces de una
		            organización.
	      \end{itemize}
	      \pagebreak
	\item El host rompe los mensajes en paquetes de datos de aprox. 1500 bytes
	      para ser transmitidos con un encabezado que permite indicar el
	      destinatario y a la red llevarlos. Una vez dividido se transmite por
	      un enlace al router, así con la cabecera sabe dónde reenviar otro
	      router, ahí hasta llegar al destino.

	      \begin{itemize}
		      \item Store and forward: Debe llegar el paquete completo al router antes
		            de transmitirlo por el siguiente enlace.
	      \end{itemize}
	\item Funciones clave de los nodos de la red:

	      \begin{itemize}
		      \item Forwarding -- Reenvío: Es una acción local, que se encarga de
		            mover los paquetes que llegan por el enlace de entrada al enlace
		            de salida correspondiente.
	      \end{itemize}
	\item Routing -- Enrutamiento: Es una acción global, consiste en
	      determinar la ruta desde el origen hasta destino que seguirán los
	      paquetes mediante algoritmo de enrutado.
\end{itemize}

\section{1.2 Las fronteras de la red}

Redes de acceso

Medios físicos

\subsection{Arquitectura de la red}

Hoy en día usamos principalmente dos redes de comunicación, la red
telefónica e internet.

\begin{itemize}
	\item Conmutación de circuitos: Conceptualmente hablando en la red
	      telefónica se crea un cable que te conecta la llamada y cuando
	      finaliza se despliega para dejar disponible los recursos para formar
	      otra conexión. Se usa multiplexación de división en el tiempo y
	      frecuencia. Usa toda la capacidad del enlace para el intercambio.
	\item Conmutación de paquetes: Los datos se trocean y se les agrega un
	      encabezado con la dirección de destino y se envía, los routers y
	      conmutadores miran la dirección y lo envía por su camino hasta llegar
	      al destino. Utiliza multiplexación estadística. Se comparten todos los
	      recursos en tiempo real.
\end{itemize}

\section{1.5 Protocolos}

Definen el formato, orden de enviado y recepción de mensajes entre las
entidades de la red y acciones tomadas en la transmisión de mensajes.
Hay tantos dispositivos y apps interconectados, cada uno distinto, para
que pueda funcionar todos deben hablar un lenguaje común, los protocolos
permiten acordarlo. Están en todas las conexiones, control de envíos y
recepción de datos.

\subsection{Modelo de capas:}

\begin{itemize}
	\item Cada capa siente que la comunicación es horizontal, sin embargo, la
	      implementación es vertical. Cada capa implementa un servicio y el
	      inverso
	\item El origen y destino implementan todas las capas. En el origen va de
	      arriba hacia abajo, en los intermedios sube y baja, y en el destino
	      sube las capas.
	\item Los enrutadores - routers implementan la capa red, enlace y física.
	\item Los conmutadores - switch implementan enlace y física.
	\item Capas:

	      \begin{itemize}
		      \item Aplicación: Los propios programas que quieren enviar y recibir
		            datos. Soporta aplicaciones distribuidas. Pone el mensaje.
		      \item Transporte: Multiplexación y desmultiplexación de datos para poder
		            utilizar distintas aplicaciones. Transferencia de datos entre
		            procesos. Pone un encabezado para identificar la aplicación, pasa a
		            llamarse segmento.
		      \item Red: Enrutamiento de datagramas de origen a destino: IP, protocolos
		            de enrutamiento. Concatena saltos para llevar los paquetes desde el
		            origen hasta el destino. Pone otro encabezamiento que indica la
		            localización del origen y destino, pasa a llamarse datagrama.
		      \item Enlace: Corrige y detecta errores de la transmisión, transfiere los
		            datos a la entidad de la red vecina, en conexiones a 1 salto. Pone
		            otro encabezamiento que indican el siguiente salto en la red, pasa a
		            llamarse trama.
		      \item Física: Traduce bits a ondas que se envían por el cable y viceversa.
	      \end{itemize}

\end{itemize}


\section{1.4 Retraso}

El tiempo que pasa desde que el paquete es recibido por el router hasta
que llega al destino.
$$d_{nodal}= d_{procesado}+d_{cola}+d_{transmisión}+d_{propagación}$$
\pagebreak

Tipos:

\begin{itemize}
	\item Procesamiento, comprobar error de bit y determinar el enlace de
	      salida.
	\item Cola, espera a ser transmitido por un enlace de salida.

	      \begin{itemize}
		      \item Intensidad de tráfico = \(\frac{L\cdot a}{R}\)

		            \begin{itemize}
			            \item L: tamaño paquete
			            \item a: ratio de llegada del paquete
			            \item R: ancho de banda
		            \end{itemize}
	      \end{itemize}
	\item Trasmisión: En transmitir los datos, volcarlo en el enlace.
	      \(\frac{L}{R}\)

	      \begin{itemize}
		      \item L: bits del paquete o mensaje.
		      \item R: ancho de banda del enlace. Bits/seg
	      \end{itemize}
	\item Propagación: Tiempo que tarda en transmitirse por el enlace.
	      \(\frac{d}{s}\)

	      \begin{itemize}
		      \item d: distancia del enlace. metros
		      \item s: velocidad de propagación. Metros/seg
	      \end{itemize}

\end{itemize}

\section{1.4 Traceroute:}

Método para conocer el retraso o perdida de datos.

Consiste en enviar 3 paquetes a destino, con tiempos de vida, de menos
a más. Cuando su tiempo termina vuelve y sabe cuánto tarda en cada
salto, al aumentar va llegando más lejos. Cuando hay un gran salto de
ms (milisegundos) podemos analizar la fuente.

\section{1.4 Perdida}

Cuando la capacidad del buffer se termina o se han enviado mal, y
dependiendo del protocolo:

\begin{itemize}
	\item Se pierde, se descarta lo que no entra.
	\item Pide al emisor que lo reenvíe.
\end{itemize}

\section{1.4 Throughput}


Tasa de procesamiento, la capacidad de un sistema para volcar datos
para transmitir. \(\frac{Bits}{tiempo}\).

\begin{itemize}
	\item Se caracteriza por el peor caso:

	      \begin{itemize}
		      \item Instantáneo: En un momento determinado
		      \item Medio: De media.
	      \end{itemize}
\end{itemize}

Cuello de botella / bottleneck: Cuando un enlace de una ruta restringe
el Throughput de la ruta, dado que en esa ruta habrá un enlace de
menor capacidad o que esté saturado.

Se toma para los cálculos el mínimo entre el \(\frac{R}{10}\),
\(R_{emisor}\) o \(R_{receptor}\).

Como R recibe muchas conexiones puede haber cuello de botella en
\(R_e\) y \(R_r\).

\chapter{TEMA 2: Application Layer}

\section{2.1 Principios de las aplicaciones de red}

Crear una aplicación de red:

\begin{itemize}
	\item Son aplicaciones distribuidas, que necesitan intercambiar
	      información para funcionar.
	\item Hay que crear la aplicación del cliente para los distintos
	      dispositivos y servidor, y ejecutarla.
	\item No es necesario modificar los elementos de la red, los usuarios
	      son los que hacen que funcione la red utilizando la aplicación.
\end{itemize}

Cliente: El que envía datos o inicia la comunicación.

Servidor: El que recibe o espera la comunicación.

Proceso: programa que se ejecuta.

\begin{itemize}
	\item dentro de un host.
	\item dentro del mismo host, dos procesos se comunican mediante la
	      comunicación entre procesos.
	\item procesos en diferentes hosts que se comunican mediante intercambio
	      de mensajes.
\end{itemize}


\subsection{Formas de estructurar las aplicaciones:}

Paradigma cliente-servidor:

\begin{itemize}
	\item Servidor: Su función es brindar servicio. Deben estar siempre
	      disponible y accesible. Dirección IP permanente.
	\item Cliente: Solo se conecta cuando necesita algo.
\end{itemize}

Arquitectura peer-peer (igual-igual): Las comunicaciones se hacen
directamente entre usuarios, sin pasar por un servidor.

\begin{itemize}
	\item Cliente: No siempre en línea, pides servicio a otro usuario y
	      provees servicio a otros usuarios.
	\item Auto escalabilidad: Cuando más clientes más capacidad de servicio.
\end{itemize}

\subsection{Sockets:}


Interfaz entre la capa de aplicación y transporte, dentro de esta
última.

Se utiliza para comunicar una aplicación con otra, en cada
dispositivo hay un shocket para esa aplicación.

Permite al sistema identificar cada aplicación, cuando se reciben
datos se pasan al correcto.

Un puerto no identifica de forma única la aplicación, hasta que se
le asigna uno.

Puerto: Identifica al socket del dispositivo con 16 bits. Hay un
rango asignado a aplicaciones bien conocidas.

\subsection{Protocolo de la capa de aplicación:}

Define:

\begin{itemize}
	\item Tipos de mensajes intercambiados.
	\item Sintaxis del mensaje.
	\item Semántica del mensaje.
	\item Reglas de cuándo y cómo los procesos envían y responden los
	      mensajes.
\end{itemize}

Tipos:

\begin{itemize}
	\item Protocolos abiertos: Todo el mundo tiene acceso a la definición.
	\item Protocolos de propietario: Propios de la aplicación.
\end{itemize}


\subsection{Necesidades del servicio de transporte:}

Dependiendo de la aplicación puede ser más o menos susceptible.

\begin{itemize}
	\item Integridad de datos: Los datos no hayan sido alterados, ya sea por
	      fallos o interferencias. Aplicación de envío de datos son muy
	      susceptibles y las de audio o video pueden tolerar perdidas.
	\item Temporalidad: El tiempo que tarda en llegar. Las de telefonía o
	      videojuegos necesitan baja latencia.
	\item Ancho de banda: Cuantos datos puede recibir y enviar. Algunas
	      necesitan mucha capacidad, otras se adaptan a lo que hay.
	\item Seguridad: Encriptado, integridad, \ldots{}
\end{itemize}

\section{2.4 DNS -- Domain Name System}

Directorio/Base de datos distribuida/espacio de nombres global, en
formato amigable para el usuario, que nos permite mediante un
protocolo obtener la IP.

Cada nombre está asignado a una IP, es una manera más intuitiva
dado que una dir IP son 32 bits, 4 números entre 0-255. No es
asequible para el usuario, por eso se crea el DNS que permite
asignar nombres a dispositivos amigables para el usuario.

Es un protocolo de la capa de aplicación.

Diagrama paquete
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Diagrama paquete DNS}}
	{\def\svgwidth{.5\textwidth}
		\input{./img/DDNS.eps_tex}}
\end{figure}
Jerarquía:

\begin{itemize}
	\item Servidor raíz: Capaces de resolver el mapeo de cualquier nombre
	      del sistema de nombres de dominio.

	      \begin{itemize}
		      \item Conoce los servidores que contienen la información de los
		            subdominios para todo el espacio de nombres.
		      \item Hay 1 maestro, pero hay muchas copias distribuidas por el mundo.
	      \end{itemize}
	\item TLD -- Top Level Domain - Dominios de alto nivel: Tienen autoridad
	      sobre todo un subdominio (.com/.edu/.es/\ldots).
	\item Autoritario: Donde se almacena la información de mapeo de nombre y
	      su IP. Conoce la IP para una determinada terminación de nombres
	      (uc3m.es) propios de la organización.
	\item Local: Fuera de la jerarquía, es el nivel más bajo. Responsable de
	      subdominios de bajo nivel. Se consulta para resolver los nombres y
	      lo poseen las empresas para su propia administración.
\end{itemize}

Resolución de nombre DNS:

\begin{itemize}
	\item Consulta iterativa:

	      \begin{itemize}
		      \item Se busca una DNS a la que queremos acceder.
		      \item Como no se conoce la IP, se llama al DNS resolver para
		            obtenerla.
		      \item Llama al server local, si la conoce nos la envía, pero si no
		            consulta al servidor raíz.
		      \item El servidor raíz nos indica el servidor que conoce ese
		            subdominio.
		      \item Accedemos a ese servidor que nos manda a otro que sepa más
		            profundo el subdominio o nos envía la IP.
	      \end{itemize}
	\item Consulta recursiva:

	      \begin{itemize}
		      \item Consiste en hacer una sola consulta y que la siguiente consulta
		            la haga el servidor consultado al siguiente en la jerarquía
		            hasta llegar al local.
	      \end{itemize}
\end{itemize}

Para introducir un nombre nuevo se llama al registrador DNS, que
introduce 2 registros en un Servidor autoritario, uno de tipo A y
otro de tipo NS.

Seguridad:

\begin{itemize}
	\item Ataques DDoS: bombardear al servidor raíz con tráfico.
	\item Ataques de redirección:

	      \begin{itemize}
		      \item Hombre en el medio: Interceptar las consultas.
		      \item Envenenamiento de DNS: send bogus relies to DNS server, which
		            caches.
	      \end{itemize}
\end{itemize}

\section{2.7 Programación de sockets: creación de aplicaciones de red}

\begin{itemize}
	\item En UDP
	\item En TCP
\end{itemize}

\chapter{TEMA 3: Transport Layer}

\section{3.1 Capa de transporte y sus servicios}
Entre la capa de red y aplicación.

Mejora la capa de red, ofrece un canal lógico de comunicación entre
aplicaciones de distintos dispositivos.

Solo está presente en los extremos, emisor y receptor.

\subsection{Acciones de los protocolos de transporte:}


Emisor: Recibe los bits del mensaje de la aplicación los segmenta y
les añade una cabecera que indica el origen y destino.

Receptor: Recibe los segmentos y los une todos para formar el
mensaje completo y lo pasa a la aplicación.


\subsection{Servicio:}


Orientado a conexiones: Se envía un mensaje de señalización y el
receptor acepta o rechaza. Si acepta se abre un canal de conexión.

No orientado a conexiones: Se abre el canal y ya. Llegan los
mensajes.


\section{Principales protocolos de transporte:}
\subsection{3.5 TCP - Transmission Control Protocol:}


Orientado a conexiones: Hace que el cliente y el servidor
intercambien la información de control de capa de transporte entre
si antes de que empiecen a fluir los mensajes del nivel de
aplicación. Este procedimiento denominado de negociación, de
reconocimiento o de establecimiento de la conexión alerta al cliente
y al servidor, permitiéndoles prepararse para el intercambio de
paquetes, se conectan los sockets del emisor y del receptor, de esta
manera lo que entra por un lado sale por el otro.

\begin{itemize}
	\item Solo soporta comunicaciones 1 a 1, un emisor y un receptor. Crea
	      un canal bidireccional entre ambos en la misma conexión.
\end{itemize}
\pagebreak
Ofrece servicio confiable, los segmentos llegan íntegros y en orden.
Se envía redundancia cíclica del mensaje en la cabecera para ver al
llegar si ha fallado o ha habido interferencias, pero no ataques
(habrían pensado en cambiarlo).

\begin{itemize}
	\item Lo malo es que parte del ancho de banda usar para redundancia,
	      si falla se reenvía y el resto de segmentos debe esperar a que
	      llegue.
\end{itemize}

Control de flujo, el emisor no satura al receptor, y congestión.

No proporciona: temporización, ancho de banda garantizado,
seguridad.

Servicio fiable de transferencia de flujos de bytes, a diferencia de
UDP que es de paquetes.

Recibe datos de la capa de aplicación y puede:

\begin{itemize}
	\item Segmentar y enviar.
	\item Esperar para hacer un paquete más grande y envía, pero crea
	      retardo si espera.
\end{itemize}

Si el paquete es demasiado pequeño, la cabecera ocupa más que los
propios datos.

\begin{itemize}
	\item Los paquetes son costosos en overhead, pero para algunas
	      aplicaciones son necesarios, ya que no pueden esperar hasta que
	      lleguen a crear un paquete más grande.
\end{itemize}

Cuanta más carga en la red es más importante la eficiencia, cuesta
más introducir paquetes al haber retraso de cola.

TCP siempre envía MSS:

\begin{itemize}
	\item MSS: Máximo tamaño de segmentación.
	\item El receptor tiene pipeline que permite una ventana deslizante de
	      tantos paquetes como quepan en el buffer, por si se corrompe
	      alguno.
	\item Usa un método parecido al Go-back N, recibe asentimiento del
	      último número de secuencia que se recibió en orden en el receptor
	      y si se pasa el temporizador envía solo el más viejo. El receptor
	      almacena en el buffer los paquetes que recibe fuera de orden, pero
	      sigue mandando la confirmación del que le falta en medio, y cuando
	      lo recibe los pasa en orden a la aplicación.
	\item La unidad fundamental de transmisión es el byte, por ello a cada
	      byte que transmita le asocia un numero de secuencia. Cuando se
	      recibe un asentimiento, se ha tenido en cuenta la suma de los
	      bytes de los datos.

	      \begin{itemize}
		      \item Si envió el paquete n.º 92 de 8 bytes, el asentimiento que reciba
		            será el n.º 100, confirmando que ha recibido esos 8 bytes.
	      \end{itemize}
\end{itemize}

Para tener n paquetes en vuelo necesitamos 2n números de secuencia.

Segmentado: el control de flujo y congestión de TCP fijan el tamaño
de la ventana. Hay buffers de emisión y recepción.

Crea un segmento con:

\begin{itemize}
	\item Puerto del origen y destino, los puertos identifican la
	      aplicación.
	\item n.º secuencia: identifica el orden y evita duplicados. El número va
	      aumentando según los bytes enviados, van asociados.
	\item n.º ack: Es el número de secuencia que espera recibir el receptor,
	      para cuando intercambiamos datos.
\end{itemize}
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Segmento TCP}}
	{\def\svgwidth{1.2\textwidth}
		\input{./img/STCP.eps_tex}}
\end{figure}
\pagebreak
En la cabecera se pone el número de secuencia del propio paquete y
además el número de secuencia que yo espero recibir si se quiere
comunicar conmigo de vuelta.

\begin{itemize}
	\item Cuando se envían datos bidireccionalmente, cada lado tiene su
	      propio número de secuencia de tal manera que cada uno controla la
	      llegada de sus propios datos y el otro confirma esos paquetes
	      recibidos.
\end{itemize}

Calcular el tiempo para el temporizador (timeout):

\begin{itemize}
	\item Debe ser más que round trip time, ida y vuelta, pero este varía.
	\item Demasiado corto: Antes de recibir la confirmación ya he reenviado
	      el paquete.
	\item Demasiado grande: Cuando no llega la confirmación espero demasiado
	      tiempo. Aunque es mejor pasarse que quedarse corto

	      $\textit{EstimatedRTT}=(1-\alpha)\cdot \textit{EstimatedRTT} + \alpha \cdot \textit{SampleRTT}$

	      $\textit{DevRTT} = (1-\beta)\cdot \textit{DevRTT} + \beta \cdot |\textit{SampleRTT}-\textit{EstimatedRTT}|$

	      $\textit{TimeoutInterval} = \textit{EstimatedRTT} + 4 \cdot \textit{DevRTT}$

	      Valor típico: $\alpha = 0,125$ y $\beta = 0,25$
	\item Cada vez que recibo un paquete, voy calculando la media ponderada
	      móvil exponencial (las más recientes influyen más) de los RTT más
	      un margen de seguridad según la variabilidad de los tiempos como
	      tiempo límite para recibir un paquete.
\end{itemize}

Emisor:

\begin{itemize}
	\item Crea un segmento con numero de secuencia según el byte del flujo
	      de bytes.
	\item Se inicia un temporizador con tiempo de expedición:
	      TimeOutArrival.

	      \begin{itemize}
		      \item Si pasa el tiempo, se reenvía y reinicia el temporizador.
		      \item Si se recibe ACK de segmentos sin confirmación, desplazo la
		            ventana, actualizo cuál es el más viejo e inicio temporizador si
		            no hay ninguno para el más viejo.
	      \end{itemize}
\end{itemize}
\pagebreak

Receptor:

\begin{itemize}
	\item Llegada de segmento en orden con el número de secuencia esperado,
	      pero ya ha sido confirmado. Se espera hasta recibir el siguiente
	      segmento, si no llega se envía ACK.

	      \begin{itemize}
		      \item El tiempo en enviar una confirmación: ¿Es de 500 ms?

		            \begin{itemize}
			            \item Cuando más grande es el tiempo que esperamos medido en número
			                  de confirmaciones de paquetes, el beneficio se va reduciendo
			                  en comparación a lo que aumenta el tiempo.
			            \item Esto nos permite ahorrar confirmaciones, que congestionan la
			                  red.
			            \item Lo mejor es enviar 1 confirmación de cada 2 paquetes.
		            \end{itemize}
	      \end{itemize}
	\item Llegada de segmento en orden con el número de secuencia esperado,
	      pero hay otro segmento en orden esperando a ser confirmado. Se
	      envía el ACK acumulativo de ambos, el más alto.
	\item Llegada de numero de secuencia fuera de orden mayor que el
	      esperado. Se manda ACK duplicado inmediatamente del último en
	      orden recibido, indicando el siguiente byte que esperamos.
	\item Llegada de segmento que completa parcialmente una laguna. Se envía
	      ACK inmediatamente, suponiendo que el segmento empieza en el
	      límite inferior de la laguna.
\end{itemize}

Retransmisión rápida: Se detectan segmentos perdidos por ACK
repetidos. Si el emisor recibe 3 ACK por los mismos datos, supone
que el segmento se ha perdido y reenvía ese segmento de inmediato,
sin esperar a que termine el temporizador.

\begin{itemize}
	\item Como el emisor envía varios segmento seguidos, si se pierde alguno
	      llegaran varios ACK repetidos.
	\item El periodo de expiración a menudo es relativamente largo, lo que
	      retrasa el reenvió de paquetes.
\end{itemize}

Cambia: Retardo -\textgreater{} Integridad.
\pagebreak

\subsection{3.3 UDP -- User Datagram Protocol:}


No orientado a conexiones: Como los sockets no están conectados, a
la hora de enviar un mensaje hay que indicar quién es el destino, no
crea un canal de comunicación.

Mejor esfuerzo.

Ofrece un servicio de comunicación no fiable, no hay garantías de
que llegue bien o en orden.

No proporciona: negociación, fiabilidad, control de flujo, control
de congestión, temporización, ancho de banda garantizado, seguridad.

La detección de errores es muy básica, avisa si hay fallos, pero no
lo resuelve.

Cabecera más ligera, a veces es mejor no hacer nada para no tener
retardo, a pesar de no asegurar integridad.

Al no haber establecimiento de la conexión, es más rápida.

Al no tener control de congestión, puede disparar todo lo rápida que
quiera.

Cabecera: Datagrama con

\begin{itemize}
	\item Puerto de origen y destino.
	\item Length: Longitud en bytes del segmento UDP con el header.
	\item Checksum: Detectar errores, pero no los solventa.
	      \begin{figure}[H]
		      \ffigbox[\FBwidth]
		      {\caption{Diagrama paquete UDP}}
		      {\def\svgwidth{.5\textwidth}
			      \input{./img/DUDP.eps_tex}}
	      \end{figure}
\end{itemize}

Es utilizado para las DNS, para no sobrecargar los servidores raíz
(no hay que enviar mensaje de solicitud para abrir conexión), como
la integridad es importante la integridad a nivel de aplicación si
falla o está corrupta se vuelve a hacer una consulta.

Cambia: Integridad -\textgreater{} Retardo.

UDP checksum: Numero añadido en el segmento de transporte para
detectar errores. El emisor crea el checksum, el receptor lo
recalcula y compara si son distintos, si lo son correcto y si no hay
algún error.

\begin{itemize}
	\item El emisor trata el contenido del segmento UDP (que incluye los
	      campos de la cabecera UDP y las direcciones IP) como secuencias de
	      16 bits enteros.
	\item Se van sumando los segmentos desde el primero de 16 en 16 bits, y
	      si sale alguno de 17 bits cogemos el más significativo y se lo
	      sumamos al mismo, 1º+2º, (1º+2º)+3º\ldots. Cuando hemos sumado
	      todos hacemos complemento a uno, los 1 por 0 y 0 por 1.
\end{itemize}

\subsection{3.2 Multiplexación/ Demultiplexación:}


El emisor multiplexa, añade la cabecera de transporte para ser
demultiplexada después y vaya al socket correcto.
El receptor demultiplexa, deshace la cabecera del segmento para
entregarlo al socket correcto.

\begin{itemize}
	\item Cada datagrama de la capa de red tiene la IP origen y destino con
	      el correspondiente puerto de cada lado que identifica el socket.
\end{itemize}

\subsection{3.4 Principios de transferencia de datos confiable:}

Los servicios de transferencia confiable, consiguen que los datos
lleguen y sin fallos.

Para la capa de aplicación es como pasar los datos a un canal
confiable, pero la capa de transporte realiza un protocolo para la
transferencia de datos confiable y lo pasa a un canal no confiable o
lo recibe de un canal no confiable(según el lado).

Las características del canal no fiable determinarán la complejidad
de transferencia de datos fiable.

Terminología:

\begin{itemize}
	\item rdt\_sent(): Pasa los datos la aplicación a la capa de transporte.
	\item udt\_send(): La capa de transporte transfiere el paquete por el
	      canal no confiable al receptor (capa red).
	\item rdt\_rcv(): Cuando el paquete llega al extremo de recepción del
	      canal (red -\textgreater{} transporte)
	\item deliver\_data(): La capa de transporte pasa los datos a la
	      aplicación.
\end{itemize}

Se desarrollan los lados de emisor y receptor incrementalmente, se
imponen una solución simple y vamos levantando la simplicidad con
problemas del canal.

Consideramos solo transferencia de datos unidireccional, pero
funciona bidireccional de igual manera, es para simplificar.

Se usan máquinas de estado finitas para representar emisor y
receptor por separado: evento/acciones tomadas.

\subsubsection{rdt1.0: transferencia fiable en canal fiable.}

Sin errores de bit, ni perdida de paquetes.

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{rdt1.0}}
	{\def\svgwidth{.9\textwidth}
		\input{./img/rdt1.eps_tex}}
\end{figure}

Emisor:

\begin{itemize}
	\item Espera los datos de la aplicación, cuando los recibe crea un
	      paquete y envía el paquete por el canal no confiable.
\end{itemize}

Receptor:

\begin{itemize}
	\item Espera recibir paquete, cuando lo recibe extrae los datos y los
	      pasa la aplicación.
\end{itemize}
\subsubsection{rdt2.0: canal con errores de bit.}

El canal puede alterar bits del paquete, para eso se usa el
checksum y se detectan.

Para resolver los errores, se usa:

\begin{itemize}
	\item Asentimiento, confirmación o reconocimiento (Acknowledgements,
	      ACK): El receptor indica que la recepción fue buena.
	\item Asentimiento negativo o reconocimiento negativo (NAK): El
	      receptor indica que el paquete tenía errores. En este caso el
	      emisor reenvía el paquete.
\end{itemize}

Protocolo de parada y espera (stop and wait): Si se corrompe se
envía una señal de respuesta negativa y el emisor envía de nuevo,
si llega bien una respuesta positiva.
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{rdt2.0}}
	{\def\svgwidth{.9\textwidth}
		\input{./img/rdt2.0.eps_tex}}
\end{figure}
Emisor:

\begin{itemize}
	\item Espera recibir datos de la aplicación, cuando los recibe calcula
	      el checksum y crea un paquete que incluye el checksum, entonces
	      lo envía
	\item Espera un paquete del receptor ACK o NAK, si recibe ACK pasa a
	      esperar datos de la aplicación, si recibe NAK envía de nuevo el
	      paquete y espera otra vez ACK o NAK.
\end{itemize}

Receptor:

\begin{itemize}
	\item Espera un paquete del emisor, cuando lo recibe comprueba los
	      datos con el checksum, si coincide envía ACK y pasa los datos a
	      la aplicación, y si no coincide envía NAK.
\end{itemize}

Pero qué pasa si se corrompe un asentimiento, no podemos asumir
ACK (se pierden paquetes), ni NAK (se duplican paquetes). Para
solucionarlo rdt2.1
\pagebreak
\subsubsection{rdt2.1: canal con errores de bit y manejo de ACK/NAK erróneos.}


El emisor retransmite el paquete actual si ACK o NAK si no llegan
bien.

El emisor añade un numero de secuencia a cada paquete, para
detectar si se repite el paquete cuando se recibe.

Emisor:
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{rdt2.1: Emisor}}
	{\def\svgwidth{.9\textwidth}
		\input{./img/rdt2.1E.eps_tex}}
\end{figure}
\begin{itemize}
	\item Espera datos de la aplicación para poner el número de secuencia
	      0, cuando los recibe crea un paquete con el checksum, datos y el
	      0.
	\item Espera recibir asentimiento con 0, si recibe ACK y no está
	      corrupto pasa a espera datos para poner 1, si recibe NAK o está
	      corrupto reenvía el paquete con 0.
	\item Espera datos de la aplicación para poner 1, cuando los recibe
	      crea un paquete con el checksum, datos y el 1
	\item Espera recibir asentimiento con 1, si recibe ACK y no está
	      corrupto pasa a espera datos para poner 0, si recibe NAK o está
	      corrupto reenvía el paquete con 1.
\end{itemize}

\pagebreak
Receptor:
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{rdt2.1: Receptor}}
	{\def\svgwidth{1.1\textwidth}
		\input{./img/rdt2.1R.eps_tex}}
\end{figure}
\begin{itemize}
	\item Espera paquete con numero de secuencia 0:

	      \begin{itemize}
		      \item Cuando recibe un paquete comprueba que el checksum no esté
		            corrupto y numero de secuencia 0, si están bien ambos pasa los
		            datos a la aplicación y crea un paquete con ACK y su checksum,
		            por último, pasa a esperar un 1.
		      \item Cuando recibe un paquete si no coincide el checksum con los
		            datos, se envía NAK con su checksum, y sigue esperando un 0.
		      \item Cuando recibe un paquete no corrupto (checksum correcto) y el
		            número de secuencia es 1, se crea un paquete con ACK y su
		            checksum (estaba duplicado)
	      \end{itemize}
	\item Espera paquete con numero de secuencia 1:

	      \begin{itemize}
		      \item Cuando recibe un paquete comprueba que el checksum no esté
		            corrupto y número de secuencia 1, si están bien ambos pasa los
		            datos a la aplicación y crea un paquete con ACK y su checksum,
		            por último, pasa a esperar un 0.
		      \item Cuando recibe un paquete si no coincide el checksum con los
		            datos, se envía NAK con su checksum, y sigue esperando un 1.
		      \item Cuando recibe un paquete no corrupto (checksum correcto) y el
		            número de secuencia es 0, se crea un paquete con ACK y su
		            checksum (estaba duplicado)
	      \end{itemize}
\end{itemize}
\pagebreak
\subsubsection{rdt2.2: Un protocolo sin NAK.}


La misma funcionalidad que rdt2.1, usando solo ACK

En lugar de NAK, el receptor envía ACK para el último paquete
recibido bien indicando el número de secuencia del mismo.

Por lo tanto, el emisor si recibe un ACK de numero de secuencia
incorrecta es NAK y retransmite.

\subsubsection{rdt3.0: Canales con errores y perdidas.}

El emisor espera un tiempo razonable para recibir el asentimiento,
si no se ha perdido.

El tiempo de espera es el round trip time, el tiempo que tarda un
paquete en ir y volver.

Si se pasa el tiempo se reenvía, y si se reenvió antes de tiempo
el número de secuencia lo identifica.

Usa números de serie, temporizador y checksum.

Emisor:

\begin{itemize}
	\item Esperar datos para poner el 0, se reciben datos:

	      \begin{itemize}
		      \item Si se reciben datos de la aplicación se crea un paquete con el
		            checksum y número de serie 0, se inicia un temporizador y se
		            envía el paquete.
		      \item Si se recibe un paquete del receptor no se hace nada.
	      \end{itemize}
	\item Esperar asentimiento 0, se recibe un paquete del emisor:

	      \begin{itemize}
		      \item Si está corrupto el paquete o el número de serie recibido es
		            1, no se hace nada.
		      \item Si se pasa el temporizador se reenvía el paquete.
		      \item Si no está corrupto y el número de serie es 0, se para el
		            temporizador y pasamos a esperar datos de la aplicación para
		            poner un 1.
	      \end{itemize}
	\item Esperar datos para poner el 1, se reciben datos:

	      \begin{itemize}
		      \item Si se reciben datos de la aplicación se crea un paquete con el
		            checksum y número de serie 1, se inicia un temporizador y se
		            envía el paquete.
		      \item Si se recibe un paquete del receptor no se hace nada.
	      \end{itemize}
	\item Esperar asentimiento 1, se recibe un paquete del emisor:

	      \begin{itemize}
		      \item Si está corrupto el paquete o el número de serie recibido es
		            0, no se hace nada.
		      \item Si se pasa el temporizador se reenvía el paquete.
		      \item Si no está corrupto y el número de serie es 1, se para el
		            temporizador y pasamos a esperar datos de la aplicación para
		            poner un 0.
	      \end{itemize}
\end{itemize}

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{rdt3.0}}
	{\def\svgwidth{1.2\textwidth}
		\input{./img/rdt3.eps_tex}}
\end{figure}

Receptor: Es igual que en rdt2.2, se envía asentimiento positivo
con checksum y numero de secuencia.

\begin{itemize}
	\item Espero paquete con 0, recibo paquete del emisor:

	      \begin{itemize}
		      \item Está corrupto el paquete o número de serie 1, envía de nuevo
		            la confirmación anterior para que mande de nuevo el paquete 0
		            o el siguiente.
		      \item Si no está corrupto y es un 0, pasamos los datos a la
		            aplicación y enviamos al emisor el asentimiento con 0 y su
		            checksum.
	      \end{itemize}
\end{itemize}

El problema de este mecanismo es el rendimiento, está la mayor
parte del tiempo esperando respuesta.


\subsubsection{Protocolos segmentados (pipelined protocols)}
Se amplía el número de serie que se envía lo que nos permite
aumentar el número de paquetes en vuelo.

Aunque necesitamos un buffer más grande en el emisor y/o el
receptor.

Ventana: Numero de paquetes que puede haber en vuelo, sin
confirmación.

Ventana deslizante: Se va olvidando de los confirmados y envía
otro según confirma.

\paragraph{Go-Back-N}



En el emisor hay un buffer y temporizador asociado a cada
paquete.

\begin{itemize}
	\item Si se pasa el tiempo reenvía todos los paquetes desde el más
	      viejo.
	\item Según van llegando se desplaza la ventana y envía nuevos.
	\item Acepta duplicados, cuando recibe muchos iguales acabara el
	      temporizador porque se ha perdido alguno.
\end{itemize}

En el receptor, solo sabe el paquete que está esperando, si
llega lo pasa a la aplicación, pero si no es el esperado lo
almacena en buffer o lo deja pasar.

\begin{itemize}
	\item Se tiene un ACK acumulativo, le dice al emisor que ha recibido
	      correctamente hasta cierto número de secuencia, el último en
	      orden de secuencia. Mantiene el número 2 si no ha llegado,
	      aunque reciba el 3 y 4.
\end{itemize}

Una ventaja es que, si se pierden confirmaciones, pero se recibe
una con numero de secuencia superior antes de que pase el
tiempo, el emisor entenderá que las perdidas han sido recibidas.

\paragraph{Repetición selectiva (Selective repeat}

Ventana de n paquetes, a cada uno con un temporizador y voy
corriendo la ventana cuando se confirman y si no se confirman lo
reenvía.

El emisor solo reenvía paquetes para los que no reciba ACK,
según se van recibiendo se va desplazando la ventana.

El receptor envía ACK individual para cada paquete correcto, a
diferencia de GBN no se queda solo con el número de secuencia
del último correcto consecutivo. No mantiene numero 2 si recibe
el 3 y 4, aunque no haya recibido el 2.

\begin{itemize}
	\item En un buffer voy almacenando los paquetes que llegan en
	      desorden y cuando tengo todos se pasan a la app.
\end{itemize}

Dilema: Como no necesariamente los acepta en orden, puede
ocurrir que, al perderse todos los paquetes aceptados, aceptemos
como nuevo los paquetes reenviados por el emisor al tener
números de serie que correspondan a la ventana del receptor.


Cada socket tiene asociado un buffer.

El control de flujo y congestión reducen la velocidad de
transmisión, para no saturar la red.

$$TCP = \frac {nºpaquetes\cdot MSS}{RTT}$$

Control de flujo: El emisor no saturará el buffer del receptor a
base de enviar muchos paquetes seguidos. Se equilibra la velocidad
de envío a la del receptor.

\begin{itemize}
	\item El emisor debe controlar su velocidad de emisión para no saturar
	      al receptor, para ello el receptor va enviando en sus
	      confirmaciones cuanto buffer tiene libre, de esta manera se
	      adapta.
	\item La velocidad de recepción de paquetes viene dada por el emisor, si
	      el receptor capta los datos más lentos o tiene poco buffer, empieza
	      a perder paquetes al no caber.
	\item Recibe más de lo que puede procesar.
\end{itemize}

\subsection{3.6 Principios del control de congestión}

Congestión: hay más tráfico en una parte de la red de lo que es
capaz de soportar.

\begin{itemize}
	\item Normalmente son los enlaces los que se congestionan, cuando la
	      multiplexación estadística se ve superada.
	\item A diferencia del control de flujo, la congestión es de la red, no
	      del receptor.
\end{itemize}

Síntomas:

\begin{itemize}
	\item Perdida de paquetes.
	\item Grandes retardos.
\end{itemize}

Tipos:

\begin{itemize}
	\item Congestión crónica: Continúa en el tiempo, que dura. Se puede
	      solucionar incrementando la capacidad, más enlaces.
	\item Congestión puntual: Momentánea. Se soluciona reduciendo la
	      demanda, hacer que se envíe menos.
\end{itemize}

Formas de abordarla:

\begin{itemize}
	\item Control de terminal a terminal: No hay retroalimentación de la
	      red, se deduce por el retardo y las perdidas. Es el método de TCP.
	\item Control asistido por la red: Los routers proporcionan
	      realimentación a los terminales. Indican a que tasa deben enviar
	      los emisores.
\end{itemize}

\subsection{3.7 Mecanismos de control de congestión de TCP}


No se conoce como de congestionada esta la red, por lo que se va
incrementando la tasa de transmisión poco a poco y cuando hay
perdidas vuelvo a reducir.

\begin{itemize}
	\item Es autocongestionante, lo sube hasta que se congestiona.
\end{itemize}

Incremento aditivo: Incrementamos el tamaño de ventana en 1 MSS cada
RTT hasta que haya perdidas. +1 tamaño ventana

Decremento multiplicativo: Dividimos el tamaño de ventana por 2
cuando haya perdidas. Ventana/2

\begin{itemize}
	\item En AIMD, corta por la mitad cuando recibe 3 ACK del mismo paquete
	      y quita 1 cuando expira un temporizador.
\end{itemize}

AIDM: Algoritmo asíncrono distribuido para optimizar los ratios de
congestión de la red y tienen propiedades de estabilidad.

$$Tasa TCP \approx \frac {cwnd} {RTT} \frac {bytes}{sec}$$

El emisor limita la transmisión: LastByteSent- LastByteAcked
\textless{} cwnd

ACK duplicados: Congestión moderada. Bajamos a la mitad +3 y
subimos poco a poco. El umbral también se reduce a la mitad.

Detectamos perdida por temporizador: Congestión severa. Bajamos el
tamaño de ventana a 1 y volvemos a aumentar exponencialmente. El
umbral se reduce a la mitad.

Arranque lento: Comienza con tamaño de ventana pequeña, 1 MSS, pero
no solo aumentan de 1 en 1, se va doblando por cada RTT hasta llegar
a ssthresh (la mitad del valor de la ventana antes de la última
perdida) y después continua linealmente hasta perdida.

The Maximum Segment Size (MSS) is set to 1 in TCP Reno and Tahoe, in
case of timeout detection, as the congestion is severe. However, in
case of even less severe congestion detected by triple duplicate
acknowledgement, the MSS size is reduced to 1 in TCP Tahoe and half
in TCP Reno.
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Control de congestión TCP}}
	{\def\svgwidth{.9\textwidth}
		\input{./img/congestionTCP.eps_tex}}
\end{figure}
En arranque lento aumenta uno por cada segmento de la ventana, lo
que al ocurrir para toda la ventana duplica.

En evitación de congestión aumenta 1/ tamaño de la ventana, lo que
hace que cuando se haya confirmado toda la ventana habrá aumentado
uno completo.

\chapter{TEMA 4: Network Layer Data Plane}

\section{4.1 Overview of Network layer}

Capa de red:

\begin{itemize}
	\item Ofrece un canal lógico de comunicación entre hosts -- anfitriones
	      conectados por un medio físico. Entrega los paquetes al destino
	      indicado por su dirección IP, con los saltos que sean necesarios.
	\item Utiliza los servicios de la capa de enlace y los mejora para
	      ofrecer mejor servicio a la capa de transporte.
	\item Transporta segmentos del host emisor al receptor.

	      \begin{itemize}
		      \item El emisor encapsula los segmentos en datagramas. Pone la
		            dirección IP del dispositivo destino.
		      \item El receptor entrega los segmentos a la capa de transporte.
	      \end{itemize}
	\item Está presente en Routers y Hosts.
	\item El router examina los campos de la cabecera de todos los
	      datagramas IP, para determinar a donde se debe enviar y cuál será
	      el siguiente salto, pero la IP no cambia.
	\item Visión como dos planos:

	      \begin{itemize}
		      \item Plano de datos: Hace Forwarding, decide por qué puerto de salida
		            deben ir los datos de entrada.
		      \item Plano de control: Información de control que se transmite entre
		            routers para controlar la red, configurar las tablas de
		            forwarding y las del propio router. Dos aproximaciones:

		            \begin{itemize}
			            \item Algoritmo distribuido de routing tradicional: Todos los router
			                  se comunican entre ellos para configurarse.
			            \item Red definida por software: Centralizado. Hay un proceso
			                  central, que conoce el estado toda la red, para configurar el
			                  estado de cada router.
		            \end{itemize}
	      \end{itemize}
\end{itemize}

Funciones clave: Que deben ser consistentes para no crear bucles.

\begin{itemize}
	\item Reenvío: Mover los paquetes de la entrada a la salida apropiada.
	\item Enrutamiento: Determinar la ruta a tomar por los paquetes, desde
	      el origen a destino.
\end{itemize}

Modelo de servicio de red:

\begin{itemize}
	\item Posibles servicios:

	      \begin{itemize}
		      \item Para datagramas individuales: Entrega garantizada o Retardo
		            acotado.
		      \item Para un flujo de datagramas: Datagramas en orden, Ancho de banda
		            mínimo o restricción en la fluctuación entre paquetes.
	      \end{itemize}
	\item Modelo de servicio de \enquote{mejor esfuerzo}:

	      \begin{itemize}
		      \item No garantiza: Entrega garantizada al destino, en orden,
		            temporización ni ancho de banda garantizado.
		      \item Ventajas:

		            \begin{itemize}
			            \item Es simple, por lo que es robusto y es ampliamente usado.
			            \item Ofrece los servicios esenciales comunes para las aplicaciones,
			                  y si quieren más servicios los implementan ellos mismos.
			            \item Aprovechamiento suficiente de ancho de banda para aplicaciones
			                  en tiempo real.
			            \item Servicios distribuidos de capa de aplicación replicados que se
			                  conectan cerca de las redes de los clientes, permiten que los
			                  servicios se den desde varias ubicaciones.
			            \item El control de congestión de los servicios ayuda.
		            \end{itemize}
	      \end{itemize}
\end{itemize}

Protocolos de la capa de red:

\begin{itemize}
	\item Algoritmos de selección de camino: Protocolos de enrutamiento.
	\item Protocolo ICMP: Señaliza errores.
	\item Protocolo de Internet -- IP: Formato del datagrama,
	      direccionamiento y convenciones de manejo de paquetes.
\end{itemize}

\section{4.2 What's inside a Router}
\subsection{Arquitectura del router}
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Arquitectura del router}}
	{\def\svgwidth{.8\textwidth}
		\input{./img/ArqRouter.eps_tex}}
\end{figure}
Funciones del Puerto de entrada: 3 capas.
\begin{itemize}
	\item Física: Transforma los impulsos de luz a bits.
	\item Enlace: Procesa la capa de enlace.
	\item Tiene un buffer y la capacidad de hacer forwarding, es decir
	      consultar el puerto de salida en las tablas de forwarding que nos
	      indica a donde deben ir. El forwarding puede ser:

	      \begin{itemize}
		      \item Basado en el destino: Basado solo en la dirección IP destino.
		      \item Generalizado: Basado en campos de la cabecera.
	      \end{itemize}
\end{itemize}

Matrices de conmutación: Permite hacer forwarding, lleva paquetes
del puerto de entrada a los de salida adecuado.

\begin{itemize}
	\item Tipos:

	      \begin{itemize}
		      \item De memoria: Bajo el control de la CPU, los paquetes se copian en
		            memoria y la velocidad está limitada por el ancho de banda de
		            memoria.
		            \begin{itemize}
			            \item Llega un paquete a la entrada.
			            \item Se pasa a memoria.
			            \item Se determina la salida.
			            \item Se saca el paquete de memoria y se lleva a la salida correcta.
		            \end{itemize}
		      \item De bus: Cada puerto tiene capacidad de memoria y procesamiento,
		            y usa el bus para pasar de entrada a salida.
		            \begin{itemize}
			            \item Hay limitación por el ancho de banda del bus.
			            \item Para no saturar el bus: el ancho de banda del bus
			                  \textgreater= número de puertos de entrada*ancho de banda del
			                  puerto de entrada.
			            \item Para no saturar la salida: ancho de banda de las entradas
			                  \textless= ancho de banda de las salidas
		            \end{itemize}
		      \item Red de interconexión: Caminos paralelos, todos conectados con
		            todos, pero es caro tener una conexión entre cada uno.

		            \begin{itemize}
			            \item Para evitar que se haga tan caro, se usan múltiples planos
			                  para tener más caminos.
		            \end{itemize}


	      \end{itemize}
\end{itemize}

Procesador de routing: Calcula la ruta, enruta.

Puerto de salida: 3 etapas.

\begin{itemize}
	\item Buffer sobre todo, para almacenar los paquetes que hay que sacar a
	      la red que han llegado más rápido que la velocidad de transmisión.

	      \begin{itemize}
		      \item Administración del buffer: Hay una cola de paquetes, cuando se
		            llena se pierden los que no entran o los de menor prioridad.
		            Estrategias:

		            \begin{itemize}
			            \item FCFS - Primero en Llegar, Primero en Servir: En orden de
			                  llegada al puerto de salida.
			            \item Prioridad: Puede haber dos o más colas, una de alta y otra de
			                  baja prioridad. Tipos:

			                  \begin{itemize}
				                  \item Primero se pasan los de alta prioridad y luego los otros.
				                  \item Cada n paquetes prioritarios, se cogen 1 no prioritario.
			                  \end{itemize}
			            \item Round Robin: Varias colas y va rotando, se coge uno de cada
			                  cola.

			                  \begin{itemize}
				                  \item Se hace de forma equitativa y la prioridad la da un campo de
				                        la cabecera.
			                  \end{itemize}
			            \item Weighted Fair Queueing -- Espera equitativa Ponderada: Como
			                  round robin, pero según el peso de cada cola, se cogen más o
			                  menos paquetes de esa cola en la rotación.
		            \end{itemize}
	      \end{itemize}
	\item Enlace.
	\item Física: Pasa bits a pulsos de luz.
\end{itemize}
\pagebreak
\section{4.3 The Internet Protocol (IP): IPv4, Addressing, IPv6, and More}
\subsection{IP: Protocolo de Internet}

Es un protocolo no confiable.

Formato:
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Diagrama mensaje IP}}
	{\def\svgwidth{\textwidth}
		\input{./img/DIP.eps_tex}}
\end{figure}
\begin{itemize}
	\item Cabecera: 20 bytes IP.

	      \begin{itemize}
		      \item Versión del protocolo: 4 32 bits y 6 128 bits.
		      \item Longitud de la cabecera en bytes.
		      \item Tipo de servicio: Permite indicar la prioridad.
		      \item Longitud total del paquete.
		      \item Identificar de 16 bits, flags y offset, para identificar los
		            fragmentos de un mismo paquete al fragmentar.

		            \begin{itemize}
			            \item Id: Es fijo para el paquete.
			            \item Flag: 1 si hay más fragmentos y 0 si es el último.
			            \item Offset: Identifica el desplazamiento dentro del paquete
			                  fragmentado.
		            \end{itemize}
		      \item Tiempo de vida: máximo número de saltos de paquete, va bajando
		            según salta. Es mucho mayor que los salto de la óptima. Si se
		            acaba es un problema grave, ya que no es capaz de llevar los
		            paquetes al destino.
		      \item Protocolo de la capa superior: TCP o UDP.
		      \item Checksum de la cabecera.
		      \item IP origen.
		      \item IP destino.
	      \end{itemize}
	\item Segmento
\end{itemize}

Fragmentación y Reensamblado.

\begin{itemize}
	\item Los enlaces tienen un máximo de tamaño de transferencia -- MTU.
	\item Los datagramas IP cuando son grandes, se fragmentan en la red (en
	      cualquier dispositivo de la red) y cuando llega al destino se
	      reensambla.
	\item Cada fragmento tiene en la cabecera un identificador que indica a
	      que paquete corresponde y cuál es de todos.
\end{itemize}

\subsection{Direccionamiento}

Pasos para asignar direcciones a una topología con subredes dadas:

\begin{enumerate}
	\def\labelenumi{\arabic{enumi}.}
	\item Calcular el número de IP que necesita cada red,
	      \#hosts+\#routers+1 de red+1 de broadcast
	\item Calcular el prefijo de cada red.

	      \begin{itemize}
		      \item /32 1, /31 2, /30 4, /29 8, /28 16, /27 32, /26 64, /25 128, /24
		            255\ldots{}
	      \end{itemize}
	\item Asignar IP con la tabla, dividiendo y viendo donde comienza cada
	      bloque de IP.
\end{enumerate}

Maneras de obtener la dirección IP:

\begin{itemize}
	\item Configurar el dispositivo manualmente.
	\item DHCP, se asignan de forma dinámica.
\end{itemize}

Necesitamos un espacio o sistema de nombres para identificar los
elementos de la red con un nombre único.

En internet se le asigna una dirección IP a cada interfaz.

\begin{itemize}
	\item 4 bytes separados por puntos, valores entre 0-255, en total 32
	      bits.

	      \begin{itemize}
		      \item 1.1.1.1= 00000001. 00000001.00000001.00000001
	      \end{itemize}
	\item Hay \(2^{32}\) posibles valores, el tamaño máximo de internet.
	\item Cuando enviamos un paquete la IP se pone en la cabecera IP, para
	      identificar al destinatario de forma única.
\end{itemize}

Tabla de Forwarding/reenvío:

\begin{itemize}
	\item Columnas: Destino DEST y Siguiente salto NH (y Distancia, nos la
	      dan o nos la inventamos y nos sirve para ordenar de menor a mayor
	      distancia)
	\item En DEST se pone la IP de la red, es decir la de todo 0's con su
	      prefijo.
	\item En NH:

	      \begin{itemize}
		      \item Si hay conexión directa, no se pone NADA, lo asigna el propio
		            dispositivo.
		      \item Si no es directa la conexión, se pone la dirección asignada a la
		            entrada del router que lleva a esa red.

		            \begin{itemize}
			            \item Poner redundancia consiste en poner para el mismo DST varias
			                  direcciones de salto.
			            \item Se pone la dirección de la red, la global, para todas las
			                  direcciones de las redes.
		            \end{itemize}
	      \end{itemize}
	\item Los DEST se ordenan de mayor a menor longitud de prefijo, y en
	      caso de que haya varios con el mismo se ordenan entre ellos de
	      menor a mayor distancia.
	\item La tabla de los dispositivos de una red es: Se pone la de la red y
	      no se configura (vacía), y en la global de la red se pone la de
	      salida.
\end{itemize}

Dos interfaces que no están en la misma red tendrán que usar al
menos un router.

\begin{itemize}
	\item Para ver el número de redes eliminamos los router y cada medio
	      físico aislado es una red.
	\item En cada red necesitamos 1 para cada host, 1 para cada router, 1
	      para la propia red todo 0's (la propia red) y 1 de broadcasts más
	      todo 1's (referirnos a todos los dispositivos).

	      \begin{itemize}
		      \item \#dirs=\#hosts+\#routers+2
		      \item 60 dispositivos en una red=60+3= 63 direcciones IP necesita.
	      \end{itemize}
\end{itemize}

En una red con 256 dirs. puede haber 254 routers y 253 si tiene que
conectarse con el exterior.

Enlace punto a punto: Conecta 1 a 1, no 1 a n o n a 1. No es un
medio compartido.

Cuando un paquete llega al router, se lee la cabecera IP, se extrae
la dirección IP y se consulta la Tabla de forwarding (Contiene:
Destino y Siguiente salto) donde indica según la IP que entrada debe
tomar el paquete.

\begin{itemize}
	\item No es factible que se almacene un valor para cada posible valor de
	      IP, por tanto, se agrupan IP según la entrada.
	\item Todas las IP del conjunto tomarán la misma entrada y esos
	      dispositivos deben tener una propiedad topológica para que envíe quien
	      lo envié llegue.
\end{itemize}

CIDR - Classless InterDomain Routing: Porciones de la subred de
longitud arbitraria

La IP se asigna a la interfaz del dispositivo, no al propio
dispositivo.

\begin{itemize}
	\item Un mismo dispositivo puede tener varias interfaces.
\end{itemize}

Red: Conjunto de interfaces conectadas por un medio físico.


Hay que repartir las direcciones entre las distintas redes, cada red
tiene su propio conjunto para las interfaces que lo forman.



\subsection{DHCP -- Dynamic Host Configuration
	Protocol:}

El host obtiene la dirección IP del servidor cuando entra en la red.

Proceso:

\begin{itemize}
	\item El host envía un mensaje a toda la red, para descubrir los DHCP
	      server.
	\item Un DHCP recibe el mensaje, entonces ofrece al host una dirección IP.
	\item Recibimos esa dirección IP y se la confirmamos a DHCP.
	\item DHCP envía un asentimiento de que ha recibido la confirmación y nos
	      la ha asignado.
\end{itemize}

No solo envía la dirección IP, también:

\begin{itemize}
	\item La dirección del primer salto a router del cliente.
	\item Nombre y dirección del servidor DNS.
	\item La máscara de red.
\end{itemize}

La IP asignada es única en el sentido que no puede haber 2 usándola
simultáneamente, pero en otro momento puede haber dispositivos que
hayan usado la misma.

Hay una jerarquía en la red, lo que permite que los cambios de IP se
hagan de una forma más eficiente. Una parte importante figura son los
ISP -- Internet Service Provider.

ICANN -- Internet Corporation for Assigned Names and Numbers: Asigna
los bloques de direcciones a los ISP, gestiona las DNS y dominios.

\begin{itemize}
	\item Hay 5 registros regionales, distribuidos por el mundo.
	\item En 2011 asignaron el último bloque de direcciones IPv4.
	\item Gracias a NAT e IPv6 se solucionan las limitaciones de las IP.
\end{itemize}


\subsection{NAT -- Network Address
	Translation:}


Para una misma red todos los dispositivos comparten la misma IPv4 a
ojos del resto de internet.

Cada dispositivo de la red se diferencia con un puerto, ya que tienen
la misma IP entre ellos.

Todos los dispositivos en la red local tienen una dirección de 32 bits
en un espacio de direcciones privado (10/8, 172.16/12, 192.168/16
prefijos) que solo puede ser usada en esa red.

Ventajas:

\begin{itemize}
	\item Con una sola IP, da servicio a todos los dispositivos del ISP.
	\item Cambiar la IP local no afecta fuera de la propia red.
	\item Cuando cambia la IP del ISP, no afecta a los dispositivos y su
	      dirección privada.
	\item Es más seguro, no se puede direccionar un dispositivo directamente
	      desde fuera de la red.
\end{itemize}

Implementación:

\begin{itemize}
	\item Hace falta cambiar la dirección IP en los datagramas de salida y
	      entrada a la IP de NAT, al igual que puertos.
	\item Hay una tabla de correspondencia de IP y puerto local -- IP y puerto
	      NAT.
	\item Traduce IP y puerto local al de NAT y viceversa, mediante la Tabla
	      de NAT.
\end{itemize}
\pagebreak

Controversia:

\begin{itemize}
	\item Los routers deben solo procesar hasta el nivel 3, pero si alteran el
	      puerto deben llegar a la 4.
	\item Cuando faltan direcciones se deben usar las direcciones IPv6, en vez
	      de NAT.
	\item Los extremos son los únicos que deben poder alterar los puertos.
\end{itemize}

A pesar de los inconvenientes se usa NAT en muchos ámbitos.


\subsection{IPv6:}



Surge de la limitación de 32 bits de IPv4, ya que actualmente hay
mucha variedad de dispositivos con su propia IP.

Se pasa de 32 a 128 bits.

Además:

\begin{itemize}
	\item Mejora la velocidad de enviado y procesado. Protocolo más eficiente.
	      Para ello opta por una cabecera fija de 40 bytes.
	\item Permite tratar los flows en distintas capas. Esto mejora el
	      tratamiento de la comunicación de las aplicaciones de tiempo real.
\end{itemize}

Formato del datagrama:
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Formato del datagrama IPv6}}
	{\def\svgwidth{.9\textwidth}
		\input{./img/DIPv6.eps_tex}}
\end{figure}

\begin{itemize}
	\item Cabecera

	      \begin{itemize}
		      \item Versión del protocolo.
		      \item Prioridad, dar mejor servicio según la prioridad.
		      \item Etiqueta de Flow, identifica los datagramas dentro del Flow.
		      \item Longitud del datagrama completo.
		      \item Next hdr.
		      \item Límite de saltos del datagrama, si se sobrepasa se descarta.
		      \item Dirección IPv6 origen.
		      \item Dirección IPv6 destino.
	      \end{itemize}
	\item Datos -- payload
	\item No tiene: Checksum, fragmentación y reensamblado y tampoco opciones
	      extra.
\end{itemize}

Transición

\begin{itemize}
	\item Conviven ambos protocolos gracias al tunneling.
	\item No todos los dispositivos pueden hacer esta mejora.

	      \begin{itemize}
		      \item El 30\% de los clientes acceden a Google de esta manera.
		      \item 1/3 de los dominios del gobierno de los estados unidos son
		            capaces.
	      \end{itemize}
	\item Se han tardado 25 años hasta este punto, pero todavía queda.
	\item Tunneling:
	      \begin{itemize}
		      \item Los datagramas de IPv6 se encapsulan en datagramas de tipo IPv4
		            como datos, para ser gestionado por los dispositivos que admiten
		            solo IPv4.
		      \item Se crea un túnel por los routers de versión 4 indicando hasta
		            donde mantenerlo, y cuando se pasa se deshace el encapsulado y se
		            sigue pasando IPv6.
	      \end{itemize}
\end{itemize}

El protocolo IP es la única de su capa, a diferencia del resto de
capas que tienen muchas alternativas. IP debe estar implementada en
todos los dispositivos.
\begin{itemize}
	\item A veces se necesitan otros elementos para resolver ciertos problemas
	      de IP, como NAT o Firewalls. Ya sea por limitación de direcciones o
	      la mejora de la eficiencia.
\end{itemize}

\subsection{Principio arquitectónico de Internet:}

\begin{itemize}
	\item El objetivo de internet, era la conectividad, mediante el Internet
	      Protocol y la gestión/inteligencia se hará en los extremos y no
	      oculta en la red.
	\item El end-end argument: Dice que la complejidad o lógica de la
	      conectividad se puede implementar en los extremos en vez de
	      soportarla la red.
	\item Se puede ver en la capa de protocolos, los extremos hacen la
	      comunicación y la red se queda en las 3 primeras.
	\item Aunque algunas funcionalidades pueden implementarse en la red, como
	      congestión o transferencia fiable.
	\item ICMP -- Internet Control Message Protocol: Protocolo que utilizan
	      los dispositivos con los routers y viceversa para comunicar
	      información a nivel de red, ya sean errores o llegadas de datos
	      (ping).

	      \begin{itemize}
		      \item Contenido del mensaje: Tipo, código y los 8 primeros bytes del
		            datagrama IP que causa el error.
		      \item Relación con Traceroute:

		            \begin{itemize}
			            \item Envía 3 paquetes por iteración, según progresan las iteraciones
			                  se va aumentando su tiempo de vida.
			            \item Cuando se termina el tiempo se recibe error de que no llega, TTL
			                  expired, que también informa en que IP y router se ha terminado.
			                  Vuelve a mandando paquetes como más tiempo de vida.
			            \item Cuando llega al destino, port unreachable, conocemos la ruta
			                  tomada.
		            \end{itemize}
	      \end{itemize}
\end{itemize}

\chapter{TEMA 5: Network Layer Control Plane}

\section{5.1 Introduction}



La función del plano de control es determinar el camino que deben
seguir los paquetes desde el origen hasta la salida.

A diferencia que el plano de datos que es elegir la salida apropiada
del router.

Dos aproximaciones:

\begin{itemize}
	\item Per-router: Configurar cada router/dispositivo manualmente.
	      \begin{itemize}
		      \item Todo y cada uno de los router tiene un algoritmo de enrutado,
		            que le configura las tablas de ruta.
	      \end{itemize}
	\item SDN -- Software Defined Networking: Todo el enrutado se hace
	      mediante software desde un punto centralizado.
	      \begin{itemize}
		      \item Hay un controlador remoto que configura las tablas de los
		            routers, un proceso centralizado que se comunica con todos los
		            routers.
	      \end{itemize}
\end{itemize}


\section{5.2 Routing Algorithms}

Protocolos de enrutamiento: Tratan de buscar el mejor camino en
comunicaciones host to host, de punto a punto.

\begin{itemize}
	\item Camino: Secuencia de routers que deben atravesar los paquetes
	      desde el host inicial dado el host destino.
	\item Se puede buscar la mejor, pero con respecto a varios parámetros
	      como coste, rapidez o menos congestión.
\end{itemize}

Se representan en forma de grafo:

\begin{itemize}
	\item Los vértices son los routers.
	\item Los arcos son los enlaces entre routers.
	\item Los costes de los arcos son el coste en atravesarlo de un punto a
	      otro. Viene dado por el operador de red. Los conectados
	      directamente tienen un valor, si no es infinito el coste entre
	      ambos.
\end{itemize}

Clasificación de los algoritmos de routing: Dos planos, global o
descentralizada y estática o dinámica.

\begin{itemize}
	\item Global: Todos los routers tienen completa información sobre la
	      topología y costes de enlace.

	      \begin{itemize}
		      \item Algoritmo de estado de enlace.
	      \end{itemize}
	\item Descentralizada: La información está distribuida, cada router solo
	      conoce el estado y costes de sus vecinos físicamente conectados.
	      Es un proceso iterativo de computación e intercambio de
	      información con los vecinos.

	      \begin{itemize}
		      \item Algoritmo de vector de distancias.
	      \end{itemize}
	\item Estática: Las rutas cambian poco en el tiempo.
	\item Dinámica: Las rutas cambian rápidamente, actualización periódica
	      en respuesta a cambios en el coste de enlaces.
\end{itemize}

Algoritmo estado de enlaces -- link state: Algoritmo de enrutado
estado de enlaces de Dijkstra.

\begin{itemize}
	\item Centralizado: Tiene información completa sobre todos los nodos de
	      la red.
	\item Calcula la ruta de menor coste desde ese nodo al resto de nodos,
	      proporciona la tabla de enrutamiento de ese nodo.
	\item Es iterativo, después de k iteraciones conoce los caminos de menor
	      coste.
	\item Notación:

	      \begin{itemize}
		      \item \(c_{x,y}\): Coste de los enlaces directos, si no los hay
		            infinito.
		      \item \(D(v)\): Estimación actual del coste hasta v.
		      \item \(p(v)\): Nodo anterior a v en la ruta.
		      \item \(N’\): Conjunto de nodos de los que se conoce el camino de
		            menor coste, van entrando los menos del algoritmo.
	      \end{itemize}
	      \pagebreak
	\item Algoritmo:
	      \begin{enumerate}
		      \item Inicialización:
		            \begin{enumerate}
			            \item N' = {u}
			            \item para todo nodo v
			                  \begin{enumerate}
				                  \item si v adyacente a u

				                        entonces D(v) = c(u,v)
				                  \item si no D(v) = $\infty$
			                  \end{enumerate}
		            \end{enumerate}
		      \item Lazo
		            \begin{enumerate}
			            \item buscar w no en N' tal que D(w) sea el mínimo
			            \item añadir w a N'
			            \item para todo v adyacente a w y no en N', actualiza D(v):

			                  D(v) = min( D(v), D(w) + c(w,v) )

			            \item /* el nuevo coste a v es: o viejo coste a v, o coste de ruta más barata conocida a w más coste de w a v */
		            \end{enumerate}
		      \item hasta que todos los nodos están en N'
	      \end{enumerate}

	\item La complejidad del algoritmo es \(O(n^2)\), una mejor
	      implementación tendrá \(O(n \log (n))\)
	\item La complejidad de mensaje, cada router debe transmitir la
	      información de estado a los n routers
	\item Posibles oscilación/fluctuaciones de ruta, según la cantidad de
	      tráfico en los enlaces, lo que hace que tenga que recomputar todas
	      las rutas.

\end{itemize}

Algoritmo vector de distancias -- distance vector: Basado en la
ecuación de Bellman-Ford.

\begin{itemize}
	\item \(D_x(y)\): Coste del camino más barato desde x a y
	\item \(D_c(y)=min_v \{ c_{c,v}+D_v(y)\}\) El mínimo se toma sobre todos
	      los vecinos v de x.

	      \begin{itemize}
		      \item Calcula la ruta de menor cote de un nodo x a un nodo y, será el
		            mínimo para todo vecino de ir al vértice más el menor coste
		            desde ese vértice hasta y.
	      \end{itemize}
	\item Algoritmo

	      Ecuación Bellman-Ford (programación dinámica)
	      Definir

	      $d_x(y)$ := coste del camino más barato desde x a y

	      Tenemos $d_x(y) = \min_v \{c(x,v) + d_v(y)\}$ donde el mín se toma sobre todos los vecinos v de x
	      \begin{itemize}
		      \item La clave es que cada nodo envía su vector de distancia solo a sus
		            vecinos, cuando recibe el de los vecinos actualizas tu vector de
		            distancia y lo vuelves a mandar.
		      \item Iterativo, asíncrono: Una iteración local viene causada por

		            \begin{itemize}
			            \item El cambio de coste en el enlace local
		            \end{itemize}
		      \item Mensaje de actualización de DV desde un vecino.
		            \begin{enumerate}
			            \item espera (un cambio en coste
			                  de enlace local; o mensaje
			                  de otro vecino)

			            \item recomputa la estimación

			            \item si DV a cualquier dest ha
			                  cambiado, notifica a los
			                  vecinos
		            \end{enumerate}

		      \item Distribuido: cada nodo notifica a los vecinos solo si su propio DV
		            cambia, y los vecinos a sus vecinos, si es necesario.
		      \item Cada iteración va llegando a datos de más lejos, se propaga, y
		            teniendo en cuanto más caminos.
		      \item Los cambios se hacen de forma asimétrica, lo que hace que cambien
		            más rápido los costes.

		            \begin{itemize}
			            \item Bad news travel slow, cuesta superar los costes al escoger los
			                  mínimos.
			            \item Good news travel fast, se superan antes al ser menores.
		            \end{itemize}
	      \end{itemize}
\end{itemize}


Comparación de estado de enlaces y vector de distancias:

\begin{itemize}
	\item Complejidad del mensaje:

	      \begin{itemize}
		      \item LS: Con n nodos, E enlaces, se envían \(O(nE)\) mensajes.
		      \item DV: Intercambio solo entre vecinos.
	      \end{itemize}
	\item Complejidad de la convergencia:

	      \begin{itemize}
		      \item LS: Algoritmo \(O(n^2)\), necesita \(O(nE)\) enlaces.
		      \item DV: Tiempo de convergencia variable.
	      \end{itemize}
	\item Robustez:

	      \begin{itemize}
		      \item LS: El nodo puede difundir un coste de enlace erróneo, cada nodo
		            computa solo su propia tabla no se propaga.
		      \item DV: El nodo DV puede difundir un coste de ruta erróneo, se
		            propagaría por la red al pasarlo a los vecinos.
	      \end{itemize}
\end{itemize}

Enrutamiento jerárquico:

\begin{itemize}
	\item Hasta ahora hemos estudiado un modelo idealizado, todos los
	      routers idénticos y una red plana, pero no es así en la práctica.
	\item Escala: Hay tantos destinos que no se puede tener una tabla de
	      routing con todos ellos, la tabla sería tan grande que saturaría
	      los enlaces.
	\item Autonomía administrativa: Cada administrador de red querrá
	      controlar su propia porción de la red.
	\item Sistemas Autónomos o dominios -- AS: agregación/agrupación de
	      routers en regiones.
	\item Intra-AS -- Intradominios: Enrutado dentro del mismo dominio.

	      \begin{itemize}
		      \item Routers en el mismo AS ejecutan el mismo protocolo de
		            enrutamiento.
		      \item Routers en diferente AS pueden ejecutar diferentes protocolos
		            intra-AS.
		      \item Gateway router -- Router pasarela: Están en la frontera de su
		            AS. Enlaza con otros routers pasarela.
	      \end{itemize}
	\item Inter-AS -- Interdominio: Enrutado entre dominios.

	      \begin{itemize}
		      \item Los router pasarela hacen el enrutamiento entre dominios.
	      \end{itemize}
\end{itemize}

La tabla de reenvío se configura tanto con algoritmos intra-AS como
inter-dominio.

\begin{itemize}
	\item Entradas intra-AS para destinos internos.
	\item Entradas inter-AS e intra-AS para destinos externos.
\end{itemize}

Los router de un dominio deben conocer que destinos tienen los
dominios vecinos para saber a qué router pasarela hay que enviar los
datagramas, esos datos los proporciona el routing inter-AS.

\section{5.3 Intra-AS Routing in the Internet: OSPF}

Protocolos intradominio más comunes, llamados IGP -- Interior
Gateway Protocols:


\subsection{RIP -- Routing Information Protocol (incluido en la distribución BSD-UNIX en 1982)}

\begin{itemize}
	\item Basado en vector de distancia.

	      \begin{itemize}
		      \item Permite un máximo de 15 saltos, cada enlace cuesta 1.
		      \item Intercambia con los routers vecinos cada 30 segundos, llamado
		            anuncio RIP.
		      \item En cada anuncio, lista de hasta 25 subredes destino, en
		            sentido IP.
	      \end{itemize}
	      \pagebreak

	\item Fallo y recuperación de enlace:

	      \begin{itemize}
		      \item Si tras 180 segundo no recibe anuncio de un vecino, entiende
		            que el vecino o el enlace han muerto.
		      \item Invalida rutas a través de muerto.
		      \item Envía anuncios a los demás vecinos, y estos si actualizan su
		            vector enviaran la suya.
		      \item Si muere la información se propaga rápido.
		      \item Inversa envenenada: Se usa para evitar bucles ping-pong, se
		            considera distancia infinita 16 saltos, ya que supera el
		            límite de saltos.

		            \begin{itemize}
			            \item En la práctica se pone valor infinito por el que debe pasar,
			                  de esta manera este no tratara de pasar por él, y al resto
			                  les informa del valor real (el coste desde ese nodo al
			                  destino)
			            \item Si se corta un enlace con un router, informara de coste
			                  infinito (16) a los vecinos de esta manera tardaran menos en
			                  actualizar los costes.
		            \end{itemize}
		      \item Cuenta hasta infinito: Cuando cambia el coste de un enlace
		            provocando que se tarden infinito o muchos ciclos en
		            estabilizar, ya que el que se encuentra directamente afectado
		            por ese aumento tratara de llegar por otro lado, pero lo que
		            no sabe es que ese lado le utilizaba a él para llegar y se
		            hace un bucle de actualizaciones. Una solución es suponer que
		            una vez que la distancia es 16 es infinito, de esta manera
		            para de calcular la distancia hacia ese nodo.
	      \end{itemize}
	\item Las tablas de enrutamiento RIP se manejan a nivel de aplicación
	      por el Daemon route-d.
	\item Los anuncios se mandan en paquetes UDP.
	\item En desuso.
\end{itemize}
\subsection{EIGRP -- Enhanced Interior Gateway Routing Protocol.}

\begin{itemize}
	\item Basado en vector de distancia.
	\item Conocido como Propiedad Cisco.
\end{itemize}
\pagebreak

\subsection{OSPF -- Open Shortest Path First.}

\begin{itemize}
	\item Basado en estado de enlace.

	      \begin{itemize}
		      \item Inunda de paquetes, el anuncio lleva una entrada por cada
		            enlace, los anuncios se difunden a todos los demás routers del
		            AS.
		      \item Los mensajes se transmiten mediante IP, no TCP o UDP.
		      \item Cada nodo conoce el mapa topológico completo.
		      \item Se calcula mediante Dijkstra.
		      \item Hay distintas métricas para calcular, retraso, ancho de banda,
		            etc.
	      \end{itemize}
	\item Es abierto, disponible públicamente.
	\item Seguridad: todos los mensajes van autenticados para evitar
	      intrusiones maliciosas.
	\item Jerarquía OSPF: 2 niveles.

	      \begin{itemize}
		      \item Back bone - Troncal:

		            \begin{itemize}
			            \item Formado por los routers de borde de área, están en ambas,
			                  resumen las distancias a otras redes dentro del área.
			            \item Los routers troncales- backbone routers, ejecutan el
			                  enrutado OSPF en los límites del área.
			            \item Routers de frontera -- boundary routers, conectan otras
		            \end{itemize}
		      \item Área local:

		            \begin{itemize}
			            \item Formado por routers locales o internos y los routers de
			                  borde de área.
			            \item En este nivel es donde se realizan los anuncios de estado de
			                  enlace.
			            \item Cada nodo tiene la topología de área.
		            \end{itemize}
	      \end{itemize}
	\item Equivalente al protocolo IS-IS.
\end{itemize}

\pagebreak
\section{5.4 Routing Among the ISPs: BGP}

Enrutado Interdominio:

\begin{itemize}
	\item BGP -- Border Gateway Protocol:

	      \begin{itemize}
		      \item Protocolo path vector.
		      \item Es el protocolo que utiliza por defecto para el enrutado
		            Interdominio.
		      \item Permite a las subredes publicar su existencia y los destinos que
		            puede alcanzar, al resto de internet.
		      \item Provee a cada red:

		            \begin{itemize}
			            \item eBGP: Obtener la información alcanzable de los dominios
			                  vecinos. Entre dominios.
			            \item iBGP: Propaga la información de alcance entre routers del
			                  dominio. Dentro del dominio.
		            \end{itemize}
		      \item Los router Gateway - pasarela ejecutan eBGP e iBGP.
		      \item Sesión BGP: Conexión TCP semipermanente de intercambio de
		            mensaje entre dos routers BGP, pares.

		            \begin{itemize}
			            \item Llevan la información sobre las rutas hasta las diferentes
			                  redes destinos en forma de prefijos.
		            \end{itemize}
		      \item Si hay varias rutas se escogerá la de menor número de saltos.
	      \end{itemize}
\end{itemize}

¿Por qué diferentes enrutados, intra e inter dominio?

\begin{itemize}
	\item Políticas:

	      \begin{itemize}
		      \item Interdominio: el administrador quiere control sobre como enrutar
		            su tráfico, y quien enruta a través de su red.
		      \item Intradominio: administrador único, que busca la eficiencia del
		            enrutado, no hace falta negociar al ser solo 1.
	      \end{itemize}
	\item Escala: Permite reducir el tamaño de tabla y el número de mensajes
	      enviados.
	\item Rendimiento:

	      \begin{itemize}
		      \item Interdominio: se centra en la política de alcanzar el dominio
		            más que en el rendimiento.
		      \item Intradominio: Se centra en la eficiencia de la ruta.
	      \end{itemize}
\end{itemize}

Enrutado de la patata caliente -- Hot potato routing: Cuando hay
varias salidas elige la salida local que conlleva menor coste
interno. Sin importar si hay más o menos saltos externos al dominio.

Enrutado broadcast -- por difusión: Envío masivo. Envía paquetes a
todos los nodos desde el origen. Replicar desde el origen no es
eficiente. Hay que controlar duplicados.

\begin{itemize}
	\item Inundación: Cuando un nodo recibe un paquete broadcast, envía
	      copias a todos sus vecinos.

	      \begin{itemize}
		      \item El problema es que genera ciclos y tormentas de difusión.
	      \end{itemize}
	\item Inundación controlada: el nodo solo difunde los paquetes broadcast
	      si no ha difundido el mismo paquete previamente.

	      \begin{itemize}
		      \item El nodo guarda memoria de la identidad de los paquetes ya
		            difundidos
		      \item O hace Reenvío por el camino inverso -- Reverse path forwarding
		            RPF: solo se reenvía un paquete si ha llegado por el camino más
		            corto desde su origen, evitando bucles.
	      \end{itemize}
	\item Árbol de recubrimiento -- Spanning Tree: Ningún nodo recibe
	      paquetes redundantes.

	      \begin{itemize}
		      \item Primero, se construye un árbol de nodos.

		            \begin{itemize}
			            \item Método basado en nodo central.

			                  \begin{itemize}
				                  \item Cada nodo envía un mensaje de adhesión al nodo central,
				                        origen, por medio de unicast -- unidifusión.
				                  \item Mandan un solo mensaje con destino el origen, si llega se
				                        establece esa rama del árbol.
				                  \item El mensaje se envía hasta que es recibido por uno que ya
				                        pertenece al árbol.
			                  \end{itemize}
			            \item Los nodos mandan copias solo a lo largo del árbol, a los
			                  siguientes siguiendo la estructura, excepto al nodo que se lo
			                  haya enviado.
		            \end{itemize}
	      \end{itemize}
\end{itemize}

Enrutado multicast -- multidifusión, problemas.

\begin{itemize}
	\item Objetivo: Encontrar un árbol que conecte routers que pertenezca al
	      grupo multicast.
	\item Árbol: no se usan todas las rutas entre routers.
	\item Basado en el origen: árboles diferentes para orígenes diferentes.
	\item Árbol compartido: mismo árbol para todos los miembros del grupo.
\end{itemize}

\section{5.6 ICMP: The Internet Control Message Protocol}
\href{https://drive.google.com/file/d/1B-h5Mxn93RJ-fWKjj9H8U_rHdbnS8vVq/view?usp=sharing}{Acceso en Drive a las diapositivas}

\chapter{TEMA 6: Link Layer}

\section{6.1 Link Layer: Introduction and Services}

Capa de enlace: Transferencia fiable de tramas entre equipos
conectados dentro de una misma red de área local. Tiene la
responsabilidad de transferir datagramas de un nodo al nodo
físicamente adyacente a través de un enlace.

Vamos a ver:

\begin{itemize}
	\item Funciones:

	      \begin{itemize}
		      \item Detección y corrección de errores.
		      \item Compartición de accesos al canal. Regula el acceso.
		      \item Direccionamiento a nivel MAC.
		      \item Redes de área local: Ethernet, VLAN.
	      \end{itemize}
	\item Implementación e instanciación de las tecnologías del nivel de
	      enlace.
\end{itemize}

Terminología:

\begin{itemize}
	\item Nodos: Hosts y routers.
	\item Enlaces: Canales de comunicación que conectan nodos adyacentes.

	      \begin{itemize}
		      \item Wired: cableados.
		      \item Wireless: inalámbricos.
		      \item LANs.
	      \end{itemize}
	\item Trama: Paquete del nivel 2, encapsula datagramas.
\end{itemize}

Cada protocolo de enlace proporciona diferentes servicios.

Los datagramas son transferidos por diferentes protocolos de enlace
según los distintos enlaces:

\begin{itemize}
	\item Ethernet como primer enlace.
	\item Frame delay como enlace intermedio.
	\item 802.11 como último enlace.
\end{itemize}

Servicios de la capa de enlace:

\begin{itemize}
	\item Entramado -- Limitación de tramas:

	      \begin{itemize}
		      \item Encapsula los datagramas dividiéndolos en trozos a los que les
		            pone una cabecera, y se identifica el comienzo y fin de cada
		            datagrama.
		      \item Accede al canal si el medio es compartido.
		      \item Las direcciones MAC identifica origen y destino a nivel de
		            enlace, son distintas a la dirección IP.
	      \end{itemize}
	\item Entrega fiable entre nodos adyacentes:

	      \begin{itemize}
		      \item Rara vez se usan en canales con pocos errores.
		      \item Enlaces inalámbricos: alta tasa de error.
	      \end{itemize}
	\item Control de flujo entre nodos: Adecuar la velocidad entre los nodos
	      adyacentes origen y destino.
	\item Detección de errores: Errores causados por la atenuación de señal,
	      ruido. Detecta y avisa al emisor.
	\item Corrección de errores: El receptor identifica y corrige errores de
	      bit sin necesidad de retransmisión. Técnica: FEQ.
	\item Half-duplex y full-duplex: Con half duplex, ambos nodos de los
	      extremos del enlace pueden transmitir, pero no a la vez.
\end{itemize}

¿Dónde se implementa?

\begin{itemize}
	\item Está en todos y cada uno de los hosts.
	\item Se implementa en el adaptador en NIC -- network interface card
	      (Tarjeta de red).
	\item Conectado a los buses de los hosts.
	\item Combinación de Software, Hardware, Firmware.

\end{itemize}

Comunicación:
\begin{itemize}
	\item Emisor: Desde la NIC

	      \begin{itemize}
		      \item Encapsula el datagrama en una trama.
		      \item Añade bits para el control de errores, control de flujo, etc.
		      \item Mira si el canal está disponible.
	      \end{itemize}
	\item Se asegura de que está disponible el enlace.
	\item Receptor: Lo recibe la NIC.

	      \begin{itemize}
		      \item Busca errores, control de flujo, etc.
		      \item Extrae el datagrama, y lo pasa a niveles superiores.
	      \end{itemize}
\end{itemize}


\section{6.2 Error Detection and Correction Techniques}

\section{6.3 Multiple Access Protocols}


Dos tipos de enlaces:

\begin{itemize}
	\item Punto a punto: PPP por red telefónica. Enlace punto a punto entre
	      conmutador Ethernet y el Host.
	\item Difusión -- Broadcast (compartición de cable o medio): Ethernet
	      antigua. LAN 802.11 inalámbrica.

	      \begin{itemize}
		      \item Wifi o por satélite.
		      \item Debe haber mecanismos que controlen quien hace uso del canal.
	      \end{itemize}
\end{itemize}

Canal único compartido para difusión.

Interferencia: cuando dos o más nodos transmiten simultáneamente.

Colisión: Si un nodo recibe dos o más señales a la vez.

Protocolo de acceso Multiple: Algoritmo distribuido que determina de
qué modo los nodos comparten el canal. La comunicación sobre como
compartir el canal va sobre el mismo canal.

Protocolo de acceso Multiple ideal:

\begin{itemize}
	\item Múltiples accesos al canal con ratio R bps.
	\item Deseable:

	      \begin{itemize}
		      \item Cuando 1 nodo quiere transmitir usa velocidad R.
		      \item Si hay M nodos cada uno usa una fracción R/M.
		      \item Totalmente descentralizada: No existe un nodo especial para
		            coordinar la transmisión. No hay ni turnos ni sincronización de
		            relojes.
		      \item Simple.
	      \end{itemize}
\end{itemize}
\pagebreak

Clasificación:

\subsection{Reparto del canal -- Partición del canal:}
Dividir el canal en
piezas más pequeñas, de tiempo o frecuencias. Reservas un nodo
para uso exclusivo.
\begin{itemize}
	\item TDMA: Acceso por multiplexación en el tiempo.

	      \begin{itemize}
		      \item Se accede al canal en rondas.
		      \item Cada estación tiene espacios de tiempo fijo en cada ronda.
		      \item Los slots no usados se desaprovechan.
	      \end{itemize}
	\item FDMA: Acceso múltiple por división en frecuencia.

	      \begin{itemize}
		      \item Se divide la frecuencia entre los accesos.
		      \item Cada estación tiene su frecuencia fija.
		      \item El espectro del canal se divide en bandas.
		      \item Cuando no transmite la banda queda desocupada.
	      \end{itemize}
\end{itemize}

\subsection{Acceso aleatorio -- De contienda}
No se particiona, permite las
colisiones y se necesita recuperación de colisiones.


Cuando un nodo tiene un paquete que enviar:

\begin{itemize}
	\item Transmite a la velocidad máxima del canal.
	\item No hay coordinación entre nodos.
\end{itemize}

Dos o más nodos transmitiendo provocan colisión.

Especifica:

\begin{itemize}
	\item Como detecta colisiones.
	\item Como recuperarse de colisión.
\end{itemize}
\subsubsection{ALOHA puro -- Pure ALOHA}


Más simple, no requiere sincronización, si quiere transmite.

Cuando llega la trama, transmite.

La probabilidad de colisión aumenta: puede colisionar con las
siguientes.

Si se produce colisión espera un tiempo aleatorio antes de
volver intentar transmitir.

Eficiencia: 18\%, peor que ALOHA ranurado.

\subsubsection{ALOHA ranurado -- Slotted ALOHA:}



Divide el tiempo de uso del canal en \enquote{cuantos}. Cuando hay
colisión espera un tiempo aleatorio, y cuando pasa el tiempo
debe esperar que empiece un cuanto/franja.

Suposiciones:

\begin{itemize}
	\item Tramas del mismo tamaño.
	\item Tiempo dividido en franjas del mismo tamaño.
	\item Se empieza a transmitir al comienzo del slot.
	\item Los nodos se sincronizan.
	\item Si dos o más nodos transmiten en el mismo slot, todos los
	      demás detectan la colisión.
\end{itemize}

Operación:

\begin{itemize}
	\item Cuando un nodo tiene una trama para transmitir:

	      \begin{itemize}
		      \item Si no hay colisión: el nodo puede transmitir una nueva
		            trama en el slot siguiente.
		      \item Si hay colisión: el nodo retransmitirá la trama en cada
		            slot subsiguiente con una probabilidad p hasta que
		            transmita con éxito. Se espera un tiempo.
	      \end{itemize}
\end{itemize}

Cuando colisionan ninguna de las transmisiones tiene éxito .

Pros:

\begin{itemize}
	\item Un nodo activo puede transmitir continuamente a velocidad
	      máxima
	\item Altamente descentralizado
	\item Simple
\end{itemize}

Contras:

\begin{itemize}
	\item Colisiones gastan slots
	\item Existen slots desocupados
	\item Los nodos tienen que ser capaces de detectar colisión en
	      menos que transmitir. Puede haber colisiones no detectadas
	      por el protocolo.
	\item Reloj de sincronización
\end{itemize}

Eficiencia: Fracción más larga de slots exitosos.

Como mucho el canal se puede usar para transmisiones con éxito
el 37\% del tiempo.


\subsubsection{CSMA -- Carrier Sense Multiple Access -- Acceso múltiple con
	sondeo de portadora}

Escucha el canal, para saber si está libre u ocupada.

Si está libre transmite, si no espera.

No interrumpe.

Mientras transmite no escucha.

El retraso en la propagación puede hacer que un nodo no oiga a
otro.

Colisión: Se malgasta el tiempo en enviar una trama completa.

A tener en cuenta: El papel que desempeñan la distancia y el
retraso en la propagación, para determinar la probabilidad de
colisión.

CSMA/CD: CSMA con detección de colisiones.

\begin{itemize}
	\item Como CSMA, pero escucha durante la transmisión.
	\item Si llega una colisión, este deja de transmitir y espera un
	      tiempo aleatorio.
	\item Las colisiones se detectan en menos tiempo.
	\item Dirección de colisión: Sencillo en LAN cableadas y difícil
	      en LAN inalámbricas.
\end{itemize}

Uno de los protocolos más usados es Ethernet CSMA/CD:

\begin{itemize}
	\item Recibe de la tarjeta de red el datagrama y crea una trama.
	\item Escucha el canal:

	      \begin{itemize}
		      \item Si está libre: Empieza a transmitir.
		      \item Si está ocupado: Espera que se libere y entonces
		            transmite.
	      \end{itemize}
	\item Si transmite la trama y no hay colisión, se completa.
	\item Si detecta otra transmisión, se detiene y manda señal de
	      atasco.
	\item Después de abortar, NIC entra en retroceso binario (binary
	      backoff)

	      \begin{itemize}
		      \item Espera un tiempo y vuelve a escuchar el canal.
		      \item Mas colisiones provocan que el intervalo de espera se
		            alargue de esta manera se ajusta a la carga del canal.
		      \item Espera 512*K, siendo K un valor entre 0 y \(2^{m}-1\) para
		            m colisiones.
	      \end{itemize}
	\item Mejor rendimiento que ALOHA: más simple, más barato y
	      descentralizado.
\end{itemize}

CSMA/CA se usa en wifi

\begin{itemize}
	\item El emisor reserva el canal para transmitir tramas, para ello
	      transmite pequeños paquetes para solicitar enviar.

	      \begin{itemize}
		      \item El emisor primero transmite RTS -- request to send usando
		            CSMA.
		      \item El receptor envía CTS -- clear to send, los envía la
		            estación base en respuesta a RTS, diciendo que emisor
		            puede transmitir.
		      \item Entonces el emisor al que se lo envía transmite y el resto
		            los aplaza.
	      \end{itemize}
\end{itemize}

Los anteriores son por cables. Ahora por Wireless:

\begin{itemize}
	\item IEEE 802.11: Multiple acceso.

	      \begin{itemize}
		      \item avoid collisions: 2+ nodes transmitting at same time
		      \item 802.11: CSMA - sense before transmitting

		            \begin{itemize}
			            \item don't collide with detected ongoing transmission by
			                  another node
		            \end{itemize}
		      \item 802.11: no collision detection!

		            \begin{itemize}
			            \item difficult to sense collisions: high transmitting signal,
			                  weak received signal due to fading
			            \item can't sense all collisions in any case: hidden terminal,
			                  fading
			            \item goal: avoid collisions: CSMA/CollisionAvoidance
		            \end{itemize}
	      \end{itemize}
	      \pagebreak

	\item IEEE 802.11 MAC Protocol: CSMA/CA

	      \begin{itemize}
		      \item 802.11 emisor:

		            \begin{itemize}
			            \item Si el canal está libre entonces para DIFS

			                  \begin{itemize}
				                  \item entonces transmite la trama.
			                  \end{itemize}
			            \item Si está ocupado

			                  \begin{itemize}
				                  \item Empieza un temporizador con tiempo aleatorio.
				                  \item El contador progresa mientras el canal esta idle.
				                  \item Cuando para el temporizador transmite.
				                  \item Si no recibe ACK aumenta el temporizador.
			                  \end{itemize}
		            \end{itemize}
		      \item 802.11 receptor:

		            \begin{itemize}
			            \item Si llega bien: Espera SIFS y envía ACK.
		            \end{itemize}
	      \end{itemize}
\end{itemize}


\subsection{Por turnos -- Paso del testigo} Los nodos cogen un turno para su
uso, y luego ira el del siguiente turno. Sin embargo, si un nodo
tiene mucho que enviar su turno será más largo.



Por división: Comparte el canal eficientemente con alta carga.
Ineficiente a baja carga.

Aleatorio: Eficiente a baja carga, un solo nodo puede utilizar
todo el canal. Con alta carga, hay muchas colisiones.

Usa lo mejor de ambos.

Sondeo: El nodo maestro invita a transmitir a los nodos
esclavos. Se emplea típicamente con nodos tontos.

\begin{itemize}
	\item Hay que tener en cuenta el tiempo que se tarda en sondear, la
	      latencia y un único punto de fallo, el nodo maestro.
\end{itemize}

Paso de testigo: Una trama especial token es intercambiado de un
nodo al siguiente.

\begin{itemize}
	\item El token es un mensaje, que cuando un nodo lo tiene pueden
	      transmitir y cuando termina se lo pasa a otro.
	\item Hay que tener en cuenta el tiempo de pasar el token, la
	      latencia y un único punto de fallo, el token.
\end{itemize}
\pagebreak

\section{6.4 Switched Local Area Networks}

Direccionamiento a nivel de enlace.

\subsection{Direccionamiento ARP - Address Resolution Protocol}

\begin{itemize}
	\item Direccionamiento MAC

	      \begin{itemize}
		      \item Usado localmente entre interfaces físicamente conectadas.
		      \item Direcciones de 48 bit, 6 pares de números hexadecimales.

		            \begin{itemize}
			            \item 1A-2F-BB-76-09-AD
		            \end{itemize}
		      \item Se reserva la dirección todo 0's y 1's.
		      \item Cada interfaz tiene una dirección MAC única en esa red de área
		            local (se supone que no tiene por qué ser única globalmente,
		            pero es muy probable) y una dirección IP local única.
		      \item IEEE administra la asignación de direcciones MAC.
		      \item Los fabricantes comprar parte del espacio de direcciones MAC.
		      \item La dirección MAC es portátil, puede cambiar de LAN, pero la
		            jerarquía de dirección IP no es portátil.
	      \end{itemize}
	\item ARP: Protocolo de Resolución de Direcciones.

	      \begin{itemize}
		      \item Cada nodo IP tiene una tabla de las direcciones MAC
		            correspondiente a la IP y un TTL.
		            \begin{itemize}
			            \item \textless{} IP address; MAC address; TTL \textgreater{}
		            \end{itemize}
		      \item TTL: Tiempo en el que olvidar esa asociación, normalmente 20 minutos.
		            Tiempo de vida de una entrada en la tabla.
		      \item Es plug-and-play: Los nodos crean su tabla ARP sin intervención del administrador de red.
		      \item Proceso: A quiere enviar un datagrama a B, y la dirección MAC de B no está en la tabla ARP de A.
		            \begin{itemize}
			            \item A quiere el MAC de B, entonces manda una solicitud de ARP en abierto a todos los nodos.
			            \item B recibe la solicitud ARP y responde con su dirección MAC a A.
			            \item A recibe la respuesta de B la añade a su ARP table hasta que no sea necesaria, TTL.
		            \end{itemize}
		            \pagebreak
		      \item Enviar un datagrama de A a B a través de R:
		            \begin{itemize}
			            \item Suponemos:
			                  \begin{itemize}
				                  \item A conoce la dirección IP y MAC de B.
				                  \item A conoce la dirección IP y MAC del primer router del primer salto, R
			                  \end{itemize}

			            \item A crea un datagrama IP con la dirección IP origen de A, destino B.
			            \item A crea una trama con la dirección MAC de R como destino, la trama contiene el datagrama IP de A a B.
			            \item Trama enviada de A a R.
			            \item Trama recibida en R, se extrae el datagrama y se pasa a IP. El router lee la trama y datagrama para saber dónde debe ser el siguiente salto.
			            \item R reenvía el datagrama con dirección IP origen de A y destino B. No lo cambia
			            \item R crea una trama con la dirección MAC de B como destino, la trama contiene el datagrama IP de A a B. Origen R y destino B.
			            \item B recibe la trama, extrae el datagrama IP y lo pasa a la capa superior.
		            \end{itemize}
	      \end{itemize}
\end{itemize}




\subsection{Ethernet}

Tecnología LAN cableada dominante.

\begin{itemize}
	\item Ampliamente usada.
	\item Simple y barato.
	\item Velocidad entre 10 Mbps y 400 Gbps.
\end{itemize}

Topología física:

\begin{itemize}
	\item La topología en bus fue popular en los 90, todos en el mismo
	      dominio de colisión.
	\item Hoy en ida se usan switches - conmutadores, que están en el
	      centro y tienen hasta capa de enlace 2. Los nodos no colisionan
	      con ningún otro.

	      \begin{itemize}
		      \item Cada switch ejecuta el protocolo Ethernet.
	      \end{itemize}
\end{itemize}

Switch: Donde se conectan los hosts e implementa la lógica de red.

Router: Separa dominios de difusión.

Estructura de trama Ethernet:
\begin{itemize}
	\item El adaptador emisor encapsula IP en una trama Ethernet.
	      \begin{figure}[H]
		      \ffigbox[\FBwidth]
		      {\caption{Estructura de trama Ethernet}}
		      {\def\svgwidth{.9\textwidth}
			      \input{./img/EEthernet.eps_tex}}
	      \end{figure}
	\item Partes:
	      \begin{itemize}
		      \item Preámbulo: Para sincronizar relojes del dispositivo y separación de tramas.
		            \begin{itemize}
			            \item 7 bytes con el patrón 10101010 seguido de un byte con el patrón 10101011
			            \item se emplea para sincronizar los relojes del emisor y del receptor
		            \end{itemize}

		      \item Direcciones: 6 bytes.
		      \item Tipo: Indica el protocolo de nivel de red.
		      \item Datos.
		      \item CRC: Detección de errores. Se comprueba en la recepción, si se detecta que hay error la trama se descarta.
	      \end{itemize}

\end{itemize}


Servicio sin conexión, no fiable.

\begin{itemize}
	\item Servicio sin conexión: No existe un protocolo de handshaking -
	      negociación entre los NIC emisor y receptor.
	\item No fiable: Detecta errores, pero no sabe resolverlos, no envía
	      asentimientos. Puede resolver el fallo si se implementa en una
	      capa superior transmisión fiable.
	\item Protocolo MAC de Ethernet: CSMA/CD no ranurado.
\end{itemize}

802.3 Estándar Ethernet: Capa enlace y física

\begin{itemize}
	\item Hay diferentes Ethernet según la velocidad y medio de la capa
	      física.

	      \begin{itemize}
		      \item El formato de trama y el protocolo MAC son comunes.
		      \item Velocidad: 2 Mbps, 10 Mbps, 100 Mbps, 1 Gbps, 10 Gbps.
		      \item Capa física: fibra óptica, cable.
	      \end{itemize}
\end{itemize}

Redes inalámbricas y móviles:

\begin{itemize}
	\item Hay más dispositivos Wireless que wired (10 a 1 en 2019)
	\item Dos importantes retos:

	      \begin{itemize}
		      \item Inalámbrico: Comunicar por enlace Wireless.
		      \item Movilidad: Manejo del usuario móvil que cambia el punto de
		            conexión a la red.
	      \end{itemize}
	      \pagebreak
	\item Elementos:

	      \begin{itemize}
		      \item Hosts inalámbricos: Laptop, smartphone, IoT. Ejecutan
		            aplicaciones.
		      \item Estación base: Típicamente conecta móviles en una red
		            cableada.
		            \begin{itemize}
			            \item Relay: Responsable de enviar paquetes entre redes cableadas y
			                  host cableados.
		            \end{itemize}

		      \item Enlace inalámbrico: Típicamente conecta móviles y la estación base.
		            Varios ratios, distintas y frecuencias de transmisión.
	      \end{itemize}

	\item Modo infraestructura:
	      \begin{itemize}
		      \item Handoff: Un móvil puede cambiar de estación base a la que está conectado.
		      \item Estación base conecta móviles en una red cableada.
	      \end{itemize}

	\item Modo ad hoc:
	      \begin{itemize}
		      \item No hay estaciones base.
		      \item Los nodos se transmiten la información directamente.
		      \item Los nodos se organizan ellos mismos, enrutados a través de los mimos.
	      \end{itemize}

	\item 802.11 Arquitectura LAN
	      \begin{itemize}
		      \item Los hosts inalámbricos se comunican con la estación base = Access point.
		      \item BSS - La infraestructura célula contiene:
		            \begin{itemize}
			            \item Hosts inalámbricos.
			            \item Estación base.
			            \item Entre los hosts se usa modo ad hoc.
		            \end{itemize}

		      \item Canales y asociación:
		            \begin{itemize}
			            \item El espectro se divide en canales con distintas frecuencias.
			            \item Los dispositivos que entran se deben asociar con el punto de acceso (Meter la pass del wifi)
			            \item Cuando se asocia con un punto de acceso, se puede hacer autenticación, típicamente se hace DHCP para conseguir una IP.
		            \end{itemize}
		      \item Escaneo pasivo:
		            \begin{itemize}
			            \item Los beacons frames envían solicitudes para asociarse con los hosts.
			            \item Beacon frame: Pequeña trama donde va información sobre el punto de acceso y la MAC.
		            \end{itemize}

		      \item Escaneo activo:
		            \begin{itemize}
			            \item Los dispositivos son los que van mandando solicitudes.
		            \end{itemize}
		            \pagebreak
		      \item Trama: Direccionamiento.
		            \begin{itemize}
			            \item Partes:
			                  \begin{itemize}
				                  \item Dentro de control de trama:

				                        Tipo: Tipo de trama, RTS, CTS, ACK y data.

				                  \item Duración: Duración de reserva del tiempo de transmisión. RTS petición y CTS envía.
				                  \item Dirección 1: Dirección MAC de destino.
				                  \item Dirección 2: Dirección MAC del que transmite la trama.
				                  \item Dirección 3: Dirección MAC del router asociado al Access point.
				                  \item Seq control – secuencia de control: Detección de tramas. Para saber cuál es.
				                  \item Dirección 4: Dirección MAC cuando se usa modo ad hoc.
			                  \end{itemize}

		            \end{itemize}



	      \end{itemize}
\end{itemize}

\subsection{Switches}

Un switch es un dispositivo en la capa de enlace con una función
importante.

\begin{itemize}
	\item Almacena y reenvía tramas ethernet.
	\item Cuando recibe una trama mira la dirección MAC y con la tabla
	      sabe por qué enlace lo debe pasar, usando CSMA/CD.
	\item Es transparente para los hosts.
	\item plug-and-play, self-learning: Autoaprenden, no hace falta
	      configurarlo según se reciben tramas se van rellenando las
	      tablas de manera dinámica. Cada nodo tiene una tabla de reenvío
	      donde guarda la dirección MAC, la interfaz un TTL.
\end{itemize}

Los hosts se conectan a los switches con conexiones dedicadas
directamente.

El protocolo ethernet se usa en cada enlace de entrada:

\begin{itemize}
	\item Sin colisiones y puedo full duplex.
	\item Cada enlace es un dominio de colisión.
	\item Un switch puede recibir y reenviar datos simultáneamente, pero
	      por un mismo enlace solo se puede transmitir uno a la vez.
\end{itemize}
\pagebreak
Autoaprende: El switch aprende cuáles son los hosts alcanzables
según la MAC origen e interfaces de entrada de las tramas que
recibe.

\begin{itemize}
	\item Se va rellenando la tabla con el uso del switch.
	\item Si recibe por la interfaz una trama que procede de A, sabe que
	      si algo es para A se enviara por esa interfaz.
	\item Si no lo conoce inunda las interfaces.
	\item Proceso:

	      \begin{enumerate}
		      \item Registra enlace y MAC del emisor.
		      \item Indexa la tabla usando la dirección de destino.
		      \item Si tiene la entrada para ese destino.

		            \begin{enumerate}
			            \item Si la interfaz es la misma de la que viene la descarta.
			            \item Si no lo envía por la interfaz correspondiente.
		            \end{enumerate}
		      \item Si no la conoce, inunda las interfaces, excepto por la que
		            viene.
	      \end{enumerate}
\end{itemize}

Los switches que autoaprenden pueden conectarse, cuando se ha
reenviado por los que pasa se conectan al almacenar las entradas.
Switch vs router:

\begin{itemize}
	\item Ambas almacenan y reenvían los datos que reciben, unos tramas
	      otros datagramas.

	      \begin{itemize}
		      \item router: De la capa de red.
		      \item switch: De la capa de enlace.
	      \end{itemize}
	\item Ambos usan tablas:

	      \begin{itemize}
		      \item router: Se basa en IP.
		      \item switch: Se basa en MAC.
	      \end{itemize}
\end{itemize}

\subsection{VLAN - Redes de Area Local Virtual}
Un solo dominio de broadcast, todo el tráfico debe cruzar la LAN
entera.

Permite que dispositivos conectados a un switch pertenezcan a otra
red de área local.

Permite a un usuario que no está conectado físicamente, pertenecer
lógicamente a la red mediante un switch.
\pagebreak

VLAN basado en el puerto:

\begin{itemize}
	\item Según el puerto configurado está en una red u otra.
	\item 1 switch muchas VLAN.
	\item Aislamiento de tráfico: Hace que las tramas no se expandan, ni
	      colisionen, entre VLAN distintas solo se popula en la VLAN.
	\item Pertenencia dinámica: La pertenencia a la VLAN es dinámica al
	      cambiar puerto.
	\item Reenvió entre VLAN: Mediante enrutamiento. En la práctica se
	      vende la combinación de router y switch.
	\item En 802.1Q hay 12 bits para el ID de la VLAN
	\item Puerto trunk: Para intercambiar tramas entre dispositivos de una
	      VLAN, pero que físicamente están en varios switches.
	      \begin{itemize}
		      \item Las tramas en VLAN en varios switches no pueden ser el standard
		            802.1
		      \item Se usan 802.1Q para añadir en la cabecera o quitar la
		            cabecera entre los puertos trunk.
	      \end{itemize}
\end{itemize}


\subsection{MPLS}


Solución tecnológica para multiplexar el tráfico, entre la capa
2 y 3.

Su objetivo es conseguir reenvío IP de alta velocidad entre
redes de router capaces de MPLS, de esta tecnología.

Se consulta más rápido usando el identificador.

Coge ideas de redes de circuitos, pero con datagramas IP. Con
respecto a que se pone un identificador dependiendo del origen y
fin.

Añade una cabecera entre la cabecera ethernet y el datagrama.

Reenvía solo consultando la cabecera MPLS, no mira el resto, usa
sus propias tablas.

Prioriza las rutas de baja latencia.

Flexible: El reenvío puede ser distinto que el de IP, ya que
prioriza baja latencia.

Permite detectar rápidamente fallos.

A diferencia de IP, la ruta se puede basar tanto en la dirección
de origen como la de destino, no solo en la de destino.
\pagebreak

Como lo hace:
\begin{itemize}
	\item Va modificando las tablas de enrutamiento de otras capas.
	\item Los routers MPLS usan RSVP-TE para configurar el reenvío, que es una
	      modificación de OSPF, un protocolo de estado de enlace por
	      inundación.
\end{itemize}

\section{6.7 A Day in the Life of a Web Page Request}

\section{7.1 Introduction}

\section{7.3 WiFi: 802.11 Wireless LANs}

\href{https://drive.google.com/file/d/1A_ompfRwG0UC5bUmhosP19GjYcG3iaNC/view?usp=sharing}{Acceso en Drive a las diapositivas}

\href{https://drive.google.com/file/d/1As8rdI9okS-TyZsHl3f6tj1ZKKItx1kT/view?usp=sharing}{Acceso en Drive a las diapositivas}

\href{https://drive.google.com/file/d/1AYFfY-uZcdAW7zipB4o5x_fc4mfXV6Cq/view?usp=sharing}{Acceso en Drive a las diapositivas}

\end{document}